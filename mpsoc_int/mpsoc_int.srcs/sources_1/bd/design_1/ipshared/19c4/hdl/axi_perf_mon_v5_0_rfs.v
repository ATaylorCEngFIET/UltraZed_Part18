//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename     : axi_perf_mon_v5_0_12_register_module_profile.v
// Version      : v5.0
// Description  : register module having all the registers of axi performance
//                monitor read and write logic. Address decoding is also
//                implemented in this module based on which the corresponding 
//                read and write enables being generated
// Verilog-Standard:verilog-2001  
//-----------------------------------------------------------------------------
// Structure:   
//
//  axi_perf_mon_v5_0_12_top.v
//      \-- axi_perf_mon_v5_0_12_dff_async_reset.v
//
//-----------------------------------------------------------------------------
// Description: Used to detect the edge for capture event and reset event
// ~~~~~~~~~~~
//-----------------------------------------------------------------------------

`timescale 1ps/1ps
module axi_perf_mon_v5_0_12_dff_async_reset (
data  ,
clk    ,
reset ,
q     
);
input data, clk, reset ; 
output q;
(*ASYNC_REG = "TRUE" *) reg q;
always @ ( posedge clk or posedge reset)
if (reset) begin
  q <= 1'b1;
end  else begin
  q <= data;
end
endmodule 


//-------------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename     : axi_perf_mon_v5_0_12_async_fifo.v
// Version      : v5.0
// Description  : This is the top level wrapper file for the asynchronous fifo 
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
// --  axi_perf_mon.v
//      \-- axi_perf_mon_v5_0_12_mon_fifo.v
//          \-- axi_perf_mon_v5_0_12_async_fifo.v
//-----------------------------------------------------------------------------
// Author:   NLR 
// History:    
// NLR       07/25/2012      First Version
// ^^^^^^
// NLR       20/03/2012      Updated with FIFO V10_0 version
// ^^^^^^^
// NLR       02/10/2013      Updated to fifo_generator_v11_0 version
// ^^^^^^^
// PKR       17/01/2014      Updated to fifo_generator_v12_0_5 version
//-----------------------------------------------------------------------------
`timescale 1ns/1ps
module axi_perf_mon_v5_0_12_async_fifo
  # (
    parameter C_FAMILY             = "nofamily",
    parameter C_FIFO_DEPTH         = 16, 
    parameter C_DATA_CNT_WIDTH     = 4, 
    parameter C_DATA_WIDTH         = 32,
    parameter C_FULL_FLAGS_RST     = 0,
    parameter C_USE_BLOCKMEM       = 2, //2 = Distributed RAM 1= Block RAM
    parameter C_COMMON_CLOCK       = 0, //0= Different clocks 1= Common clocks
    parameter C_IMPLEMENTATION_TYPE = 2,
    parameter C_USE_FWFT            = 1   
    )
    (
    input  [C_DATA_WIDTH-1:0]  Din, 
    input                      Wr_en, 
    input                      Wr_clk, 
    input                      Rd_en,
    input                      Rd_clk, 
    input                      fifo_rst,    
    output [C_DATA_WIDTH-1:0]  Dout,
    output                     Full,  
    output                     wr_rst_busy,  
    output                     Empty,
    output [C_DATA_CNT_WIDTH-1:0] rd_data_count,
    output [C_DATA_CNT_WIDTH-1:0] wr_data_count,
    output                     almost_empty,  
    output                     almost_full  
    );

   //-------------------- Function to find log base 2 of FIFO_DEPTH
    function integer clogb2;
    input integer depth;   // Depth of fifo
    integer j;
      begin
        j = depth;
        for(clogb2=0; j>0; clogb2=clogb2+1)
           j = j >> 1;
      end
    endfunction

    localparam RD_PNTR_WIDTH = clogb2(C_FIFO_DEPTH)-1;
    localparam WR_PNTR_WIDTH = clogb2(C_FIFO_DEPTH)-1;

    wire Sync_clk = C_COMMON_CLOCK? Wr_clk : 1'b0;
    localparam C_PRELOAD_LATENCY = (C_USE_FWFT==1) ? 0 :1;
    localparam C_PRELOAD_REGS = (C_USE_FWFT==1) ? 1 :0;
    localparam C_EN_SAFETY_CKT = (C_USE_BLOCKMEM==1 && C_COMMON_CLOCK ==0) ? 1 :0;
    wire [RD_PNTR_WIDTH-1:0] zeros = 0; 

   /*----------------------------------------------------------------------
   ------------------- FIFO Generator V11_0 instantiations-------
   --------------------------------------------------------------------*/ 

   fifo_generator_v13_1_2 #(
    .C_COMMON_CLOCK                     (C_COMMON_CLOCK),
    .C_COUNT_TYPE                       (0),
    .C_DATA_COUNT_WIDTH                 (10),
    .C_DEFAULT_VALUE                    ("BlankString"),
    .C_DIN_WIDTH                        (C_DATA_WIDTH),
    .C_DOUT_RST_VAL                     ("0"),
    .C_DOUT_WIDTH                       (C_DATA_WIDTH),
    .C_ENABLE_RLOCS                     (0),
    .C_FAMILY                           (C_FAMILY),
    .C_FULL_FLAGS_RST_VAL               (1),
    .C_HAS_ALMOST_EMPTY                 (1),
    .C_HAS_ALMOST_FULL                  (0),
    .C_HAS_BACKUP                       (0),
    .C_HAS_DATA_COUNT                   (0),
    .C_HAS_INT_CLK                      (0),
    .C_HAS_MEMINIT_FILE                 (0),
    .C_HAS_OVERFLOW                     (0),
    .C_HAS_RD_DATA_COUNT                (1),
    .C_EN_SAFETY_CKT                    (C_EN_SAFETY_CKT),
    .C_HAS_RD_RST                       (0),
    .C_HAS_RST                          (1),
    .C_HAS_SRST                         (0),
    .C_HAS_UNDERFLOW                    (0),
    .C_HAS_VALID                        (0),
    .C_HAS_WR_ACK                       (0),
    .C_HAS_WR_DATA_COUNT                (1),
    .C_HAS_WR_RST                       (0),
    .C_IMPLEMENTATION_TYPE              (C_IMPLEMENTATION_TYPE),
    .C_INIT_WR_PNTR_VAL                 (0),
    .C_MEMORY_TYPE                      (C_USE_BLOCKMEM),
    .C_MIF_FILE_NAME                    ("BlankString"),
    .C_OPTIMIZATION_MODE                (0),
    .C_OVERFLOW_LOW                     (0),
    .C_PRELOAD_LATENCY                  (C_PRELOAD_LATENCY),
    .C_PRELOAD_REGS                     (C_PRELOAD_REGS),
    .C_PRIM_FIFO_TYPE                   ("512x72"),
    .C_PROG_EMPTY_THRESH_ASSERT_VAL     (4),
    .C_PROG_EMPTY_THRESH_NEGATE_VAL     (5),
    .C_PROG_EMPTY_TYPE                  (0),
    .C_PROG_FULL_THRESH_ASSERT_VAL      (13),
    .C_PROG_FULL_THRESH_NEGATE_VAL      (12),
    .C_PROG_FULL_TYPE                   (0),
    .C_RD_DATA_COUNT_WIDTH              (RD_PNTR_WIDTH),
    .C_RD_DEPTH                         (C_FIFO_DEPTH),
    .C_RD_FREQ                          (1),
    .C_RD_PNTR_WIDTH                    (RD_PNTR_WIDTH),
    .C_UNDERFLOW_LOW                    (0),
    .C_USE_DOUT_RST                     (1),
    .C_USE_ECC                          (0),
    .C_USE_EMBEDDED_REG                 (0),
    .C_USE_FIFO16_FLAGS                 (0),
    .C_USE_FWFT_DATA_COUNT              (0),
    .C_VALID_LOW                        (0),
    .C_WR_ACK_LOW                       (0),
    .C_WR_DATA_COUNT_WIDTH              (WR_PNTR_WIDTH),
    .C_WR_DEPTH                         (C_FIFO_DEPTH),
    .C_WR_FREQ                          (1),
    .C_WR_PNTR_WIDTH                    (WR_PNTR_WIDTH),
    .C_WR_RESPONSE_LATENCY              (1),
    .C_MSGON_VAL                        (1),
    .C_ENABLE_RST_SYNC                  (1),
    .C_ERROR_INJECTION_TYPE             (0),
    .C_SYNCHRONIZER_STAGE               (4),
    .C_INTERFACE_TYPE                   (0),
    .C_AXI_TYPE                         (1),
    .C_HAS_AXI_WR_CHANNEL               (0),
    .C_HAS_AXI_RD_CHANNEL               (0),
    .C_HAS_SLAVE_CE                     (0),
    .C_HAS_MASTER_CE                    (0),
    .C_ADD_NGC_CONSTRAINT               (0),
    .C_USE_COMMON_OVERFLOW              (0),
    .C_USE_COMMON_UNDERFLOW             (0),
    .C_USE_DEFAULT_SETTINGS             (0),
    .C_AXI_ID_WIDTH                     (4),
    .C_AXI_ADDR_WIDTH                   (32),
    .C_AXI_DATA_WIDTH                   (64),
    .C_HAS_AXI_AWUSER                   (0),
    .C_HAS_AXI_WUSER                    (0),
    .C_HAS_AXI_BUSER                    (0),
    .C_HAS_AXI_ARUSER                   (0),
    .C_HAS_AXI_RUSER                    (0),
    .C_AXI_ARUSER_WIDTH                 (1),
    .C_AXI_AWUSER_WIDTH                 (1),
    .C_AXI_WUSER_WIDTH                  (1),
    .C_AXI_BUSER_WIDTH                  (1),
    .C_AXI_RUSER_WIDTH                  (1),
    .C_HAS_AXI_ID                       (0),
    .C_HAS_AXIS_TDATA                   (1),
    .C_HAS_AXIS_TID                     (0),
    .C_HAS_AXIS_TDEST                   (0),
    .C_HAS_AXIS_TUSER                   (0),
    .C_HAS_AXIS_TREADY                  (1),
    .C_HAS_AXIS_TLAST                   (0),
    .C_HAS_AXIS_TSTRB                   (0),
    .C_HAS_AXIS_TKEEP                   (0),
    .C_AXIS_TDATA_WIDTH                 (64),
    .C_AXIS_TID_WIDTH                   (8),
    .C_AXIS_TDEST_WIDTH                 (4),
    .C_AXIS_TUSER_WIDTH                 (4),
    .C_AXIS_TSTRB_WIDTH                 (4),
    .C_AXIS_TKEEP_WIDTH                 (4),
    .C_WACH_TYPE                        (0),
    .C_WDCH_TYPE                        (0),
    .C_WRCH_TYPE                        (0),
    .C_RACH_TYPE                        (0),
    .C_RDCH_TYPE                        (0),
    .C_AXIS_TYPE                        (0),
    .C_IMPLEMENTATION_TYPE_WACH         (1),
    .C_IMPLEMENTATION_TYPE_WDCH         (1),
    .C_IMPLEMENTATION_TYPE_WRCH         (1),
    .C_IMPLEMENTATION_TYPE_RACH         (1),
    .C_IMPLEMENTATION_TYPE_RDCH         (1),
    .C_IMPLEMENTATION_TYPE_AXIS         (1),
    .C_APPLICATION_TYPE_WACH            (0),
    .C_APPLICATION_TYPE_WDCH            (0),
    .C_APPLICATION_TYPE_WRCH            (0),
    .C_APPLICATION_TYPE_RACH            (0),
    .C_APPLICATION_TYPE_RDCH            (0),
    .C_APPLICATION_TYPE_AXIS            (0),
    .C_USE_ECC_WACH                     (0),
    .C_USE_ECC_WDCH                     (0),
    .C_USE_ECC_WRCH                     (0),
    .C_USE_ECC_RACH                     (0),
    .C_USE_ECC_RDCH                     (0),
    .C_USE_ECC_AXIS                     (0),
    .C_ERROR_INJECTION_TYPE_WACH        (0),
    .C_ERROR_INJECTION_TYPE_WDCH        (0),
    .C_ERROR_INJECTION_TYPE_WRCH        (0),
    .C_ERROR_INJECTION_TYPE_RACH        (0),
    .C_ERROR_INJECTION_TYPE_RDCH        (0),
    .C_ERROR_INJECTION_TYPE_AXIS        (0),
    .C_DIN_WIDTH_WACH                   (32),
    .C_DIN_WIDTH_WDCH                   (64),
    .C_DIN_WIDTH_WRCH                   (2),
    .C_DIN_WIDTH_RACH                   (32),
    .C_DIN_WIDTH_RDCH                   (64),
    .C_DIN_WIDTH_AXIS                   (1),
    .C_WR_DEPTH_WACH                    (16),
    .C_WR_DEPTH_WDCH                    (1024),
    .C_WR_DEPTH_WRCH                    (16),
    .C_WR_DEPTH_RACH                    (16),
    .C_WR_DEPTH_RDCH                    (1024),
    .C_WR_DEPTH_AXIS                    (1024),
    .C_WR_PNTR_WIDTH_WACH               (4),
    .C_WR_PNTR_WIDTH_WDCH               (10),
    .C_WR_PNTR_WIDTH_WRCH               (4),
    .C_WR_PNTR_WIDTH_RACH               (4),
    .C_WR_PNTR_WIDTH_RDCH               (10),
    .C_WR_PNTR_WIDTH_AXIS               (10),
    .C_HAS_DATA_COUNTS_WACH             (0),
    .C_HAS_DATA_COUNTS_WDCH             (0),
    .C_HAS_DATA_COUNTS_WRCH             (0),
    .C_HAS_DATA_COUNTS_RACH             (0),
    .C_HAS_DATA_COUNTS_RDCH             (0),
    .C_HAS_DATA_COUNTS_AXIS             (0),
    .C_HAS_PROG_FLAGS_WACH              (0),
    .C_HAS_PROG_FLAGS_WDCH              (0),
    .C_HAS_PROG_FLAGS_WRCH              (0),
    .C_HAS_PROG_FLAGS_RACH              (0),
    .C_HAS_PROG_FLAGS_RDCH              (0),
    .C_HAS_PROG_FLAGS_AXIS              (0),
    .C_PROG_FULL_TYPE_WACH              (0),
    .C_PROG_FULL_TYPE_WDCH              (0),
    .C_PROG_FULL_TYPE_WRCH              (0),
    .C_PROG_FULL_TYPE_RACH              (0),
    .C_PROG_FULL_TYPE_RDCH              (0),
    .C_PROG_FULL_TYPE_AXIS              (0),
    .C_PROG_FULL_THRESH_ASSERT_VAL_WACH(1023),
    .C_PROG_FULL_THRESH_ASSERT_VAL_WDCH(1023),
    .C_PROG_FULL_THRESH_ASSERT_VAL_WRCH(1023),
    .C_PROG_FULL_THRESH_ASSERT_VAL_RACH(1023),
    .C_PROG_FULL_THRESH_ASSERT_VAL_RDCH(1023),
    .C_PROG_FULL_THRESH_ASSERT_VAL_AXIS(1023),
    .C_PROG_EMPTY_TYPE_WACH            (0),
    .C_PROG_EMPTY_TYPE_WDCH            (0),
    .C_PROG_EMPTY_TYPE_WRCH            (0),
    .C_PROG_EMPTY_TYPE_RACH            (0),
    .C_PROG_EMPTY_TYPE_RDCH            (0),
    .C_PROG_EMPTY_TYPE_AXIS            (0),
    .C_PROG_EMPTY_THRESH_ASSERT_VAL_WACH(1022),
    .C_PROG_EMPTY_THRESH_ASSERT_VAL_WDCH(1022),
    .C_PROG_EMPTY_THRESH_ASSERT_VAL_WRCH(1022),
    .C_PROG_EMPTY_THRESH_ASSERT_VAL_RACH(1022),
    .C_PROG_EMPTY_THRESH_ASSERT_VAL_RDCH(1022),
    .C_PROG_EMPTY_THRESH_ASSERT_VAL_AXIS(1022),
    .C_REG_SLICE_MODE_WACH              (0),
    .C_REG_SLICE_MODE_WDCH              (0),
    .C_REG_SLICE_MODE_WRCH              (0),
    .C_REG_SLICE_MODE_RACH              (0),
    .C_REG_SLICE_MODE_RDCH              (0),
    .C_REG_SLICE_MODE_AXIS              (0),
    .C_AXI_LEN_WIDTH                    (8),
    .C_AXI_LOCK_WIDTH                   (1)
  ) inst (
    .backup                             (1'b0),
    .backup_marker                      (1'b0),
    .clk                                (Sync_clk),
    .rst                                (fifo_rst),
    .srst                               (1'b0),
    .wr_clk                             (Wr_clk),
    .wr_rst                             (1'b0),
    .rd_clk                             (Rd_clk),
    .rd_rst                             (1'b0),
    .din                                (Din),
    .wr_en                              (Wr_en),
    .rd_en                              (Rd_en),
    .prog_empty_thresh                  (zeros),
    .prog_empty_thresh_assert           (zeros),
    .prog_empty_thresh_negate           (zeros),
    .prog_full_thresh                   (zeros),
    .prog_full_thresh_assert            (zeros),
    .prog_full_thresh_negate            (zeros),
    .int_clk                            (1'b0),
    .injectdbiterr                      (1'b0),
    .injectsbiterr                      (1'b0),
    .sleep                              (1'b0),
    .dout                               (Dout),
    .full                               (Full),
    .almost_full                        (almost_full),
    .wr_ack                             (),
    .overflow                           (),
    .empty                              (Empty),
    .almost_empty                       (almost_empty),
    .valid                              (),
    .underflow                          (),
    .data_count                         (),
    .rd_data_count                      (rd_data_count),
    .wr_data_count                      (wr_data_count),
    .prog_full                          (),
    .prog_empty                         (),
    .sbiterr                            (),
    .dbiterr                            (),
    .wr_rst_busy                        (wr_rst_busy),
    .rd_rst_busy                        (),
    .m_aclk                             (1'b0),
    .s_aclk                             (1'b0),
    .s_aresetn                          (1'b1),
    .m_aclk_en                          (1'b0),
    .s_aclk_en                          (1'b0),
    .s_axi_awid                         (4'b0),
    .s_axi_awaddr                       (0),
    .s_axi_awlen                        (8'b0),
    .s_axi_awsize                       (3'b0),
    .s_axi_awburst                      (2'b0),
    .s_axi_awlock                       (1'b0),
    .s_axi_awcache                      (4'b0),
    .s_axi_awprot                       (3'b0),
    .s_axi_awqos                        (4'b0),
    .s_axi_awregion                     (4'b0),
    .s_axi_awuser                       (1'b0),
    .s_axi_awvalid                      (1'b0),
    .s_axi_awready                      (),
    .s_axi_wid                          (4'b0),
    .s_axi_wdata                        (64'b0),
    .s_axi_wstrb                        (8'b0),
    .s_axi_wlast                        (1'b0),
    .s_axi_wuser                        (1'b0),
    .s_axi_wvalid                       (1'b0),
    .s_axi_wready                       (),
    .s_axi_bid                          (),
    .s_axi_bresp                        (),
    .s_axi_buser                        (),
    .s_axi_bvalid                       (),
    .s_axi_bready                       (1'b0),
    .m_axi_awid                         (),
    .m_axi_awaddr                       (),
    .m_axi_awlen                        (),
    .m_axi_awsize                       (),
    .m_axi_awburst                      (),
    .m_axi_awlock                       (),
    .m_axi_awcache                      (),
    .m_axi_awprot                       (),
    .m_axi_awqos                        (),
    .m_axi_awregion                     (),
    .m_axi_awuser                       (),
    .m_axi_awvalid                      (),
    .m_axi_awready                      (1'b0),
    .m_axi_wid                          (),
    .m_axi_wdata                        (),
    .m_axi_wstrb                        (),
    .m_axi_wlast                        (),
    .m_axi_wuser                        (),
    .m_axi_wvalid                       (),
    .m_axi_wready                       (1'b0),
    .m_axi_bid                          (4'b0),
    .m_axi_bresp                        (2'b0),
    .m_axi_buser                        (1'b0),
    .m_axi_bvalid                       (1'b0),
    .m_axi_bready                       (),
    .s_axi_arid                         (4'b0),
    .s_axi_araddr                       (0),
    .s_axi_arlen                        (8'b0),
    .s_axi_arsize                       (3'b0),
    .s_axi_arburst                      (2'b0),
    .s_axi_arlock                       (1'b0),
    .s_axi_arcache                      (4'b0),
    .s_axi_arprot                       (3'b0),
    .s_axi_arqos                        (4'b0),
    .s_axi_arregion                     (4'b0),
    .s_axi_aruser                       (1'b0),
    .s_axi_arvalid                      (1'b0),
    .s_axi_arready                      (),
    .s_axi_rid                          (),
    .s_axi_rdata                        (),
    .s_axi_rresp                        (),
    .s_axi_rlast                        (),
    .s_axi_ruser                        (),
    .s_axi_rvalid                       (),
    .s_axi_rready                       (1'b0),
    .m_axi_arid                         (),
    .m_axi_araddr                       (),
    .m_axi_arlen                        (),
    .m_axi_arsize                       (),
    .m_axi_arburst                      (),
    .m_axi_arlock                       (),
    .m_axi_arcache                      (),
    .m_axi_arprot                       (),
    .m_axi_arqos                        (),
    .m_axi_arregion                     (),
    .m_axi_aruser                       (),
    .m_axi_arvalid                      (),
    .m_axi_arready                      (1'b0),
    .m_axi_rid                          (4'b0),
    .m_axi_rdata                        (64'b0),
    .m_axi_rresp                        (2'b0),
    .m_axi_rlast                        (1'b0),
    .m_axi_ruser                        (1'b0),
    .m_axi_rvalid                       (1'b0),
    .m_axi_rready                       (),
    .s_axis_tvalid                      (1'b0),
    .s_axis_tready                      (),
    .s_axis_tdata                       (64'b0),
    .s_axis_tstrb                       (4'b0),
    .s_axis_tkeep                       (4'b0),
    .s_axis_tlast                       (1'b0),
    .s_axis_tid                         (8'b0),
    .s_axis_tdest                       (4'b0),
    .s_axis_tuser                       (4'b0),
    .m_axis_tvalid                      (),
    .m_axis_tready                      (1'b0),
    .m_axis_tdata                       (),
    .m_axis_tstrb                       (),
    .m_axis_tkeep                       (),
    .m_axis_tlast                       (),
    .m_axis_tid                         (),
    .m_axis_tdest                       (),
    .m_axis_tuser                       (),
    .axi_aw_injectsbiterr               (1'b0),
    .axi_aw_injectdbiterr               (1'b0),
    .axi_aw_prog_full_thresh            (4'b0),
    .axi_aw_prog_empty_thresh           (4'b0),
    .axi_aw_data_count                  (),
    .axi_aw_wr_data_count               (),
    .axi_aw_rd_data_count               (),
    .axi_aw_sbiterr                     (),
    .axi_aw_dbiterr                     (),
    .axi_aw_overflow                    (),
    .axi_aw_underflow                   (),
    .axi_aw_prog_full                   (),
    .axi_aw_prog_empty                  (),
    .axi_w_injectsbiterr                (1'b0),
    .axi_w_injectdbiterr                (1'b0),
    .axi_w_prog_full_thresh             (10'b0),
    .axi_w_prog_empty_thresh            (10'b0),
    .axi_w_data_count                   (),
    .axi_w_wr_data_count                (),
    .axi_w_rd_data_count                (),
    .axi_w_sbiterr                      (),
    .axi_w_dbiterr                      (),
    .axi_w_overflow                     (),
    .axi_w_underflow                    (),
    .axi_b_injectsbiterr                (1'b0),
    .axi_w_prog_full                    (),
    .axi_w_prog_empty                   (),
    .axi_b_injectdbiterr                (1'b0),
    .axi_b_prog_full_thresh             (4'b0),
    .axi_b_prog_empty_thresh            (4'b0),
    .axi_b_data_count                   (),
    .axi_b_wr_data_count                (),
    .axi_b_rd_data_count                (),
    .axi_b_sbiterr                      (),
    .axi_b_dbiterr                      (),
    .axi_b_overflow                     (),
    .axi_b_underflow                    (),
    .axi_ar_injectsbiterr               (1'b0),
    .axi_b_prog_full                    (),
    .axi_b_prog_empty                   (),
    .axi_ar_injectdbiterr               (1'b0),
    .axi_ar_prog_full_thresh            (4'b0),
    .axi_ar_prog_empty_thresh           (4'b0),
    .axi_ar_data_count                  (),
    .axi_ar_wr_data_count               (),
    .axi_ar_rd_data_count               (),
    .axi_ar_sbiterr                     (),
    .axi_ar_dbiterr                     (),
    .axi_ar_overflow                    (),
    .axi_ar_underflow                   (),
    .axi_ar_prog_full                   (),
    .axi_ar_prog_empty                  (),
    .axi_r_injectsbiterr                (1'b0),
    .axi_r_injectdbiterr                (1'b0),
    .axi_r_prog_full_thresh             (10'b0),
    .axi_r_prog_empty_thresh            (10'b0),
    .axi_r_data_count                   (),
    .axi_r_wr_data_count                (),
    .axi_r_rd_data_count                (),
    .axi_r_sbiterr                      (),
    .axi_r_dbiterr                      (),
    .axi_r_overflow                     (),
    .axi_r_underflow                    (),
    .axis_injectsbiterr                 (1'b0),
    .axi_r_prog_full                    (),
    .axi_r_prog_empty                   (),
    .axis_injectdbiterr                 (1'b0),
    .axis_prog_full_thresh              (10'b0),
    .axis_prog_empty_thresh             (10'b0),
    .axis_data_count                    (),
    .axis_wr_data_count                 (),
    .axis_rd_data_count                 (),
    .axis_sbiterr                       (),
    .axis_dbiterr                       (),
    .axis_overflow                      (),
    .axis_underflow                     (),
    .axis_prog_full                     (),
    .axis_prog_empty                    ()
  );
 
endmodule



//-------------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename     : axi_perf_mon_v5_0_12_sync_fifo.v
// Version      : v5.0
// Description  : This is the verilog file for the synchronous fifo 
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
// --  axi_perf_mon.v
//      \-- axi_perf_mon_v5_0_12_metric_calc.v
//          \-- axi_perf_mon_v5_0_12_sync_fifo.v
//-----------------------------------------------------------------------------
// Author:   NLR 
// History:    
// NLR       06/19/2013      First Version
// ^^^^^^
//-----------------------------------------------------------------------------
`timescale 1ns/1ps
(* DowngradeIPIdentifiedWarnings="yes" *)

module axi_perf_mon_v5_0_12_sync_fifo 
  #(
  parameter WIDTH      = 8, // The width of the FIFO data
  parameter DEPTH_LOG2 = 3  // Specify power-of-2 FIFO depth
)

(
  input                  rst_n,
  input                  clk,
  input                  wren,
  input                  rden,
  input      [WIDTH-1:0]  din,
  output reg [WIDTH-1:0]  dout,
  output reg             full,
  output reg             empty
);

  localparam DEPTH = 1 << DEPTH_LOG2;

/* ========================================================================== */
//  Register and Wire Declarations
/* ========================================================================== */
(* ram_style = "distributed" *) reg [WIDTH-1:0]      mem [0:DEPTH-1];// memory for storing FIFO data
reg [DEPTH_LOG2:0]  wptr; // wr ptr, with extra wrap bit
reg [DEPTH_LOG2:0]  rptr; // rd ptr, with extra wrap bit
//reg rd_en_del; //Delayed read enable
wire [DEPTH_LOG2:0]  wptr_inc;// wr ptr incremented by 1
wire [DEPTH_LOG2:0]  rptr_inc;// rd ptr incremented by 1
wire [DEPTH_LOG2:0]  wptr_nxt;// next wr ptr, with extra wrap bit
wire [DEPTH_LOG2:0]  rptr_nxt;// next rd ptr, with extra wrap bit
wire [DEPTH_LOG2-1:0] mem_wptr;// mem wrptr, extra bit removed
wire [DEPTH_LOG2-1:0] mem_rptr;// mem rdptr, extra bit removed
wire almost_full;              // only 1 entry available in FIFO
wire almost_empty;             // only 1 space used in FIFO

//================================================================================
// Code the FIFO
//================================================================================
assign wptr_inc = wptr + 1'b1; // automatically wraps
assign rptr_inc = rptr + 1'b1; // automatically wraps

assign wptr_nxt = wren ? wptr_inc : wptr;
assign rptr_nxt = rden ? rptr_inc : rptr;

assign mem_wptr = wptr[DEPTH_LOG2-1:0]; // get rid of extra bit
assign mem_rptr = rptr[DEPTH_LOG2-1:0]; // get rid of extra bit

// Assign dout
always @(posedge clk) begin
   //if (~rst_n)
   //    dout <= 0;
   //else if(rden == 1'b1) begin
    dout <= mem[mem_rptr];              //read data output
   //end
end

// Almost_full if one more write will make the FIFO full
assign almost_full = (wptr_inc[DEPTH_LOG2] != rptr[DEPTH_LOG2]) &&
              (wptr_inc[DEPTH_LOG2-1:0] == rptr[DEPTH_LOG2-1:0]);

// Almost_empty if one more read will make the FIFO empty
assign almost_empty = (wptr[DEPTH_LOG2:0] == rptr_inc[DEPTH_LOG2:0]);

// Flags
always @(posedge clk) begin
  if (~rst_n)
    begin
      full <= 1'b0;
      empty <= 1'b1;
      rptr <= {(DEPTH_LOG2+1){1'b0}};
      wptr <= {(DEPTH_LOG2+1){1'b0}};
    end
  else
    begin
      full <= (almost_full & wren & ~rden) | (full & ~rden);
      empty <= (almost_empty & rden & ~wren) | (empty & ~wren);
      rptr <= rptr_nxt;
      wptr <= wptr_nxt;
     // rd_en_del <= rden;
    end
end

// Assign memory
always @(posedge clk) begin
  if (wren)
    mem[mem_wptr] <= din;
end

endmodule


//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename:       axi_perf_mon_v5_0_12_acc_n_incr.v
// Version :       v5.0
// Description:    Accumulator and incrementor module accumulates and increments
//                 the metric counts based on low and high range values from 
//                 register module.
// Verilog-Standard:verilog-2001
//---------------------------------------------------------------------------
// Structure:   
// --  axi_perf_mon.v
//        \-- axi_perf_mon_v5_0_12_metric_counters.v
//         \-- axi_perf_mon_v5_0_12_metric_sel_n_cnt.v 
//          \--axi_perf_mon_v5_0_12_acc_n_incr.v
//-----------------------------------------------------------------------------
// Author:      Kalpanath
// History:
// Kalpanath 07/25/2012      First Version
// ^^^^^^
// NLR       10/02/2013      Added scaling factor support  
//-----------------------------------------------------------------------------
`timescale 1ns/1ps
(* DowngradeIPIdentifiedWarnings="yes" *)

module axi_perf_mon_v5_0_12_acc_n_incr 
#(
   parameter                  C_FAMILY = "nofamily",
   parameter                  DWIDTH   = 32,
   parameter                  C_SCALE  = 1,
   parameter                  COUNTER_LOAD_VALUE  = 32'h00000000  

)
(
   input                      clk,
   input                      rst_n,

   input                      Enable,   
   input                      Reset,   

   input  [31:0]              Range_Reg,  

   input  [(DWIDTH - 1):0]    Add_in,  
   input                      Add_in_Valid,  
   input                      Accumulate, 
   input  [(DWIDTH - 1):0]    incrementer_input_reg_val,
   output [(DWIDTH - 1):0]    Accumulator,  
   output reg [(DWIDTH - 1):0] Incrementer,  

   output reg                 Acc_OF,   
   output reg                 Incr_OF   

);



//-------------------------------------------------------------------
// Parameter Declaration
//-------------------------------------------------------------------
localparam RST_ACTIVE = 1'b0;
localparam C_DWIDTH = DWIDTH+3;
localparam ALL_ZEROES = {DWIDTH{1'b0}};
localparam ZEROES = {4{1'b0}};

//-------------------------------------------------------------------
// Signal Declaration
//-------------------------------------------------------------------
reg                      Incr_by_1;
reg [C_DWIDTH:0]         Accum_i;  

wire                     Overflow;
reg                      Overflow_D1;
wire [(DWIDTH - 1):0]    Incrementer_i1;  
reg [DWIDTH:0]    Incrementer_i;  
reg  [(DWIDTH - 1):0]    incrementer_input_reg_val_i;
reg                      Incr_OF_i;
reg                      Incr_OF_i1;
wire                     Incr_OF_i2;
reg                      Add_in_Valid_i;
//-------------------------------------------------------------------
// Begin architecture
//-------------------------------------------------------------------

wire [15:0] Range_LOW  = Range_Reg[15:0];
wire [15:0] Range_HIGH = Range_Reg[31:16];

wire [15:0] Comp_Val   = Add_in[15:0];

//-- Comparator
always @(posedge clk) begin 
   if (rst_n == RST_ACTIVE) begin
       Incr_by_1 <= 1'b0;
   end
   else begin
       if ((Comp_Val >= Range_LOW) && (Comp_Val <= Range_HIGH)) begin
           Incr_by_1 <= Enable && Add_in_Valid;
       end
       else begin
           Incr_by_1 <= 1'b0;
       end
   end
end 

//-- Incrementer
axi_perf_mon_v5_0_12_counter 
  #(
       .C_FAMILY             (C_FAMILY),
       .C_NUM_BITS           (DWIDTH)
   ) counter_inst 
   (
       .clk                  (clk),
       .rst_n                (rst_n),
       .Load_In              (ALL_ZEROES),
       .Count_Enable         (Incr_by_1),
       .Count_Load           (Reset),
       .Count_Down           (1'b0),
       .Count_Out            (Incrementer_i1),
       .Carry_Out            (Incr_OF_i2)
   );

//Incrementer logic
always @(posedge clk) begin 
   if (rst_n == RST_ACTIVE) begin
       Incrementer_i <= 33'b0;
       //Incr_OF_i   <= 1'b0;
   end
   else begin
       //Add_in_Valid_i <= Add_in_Valid;
        incrementer_input_reg_val_i <= incrementer_input_reg_val;
       if(Reset == 1'b1)
        Incrementer_i <= {1'b0,ALL_ZEROES};
       else if(Incr_by_1 == 1'b1)
       Incrementer_i <= Incrementer_i+{1'b0,incrementer_input_reg_val_i};//-1'b1;
      // else
     //  Incrementer <= Incrementer_i;
   end
end

 
//-- Delaying Overflow
always @(posedge clk) begin 
   if (rst_n == RST_ACTIVE) begin
       Incr_OF_i1 <= 1'b0;
   end
   else begin
       Incr_OF_i1 <= Incrementer_i[DWIDTH];
   end
end 

//-- Overflow Pulse
always @(posedge clk) begin 
   if (rst_n == RST_ACTIVE) begin
       Incr_OF <= 1'b0;
       Incrementer <= ALL_ZEROES;
   end
   else begin
       Incr_OF <= Incrementer_i[DWIDTH] & (~Incr_OF_i1);
       Incrementer <= Incrementer_i[(DWIDTH-1):0];
   end
end 
 
//-- Accumulator
always @(posedge clk) begin 
   if (rst_n == RST_ACTIVE) begin
       Accum_i <= 0;
   end
   else begin
       if (Reset == 1'b1) begin
           Accum_i <= COUNTER_LOAD_VALUE;
       end
       else if ((Enable == 1'b1) && (Add_in_Valid == 1'b1) && (Accumulate == 1'b1)) begin
           Accum_i <= Accum_i + {ZEROES, Add_in};
       end
       else if ((Enable == 1'b1) && (Add_in_Valid == 1'b1)) begin
           Accum_i <= {ZEROES, Add_in};
       end
       else begin
           Accum_i <= Accum_i;
       end
   end
end 

//------------------------------------------------------------------
// Accumulator width based on the incoming scaling factor
// Metric accumulated value will be scaled down based on scaling factor
// This logic is to accommodate higher counts which are not fitting into
// 32 bit counter
//------------------------------------------------------------------

  generate if (C_SCALE == 1) begin
    assign Accumulator = Accum_i[C_DWIDTH -4:0];
    assign Overflow    = Accum_i[C_DWIDTH-3] ;
  end
  else if(C_SCALE == 2) begin
    assign Accumulator = Accum_i[C_DWIDTH -3:1];
    assign Overflow    = Accum_i[C_DWIDTH-2] ;
  end
  else if(C_SCALE == 4) begin
    assign Accumulator = Accum_i[C_DWIDTH -2:2];
    assign Overflow    = Accum_i[C_DWIDTH-1] ;
  end
  else if(C_SCALE == 8) begin
    assign Accumulator = Accum_i[C_DWIDTH -1:3];
    assign Overflow    = Accum_i[C_DWIDTH] ;
  end  
  endgenerate

//-- Delaying Overflow
always @(posedge clk) begin 
   if (rst_n == RST_ACTIVE) begin
       Overflow_D1 <= 1'b0;
   end
   else begin
       Overflow_D1 <= Overflow;
   end
end 

//-- Overflow Pulse
always @(posedge clk) begin 
   if (rst_n == RST_ACTIVE) begin
       Acc_OF <= 1'b0;
   end
   else begin
       Acc_OF <= Overflow & (~Overflow_D1);
   end
end 

endmodule








//-------------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename     : axi_perf_mon_v5_0_12_async_stream_fifo.v
// Version      : v5.0
// Description  : This is the top level wrapper file for the asynchronous 
//                streaming fifo 
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
// --  axi_perf_mon.v
//      \-- axi_perf_mon_v5_0_12_async_stream_fifo.v
//-----------------------------------------------------------------------------
// Author:   NLR 
// History:    
// NLR       07/25/2012      First Version
// ^^^^^^
//-----------------------------------------------------------------------------
`timescale 1ns/1ps
module axi_perf_mon_v5_0_12_async_stream_fifo
  # (
    parameter C_FAMILY         = "nofamily",
    parameter C_FIFO_DEPTH     = 512, 
    parameter C_DATA_WIDTH     = 1024,
    parameter C_AXIS_DWIDTH_ROUND_TO_32     = 64,
    parameter C_USE_BLOCKMEM   = 1,   // 2 = Distributed RAM 1= Block RAM
    parameter C_COMMON_CLOCK   = 0,
    parameter C_LOG_DATA_OFFLD     = 0,//0- stream offload,1-Memorymap offload 
    parameter S_AXI_OFFLD_ID_WIDTH = 1, //offload interface ID width.
    parameter C_EN_TRIGGER         = 0 
    )
    (
    input                          Wr_clk,
    input                          Wr_rst_n,
    input                          fifo_wr_en,
    output                         fifo_rd_en,
    output reg [31:0]              eventlog_cur_cnt,
    output                         fifo_full_out,
    output                         fifo_empty_out,
    input [C_DATA_WIDTH-1:0]       Fifo_Data_In,
    input                          m_axis_aclk,
    input                          m_axis_aresetn,
    output                         m_axis_tvalid,
    input                          m_axis_tready,
    output[C_DATA_WIDTH-1:0]       m_axis_tdata,
    input                             s_axi_offld_aclk,
    input                             s_axi_offld_aresetn,
    input [31:0]                      s_axi_offld_araddr ,
    input                             s_axi_offld_arvalid,
    input [7:0]                       s_axi_offld_arlen  ,
    input [S_AXI_OFFLD_ID_WIDTH-1:0]  s_axi_offld_arid   ,    
    output                            s_axi_offld_arready,
    input                             s_axi_offld_rready ,
    output [31:0]                     s_axi_offld_rdata  ,
    output reg [1:0]                  s_axi_offld_rresp  ,
    output                            s_axi_offld_rvalid ,
    output [S_AXI_OFFLD_ID_WIDTH-1:0] s_axi_offld_rid    ,      
    output reg                        s_axi_offld_rlast  ,       
    input                       		  trigger
    );


   wire [31:0]              eventlog_cur_cnt_wire;
   wire m_axis_tready_int;
   wire rd_clk;
   wire rd_rstn;
   assign rd_clk  = (C_LOG_DATA_OFFLD == 0) ? m_axis_aclk : s_axi_offld_aclk;
   assign rd_rstn = (C_LOG_DATA_OFFLD == 0) ? m_axis_aresetn : s_axi_offld_aresetn;
   //-------------------- Parameter declarations-------------------------
     
    localparam RST_ACTIVE = 1'b0; 
    localparam [1:0] IDLE = 2'b00, WRITE_WAIT1 = 2'b01, WRITE = 2'b10;
    //---------------------------------------------------
    // for common clock dist FIFO:
    // C_COMMON_CLOCK = 1
    // C_IMPLEMENTATION_TYPE = 0
    // C_USE_BLOCKMEM = 2
    //---------------------------------------------------
    // for independent clock dist FIFO:
    // C_COMMON_CLOCK = 0
    // C_IMPLEMENTATION_TYPE = 2
    // C_USE_BLOCKMEM = 2
    //---------------------------------------------------
     // for common clock BRAM FIFO:
    // C_COMMON_CLOCK = 1
    // C_IMPLEMENTATION_TYPE = 0
    // C_USE_BLOCKMEM = 1
    //---------------------------------------------------
    // for independent clock BRAM FIFO:
    // C_COMMON_CLOCK = 0
    // C_IMPLEMENTATION_TYPE = 2
    // C_USE_BLOCKMEM = 1
    //---------------------------------------------------
 
    localparam IMP_TYPE = C_COMMON_CLOCK==1?0:2;
   //-------------------- Function to find log base 2 of FIFO_DEPTH
    function integer clogb2;
    input integer depth;   // Depth of fifo
    integer j;
      begin
        j = depth;
        for(clogb2=0; j>0; clogb2=clogb2+1)
           j = j >> 1;
      end
    endfunction
    localparam DATA_CNT_WIDTH = clogb2(C_FIFO_DEPTH)-1;
 
   //--------------------Register declarations---------------------------
    reg m_axis_tvalid_int;   
    reg fifo_empty_reg;
    wire [DATA_CNT_WIDTH-1:0] rd_data_count ;
  //-------------------- Wire declarations------------------------------
    //wire fifo_rd_en;
    wire fifo_empty;
    wire almost_empty;
    wire fifo_empty_fall;
    wire [C_DATA_WIDTH-1:0]  Sync_Data_Out;
    wire fifo_rst = ~Wr_rst_n | ~rd_rstn;
   wire  fifo_rd_en_with_trig;
   wire  drain_fifo_now;
   wire almost_full;

   // Event log fifo based on common clocks parameter either Sync/Async
   // Fifo is generated
   
    axi_perf_mon_v5_0_12_async_fifo
    #(
        .C_FAMILY             (C_FAMILY       ), 
        .C_FIFO_DEPTH         (C_FIFO_DEPTH   ), 
        .C_DATA_WIDTH         (C_DATA_WIDTH   ),
        .C_DATA_CNT_WIDTH     (DATA_CNT_WIDTH ),
        .C_FULL_FLAGS_RST     (0              ),//On reset fifo full value
        .C_USE_BLOCKMEM       (C_USE_BLOCKMEM ),
        .C_COMMON_CLOCK       (C_COMMON_CLOCK ),//Different clocks then this fifo is required  
        .C_IMPLEMENTATION_TYPE(IMP_TYPE       ),//Different clock BRAM/Distributed 
        .C_USE_FWFT           (1              ) //FWFT 
 
     )async_fifo_inst
     (
        .Din               (Fifo_Data_In            ),
        .Wr_en             (fifo_wr_en              ),
        .Wr_clk            (Wr_clk                  ),
        .Rd_en             (fifo_rd_en_with_trig    ),
        .Rd_clk            (rd_clk                  ),
        .fifo_rst          (fifo_rst                ), //active high
        .Dout              (Sync_Data_Out           ),
        .Full              (fifo_full               ),
        .wr_rst_busy       (wr_rst_busy             ),
        .Empty             (fifo_empty              ),
        .rd_data_count     (rd_data_count           ),
        .almost_full       (almost_full             ),
        .almost_empty      (almost_empty            )
     );

    assign fifo_full_out  = fifo_full & ~wr_rst_busy;
    assign fifo_empty_out = fifo_empty;


   // Fifo read enable generation
 //  assign fifo_rd_en = ~(fifo_empty) && m_axis_tready_int && m_axis_tvalid_int;

 //1. before trigger is asserted, drain fifo only when fifo is near full.
 //2. after trigger is asserted, drain fifo when axi is ready.    
   assign fifo_rd_en_with_trig = (C_EN_TRIGGER) ? ((trigger==1'b1) ? fifo_rd_en: drain_fifo_now) : fifo_rd_en;
   assign fifo_rd_en = ~(fifo_empty) && m_axis_tready_int && m_axis_tvalid_int;
   assign drain_fifo_now = almost_full;
   assign fifo_empty_fall = ~ fifo_empty && fifo_empty_reg;
   


  //-----------------AXI Streaming Master Interface logic--------------
   // M_AXIS_TVALID generation Logic 
   always @(posedge rd_clk     ) begin
      if(rd_rstn == RST_ACTIVE) begin
        m_axis_tvalid_int     <= 0;
        fifo_empty_reg        <= 0;
      end
      else begin
        fifo_empty_reg        <= fifo_empty;
        if(fifo_empty_fall || (almost_empty == 1'b0 && C_EN_TRIGGER)) begin 
          m_axis_tvalid_int   <=  1'b1;
        end
        else if(almost_empty == 1'b1 && m_axis_tready_int == 1'b1) begin 
          m_axis_tvalid_int    <=  1'b0;
        end
     end
   end

    wire [C_DATA_WIDTH-1:0]  m_axis_tdata_int;
  // m_axis_tvalid and m_axis_tdata output signal connections
generate if(C_LOG_DATA_OFFLD == 0 && C_EN_TRIGGER == 1) begin : TVALID_ON1 
   assign m_axis_tvalid     = m_axis_tvalid_int & trigger;
   assign m_axis_tdata      = Sync_Data_Out;
   assign m_axis_tdata_int  = {C_DATA_WIDTH{1'b0}};
end
endgenerate
//generate if(C_LOG_DATA_OFFLD == 1 && C_EN_TRIGGER == 1) begin : TVALID_OFF 
//   assign m_axis_tvalid     = 1'b0;
//   assign m_axis_tdata      = {C_DATA_WIDTH{1'b0}};
//   assign m_axis_tdata_int  = Sync_Data_Out;
//end
//endgenerate



   // m_axis_tvalid and m_axis_tdata output signal connections
generate if(C_LOG_DATA_OFFLD == 0 && C_EN_TRIGGER == 0) begin : TVALID_ON 
   assign m_axis_tvalid     = m_axis_tvalid_int;
   assign m_axis_tdata      = Sync_Data_Out;
   assign m_axis_tdata_int  = {C_DATA_WIDTH{1'b0}};
end
endgenerate
generate if(C_LOG_DATA_OFFLD == 1) begin : TVALID_OFF 
   assign m_axis_tvalid     = 1'b0;
   assign m_axis_tdata      = {C_DATA_WIDTH{1'b0}};
   assign m_axis_tdata_int  = Sync_Data_Out;
end
endgenerate

   //localparam C_AXIS_DWIDTH_ROUND_TO_32    = 64 ; //rounded to next 32-bit boundary
   localparam WORDS_IN_ENTRY = C_AXIS_DWIDTH_ROUND_TO_32/32  ; //number of 32-bit words in each FIFO entry
   localparam S_AXI_ADDRCODE = 32'h00000000  ; //read address to FIFO
  //-----------------AXI MM Slave Interface logic--------------
    //wire                                    s_axi_offld_aclk;
    //wire                                    s_axi_offld_aresetn;
    //reg   [15:0]                            s_axi_offld_araddr ;
    //reg                                     s_axi_offld_arvalid;
    //reg   [7:0]                             s_axi_offld_arlen  ;
    //reg  [S_AXI_OFFLD_ID_WIDTH-1:0]               s_axi_offld_arid   ;    
    //reg                                     s_axi_offld_rready ;
    //reg                                     s_axi_offld_arready;
    //wire   [31:0]                           s_axi_offld_rdata  ;
    //reg   [1:0]                             s_axi_offld_rresp  ;
    //wire                                    s_axi_offld_rvalid ;
    //wire   [S_AXI_OFFLD_ID_WIDTH-1:0]             s_axi_offld_rid    ;      
    //reg                                     s_axi_offld_rlast  ;      
   //TODO: remove 
   //assign s_axi_offld_aclk = m_axis_aclk;
   //assign s_axi_offld_aresetn = m_axis_aresetn;


  //common: WORDS_IN_ENTRY ==1 and WORDS_IN_ENTRY >1
   //fifo-status-qualifiers
   wire curr_fifo_oc_gt0 ;
   //reg [DATA_CNT_WIDTH+2-1:0] curr_fifo_oc ; //TODO: re-calculate Width of this signal 
   //intermediate qualifiers
   reg [1:0] buf_valid;
   //axi-mm qualifiers
   reg valid_rd_req;
   reg [8:0] rd_cnt; 
   wire rd_cnt_not0;
   reg  rd_dphase ; 
   wire rd_aphase ;
   wire rd_chidle ;

   //rd.data.cnt calculation
   wire [1:0] rd_cnt_offset;
   assign rd_cnt_offset  = (fifo_empty)?(2'b00) :
                           (almost_empty ? 2'b01: 2'b10);
   assign eventlog_cur_cnt_wire = rd_data_count + buf_valid[0] + buf_valid[1]+ rd_cnt_offset;

   always @(posedge rd_clk     ) begin
     if(rd_rstn == RST_ACTIVE) begin
      eventlog_cur_cnt <= 32'b0;
     end
     else begin
      eventlog_cur_cnt <= eventlog_cur_cnt_wire;
     end
 end

   //reg [31:0] eventlog_cnt_i;
   //reg [31:0] eventlog_cnt_i_d1;
   //reg [31:0] eventlog_cur_cnt_d1;
   //always @(posedge rd_clk     ) begin
   //  if(rd_rstn == RST_ACTIVE) begin
   //    eventlog_cnt_i    <= 32'h0;
   //    eventlog_cnt_i_d1 <= 32'h0;
   //    eventlog_cur_cnt_d1 <= 32'h0;
   //  end else begin
   //    eventlog_cnt_i <= rd_data_count + buf_valid[0] + buf_valid[1]+ rd_cnt_offset;
   //    eventlog_cnt_i_d1 <= eventlog_cnt_i;
   //    eventlog_cur_cnt_d1 <= eventlog_cur_cnt;
   //  end
   //end
   //assign eventlog_cur_cnt = (eventlog_cnt_i == eventlog_cnt_i_d1)?
   //                           eventlog_cnt_i: eventlog_cur_cnt_d1;
  //
  //arready generation
  //
   assign rd_chidle = ~rd_aphase &  ~rd_dphase;
   assign curr_fifo_oc_gt0 = ~fifo_empty | buf_valid[0];
   reg s_axi_offld_arready_i;
   always @(posedge rd_clk     ) begin
     if(rd_rstn == RST_ACTIVE) begin
       s_axi_offld_arready_i <= 1'b0;
     end else if(~s_axi_offld_arvalid & s_axi_offld_arready_i) begin
       s_axi_offld_arready_i <= s_axi_offld_arready_i;
     end else if(s_axi_offld_arvalid & s_axi_offld_arready_i) begin
       s_axi_offld_arready_i <= 1'b0;
     end else if(rd_chidle & curr_fifo_oc_gt0)begin
       s_axi_offld_arready_i <= 1'b1;
     end
   end
   //ID reflection.
   reg [S_AXI_OFFLD_ID_WIDTH-1:0] aid;
   always @(posedge rd_clk     ) begin
     if(rd_rstn == RST_ACTIVE) begin
       aid <= {S_AXI_OFFLD_ID_WIDTH{1'b0}};
     end else if(s_axi_offld_arvalid & s_axi_offld_arready ) begin 
       aid <= s_axi_offld_arid;
     end
   end
   assign s_axi_offld_rid = aid;
  //
  //channel status: address phase- rd_aphase, data phase- rd_dphase
  //
   assign rd_aphase = s_axi_offld_arready;
   always @(posedge rd_clk     ) begin
     if(rd_rstn == RST_ACTIVE) begin
       rd_dphase <= 1'b0;
     end else if (s_axi_offld_arvalid & s_axi_offld_arready) begin
       rd_dphase <= 1'b1;
     end else if(s_axi_offld_rvalid & s_axi_offld_rready & s_axi_offld_rlast) begin
       rd_dphase <= 1'b0;
     end
   end
   //
   //cnt no.of beats trnasferred
   //
   assign rd_cnt_not0 = ( rd_cnt != 9'h0);
   always @(posedge rd_clk     ) begin
     if(rd_rstn == RST_ACTIVE) begin
       rd_cnt <= 9'h0;
     end else if(s_axi_offld_arvalid & s_axi_offld_arready) begin
       rd_cnt <= s_axi_offld_arlen;
     end else if(s_axi_offld_rvalid & s_axi_offld_rready) begin
       rd_cnt <= rd_cnt - rd_cnt_not0;
     end
   end
   //
   //rlast generation:
   //
   always @(posedge rd_clk     ) begin
      if(rd_rstn == RST_ACTIVE) begin
        s_axi_offld_rlast <= 1'b0;
      end else if(s_axi_offld_rvalid & ~s_axi_offld_rready) begin
        s_axi_offld_rlast <= s_axi_offld_rlast;
      end else if(s_axi_offld_rvalid & s_axi_offld_rready & s_axi_offld_rlast) begin
        s_axi_offld_rlast <= 1'b0;
      end else if(s_axi_offld_arvalid & s_axi_offld_arready & (s_axi_offld_arlen == 8'h0)) begin
        s_axi_offld_rlast <= 1'b1;
      end else if(s_axi_offld_rvalid & s_axi_offld_rready & (rd_cnt == 9'h1)) begin
        s_axi_offld_rlast <= 1'b1;
      end
   end

   //qualify read request: error_condition
   //error conditions
   //current fifo occupancy < Length
   //ARADDR not valid
   //ARLEN not aligned
   wire invalid_occupancy;
   wire invalid_addr;
   wire invalid_arlen;
   wire error_condition ;

   //assign invalid_occupancy = (curr_fifo_oc < (s_axi_offld_arlen + 8'h1)) | ((fifo_empty & buf_valid == 2'b00));
   assign invalid_occupancy = ((fifo_empty & buf_valid == 2'b00));
   assign invalid_addr      = 1'b0;//s_axi_offld_araddr != S_AXI_ADDRCODE;
   assign invalid_arlen     = 1'b0;//s_axi_offld_arlen[0] == 1'b0; //TODO:ARLEN should be multiple of WORDS_IN_ENTRY
   wire launch_erresp_data =  invalid_occupancy & rd_dphase; //add time-out condiftion if necessary

   assign error_condition = invalid_occupancy | invalid_addr | invalid_arlen;
   always @(posedge rd_clk     ) begin
      if(rd_rstn == RST_ACTIVE) begin
        s_axi_offld_rresp <= 2'b00;
      end else if(s_axi_offld_rvalid & s_axi_offld_rready & s_axi_offld_rlast) begin
        s_axi_offld_rresp <= 2'b00;
      end else if(s_axi_offld_rvalid & s_axi_offld_rready ) begin
        if(launch_erresp_data) begin  //ie,launch_erresp_data as rvld & rrdy confirms dphase
          s_axi_offld_rresp <= 2'b10;
        end else begin
          s_axi_offld_rresp <= 2'b00;
        end
      end else if(s_axi_offld_rvalid & ~s_axi_offld_rready) begin
        s_axi_offld_rresp <= s_axi_offld_rresp;
      end else if(s_axi_offld_arvalid & s_axi_offld_arready) begin
        if(error_condition) begin
          s_axi_offld_rresp <= 2'b10;
        end else begin
          s_axi_offld_rresp <= 2'b00;
        end 
      end
   end
  
   //chk that the req is valid(like arlen > fifo occupency
   // arlen in multimples of FIFO DWIDTH etc.,
   always @(posedge rd_clk     ) begin
     if(rd_rstn == RST_ACTIVE) begin
       valid_rd_req <= 1'b0;
     end else if(s_axi_offld_rvalid & s_axi_offld_rready & s_axi_offld_rlast) begin
       valid_rd_req <= 1'b0;
     end else if(s_axi_offld_arvalid & s_axi_offld_arready ) begin
       if(error_condition) begin
         valid_rd_req <= 1'b0;
       end else begin
         valid_rd_req <= 1'b1;
       end
     end
   end

   //1-deep buffer
   //always @(posedge s_axi_offld_aclk) begin
   //  if(s_axi_offld_aresetn == RST_ACTIVE) begin
   //    buf_valid[1:0] <= 2'b00;   
   //    buf_data[0] <= {C_AXIS_DWIDTH_ROUND_TO_32{1'b0}};
   //    buf_data[1] <= {C_AXIS_DWIDTH_ROUND_TO_32{1'b0}};
   //  end else if(buf_valid[0] & addr_train[WORDS_IN_ENTRY-1]& valid_rd_req & data_sampled & (WORDS_IN_ENTRY >1)) begin
   //      buf_valid[0] <= 1'b0;
   //  end else if(buf_valid[0] & addr_train[WORDS_IN_ENTRY-1]& valid_rd_req & buffer_valid & ~buffer_valid_d1 & (WORDS_IN_ENTRY ==1)) begin
   //      buf_valid[0] <= 1'b0;
   //  end else if((buf_valid[0] == 1'b0)&(m_axis_tvalid)) begin
   //      buf_valid[0] <= 1'b1;
   //      buf_data[0]  <= m_axis_tdata;
   //  end
   //end
  //TREADY MUXING to Internal FIFO
  generate if(C_LOG_DATA_OFFLD == 0) begin : STRM_OFFLD
    assign m_axis_tready_int = m_axis_tready;
  end
  endgenerate
  //generate if(C_LOG_DATA_OFFLD == 1 & WORDS_IN_ENTRY == 1) begin : MM_OFFLD_EQ1
  //  //pass s_axi_offld_rready to m_axis_tready_int if its a valid rd req
  //  assign m_axis_tready_int = rd_dphase & valid_rd_req ? s_axi_offld_rready : 1'b0;
  //end
  //endgenerate
  generate if(C_LOG_DATA_OFFLD == 1 & WORDS_IN_ENTRY > 1) begin : MM_OFFLD_GT1
    assign m_axis_tready_int = (buf_valid[0] == 1'b0) | (buf_valid[1] == 1'b0) ;
  end
  endgenerate

  //generate if(WORDS_IN_ENTRY == 1 && C_LOG_DATA_OFFLD == 1) begin :WORDS_EQ_1
  ////WORDS_IN_ENTRY == 1 case(data width is 32-bit)
  ////In this case no conversion required, data from FIFO 
  ////can be sent on AXIMM-32 bit
  //  
  //assign s_axi_offld_rvalid  = (rd_dphase & valid_rd_req) ? (m_axis_tvalid) :
  //                       ((rd_dphase & ~valid_rd_req) ? 1'b1 : 1'b0);
  //assign s_axi_offld_rdata   = m_axis_tdata;
  // always @(posedge s_axi_offld_aclk) begin
  //     buf_valid[1:0] <= 2'b00;   
  // end
  //end
  //endgenerate
//generate if(WORDS_IN_ENTRY > 1 && C_LOG_DATA_OFFLD == 1) begin :WORDS_GT_1
  //WORDS_IN_ENTRY > 1 case(data width is  > 32-bit)
  //Conversion of data to 32-bit data is required.
  //buffer qualifiers
   reg [C_AXIS_DWIDTH_ROUND_TO_32-1:0] buf_data[1:0];
   reg [WORDS_IN_ENTRY:0] addr_train; 
   reg [7:0] addr_train_index;
   wire load_buf_data;
   wire buffer_valid;
   reg nxt_data_valid_d1;

   //sample conditions
   wire data_sampled = s_axi_offld_rvalid & s_axi_offld_rready;
   wire last_sampled = s_axi_offld_rvalid & s_axi_offld_rready & s_axi_offld_rlast;
   wire launch_rdata = (buffer_valid ) & rd_dphase;
   wire nxt_data_valid = buffer_valid & valid_rd_req;
   wire launched_new_data = (data_sampled & ~last_sampled)|((nxt_data_valid & ~nxt_data_valid_d1)) ;

  //-copy tdata to internal buffer.
   //2-deep buffer
   always @(posedge rd_clk     ) begin
     if(rd_rstn == RST_ACTIVE) begin
       buf_valid[1:0] <= 2'b00;   
       buf_data[0] <= {C_AXIS_DWIDTH_ROUND_TO_32{1'b0}};
       buf_data[1] <= {C_AXIS_DWIDTH_ROUND_TO_32{1'b0}};
     end else if(buf_valid[0] & addr_train[WORDS_IN_ENTRY-1]& valid_rd_req & data_sampled & (WORDS_IN_ENTRY >1)) begin
         if(buf_valid[1]) begin
           buf_valid[0] <= buf_valid[1];
           buf_data[0] <= buf_data[1];
           if(m_axis_tvalid_int & m_axis_tready_int) begin //another sampl avlbl
             buf_valid[1] <= 1'b1;
             buf_data[1]  <= m_axis_tdata_int;
           end else begin
             buf_valid[1] <= 1'b0;
           end
         end else begin
           if(m_axis_tvalid_int & m_axis_tready_int) begin //another sampl avlbl
             buf_valid[0] <= 1'b1;
             buf_data[0]  <= m_axis_tdata_int;
           end else begin
             buf_valid[0] <= 1'b0;
           end
         end
     end else if((buf_valid[0] == 1'b0)&(m_axis_tvalid_int & m_axis_tready_int)) begin
         buf_valid[0] <= 1'b1;
         buf_data[0]  <= m_axis_tdata_int;
     end else if((buf_valid[1] == 1'b0)&(m_axis_tvalid_int & m_axis_tready_int)) begin
         buf_valid[1] <= 1'b1;
         buf_data[1]  <= m_axis_tdata_int;
     end
   end

  
  wire req_pend;
  //address indicator
  assign req_pend = (|(rd_cnt+1'b1) ) & rd_dphase ;
  //assign load_buf_data = (s_axi_offld_arready | req_pend) & buf_valid[0] & (addr_train[WORDS_IN_ENTRY]);
  assign load_buf_data = (s_axi_offld_arready | (req_pend & ~(s_axi_offld_rvalid & ~s_axi_offld_rready))) & ( (buf_valid[0] & addr_train[WORDS_IN_ENTRY]) |(buf_valid[1] & addr_train[WORDS_IN_ENTRY-1]));
  assign buffer_valid   = |(addr_train[WORDS_IN_ENTRY-1:0]);

  wire [C_AXIS_DWIDTH_ROUND_TO_32-1:0] data2tx;
  wire [31:0] data2txi[WORDS_IN_ENTRY:0];
   //1-deep buffer
   //always @(posedge s_axi_offld_aclk) begin
   //   if(s_axi_offld_aresetn == RST_ACTIVE) begin
   //     addr_train[WORDS_IN_ENTRY-1:0] <= {WORDS_IN_ENTRY{1'b0}};
   //     addr_train[WORDS_IN_ENTRY] <= 1'b1;
   //   end else if (load_buf_data) begin
   //     addr_train[WORDS_IN_ENTRY:1] <= {WORDS_IN_ENTRY{1'b0}};
   //     addr_train[0] <= 1'b1;
   //   end else if (addr_train[WORDS_IN_ENTRY]) begin //wait till next load.
   //     addr_train <= addr_train;
   //   end else if (launched_new_data & valid_rd_req) begin
   //     addr_train <= {addr_train[WORDS_IN_ENTRY-1:0],addr_train[WORDS_IN_ENTRY]};
   //   end else begin
   //   end
   //end
   //2-deep buffer
   always @(posedge rd_clk     ) begin
      if(rd_rstn == RST_ACTIVE) begin
        addr_train[WORDS_IN_ENTRY-1:0] <= {WORDS_IN_ENTRY{1'b0}};
        addr_train[WORDS_IN_ENTRY] <= 1'b1;
        addr_train_index <= 7'h0;
      end else if (load_buf_data) begin
        addr_train[WORDS_IN_ENTRY:1] <= {WORDS_IN_ENTRY{1'b0}};
        addr_train[0] <= 1'b1;
        addr_train_index <= 7'h0;
      end else if (addr_train[WORDS_IN_ENTRY]) begin //wait till next load.
        addr_train <= addr_train;
        addr_train_index <= addr_train_index;
      end else if (launched_new_data & valid_rd_req & ~launch_erresp_data) begin
        addr_train <= {addr_train[WORDS_IN_ENTRY-1:0],addr_train[WORDS_IN_ENTRY]};
        addr_train_index <= addr_train_index + 1'b1;
      end else begin
        addr_train <= addr_train;
      end
   end

   assign  data2tx = buf_data[0];
   //slice buf_data as 2-d array with 32b data in each entry 
   assign  data2txi[WORDS_IN_ENTRY] = 32'h0;
   genvar i;
   generate
   for (i=0; i<WORDS_IN_ENTRY; i=i+1) begin : DATA2TX_SLICE 
      assign  data2txi[i] = buf_data[0][i*32+31:i*32];
   end
   endgenerate  
   wire [31:0] rdata_i;
   assign rdata_i = data2txi[addr_train_index];
   //place rdata onto interface :WORDS_IN_ENTRY =2
   reg [31:0] s_axi_offld_rdata_i;

   always @(posedge rd_clk     ) begin
      if(rd_rstn == RST_ACTIVE) begin
        s_axi_offld_rdata_i <= 32'h0;
      end else if(s_axi_offld_rvalid & ~s_axi_offld_rready) begin
        s_axi_offld_rdata_i <= s_axi_offld_rdata_i;
      end else begin
        s_axi_offld_rdata_i <= rdata_i;
        //if(addr_train[0]) begin
        //  s_axi_offld_rdata_i <= data2tx[31:0];
        //end else if(addr_train[1]) begin
        //  s_axi_offld_rdata_i <= data2tx[63:32];
        //end
      end
   end
   reg s_axi_offld_rvalid_i; 
   always @(posedge rd_clk     ) begin
      if(rd_rstn == RST_ACTIVE) begin
        s_axi_offld_rvalid_i <= 1'b0;
      end else if(s_axi_offld_rvalid_i & s_axi_offld_rready & s_axi_offld_rlast) begin
        s_axi_offld_rvalid_i <= 1'b0;
      end else if(s_axi_offld_rvalid_i & ~s_axi_offld_rready) begin
        s_axi_offld_rvalid_i <= s_axi_offld_rvalid_i;
      end else begin
        if(launch_erresp_data) begin //FIFO is empty but axi req is incomplete.
          s_axi_offld_rvalid_i <= 1'b1;
        end else if(addr_train[WORDS_IN_ENTRY]) begin //all contents of buffer are sent.
          s_axi_offld_rvalid_i <= 1'b0;
        end else if(launch_rdata)begin
          s_axi_offld_rvalid_i <= 1'b1;
        end
      end
   end
   assign s_axi_offld_rvalid = s_axi_offld_rvalid_i;
  //delayed signal generators.
  always @(posedge rd_clk     ) begin
    if(rd_rstn == RST_ACTIVE) begin
      nxt_data_valid_d1 <= 1'b0;
    end else begin
      nxt_data_valid_d1 <= nxt_data_valid;
    end
  end
//end
//endgenerate
   // Fifo occupancy generation
   //always @(posedge rd_clk     ) begin
   //  if(rd_rstn == RST_ACTIVE) begin
   //    curr_fifo_oc <= 'h0;
   //  //end else if(fifo_rd_en & fifo_wr_en) begin
   //  //  curr_fifo_oc <= curr_fifo_oc;
   //  //end else if(fifo_rd_en) begin
   //  //  curr_fifo_oc <= curr_fifo_oc - 2'b10;
   //  //end else if(fifo_wr_en) begin
   //  //  curr_fifo_oc <= curr_fifo_oc + 2'b10;
   //  end else begin
   //    //curr_fifo_oc <= {rd_data_count[DATA_CNT_WIDTH-1:0],1'b0} ;
   //    // Add 1 to current read count due to FWFT(First word fall through set)
   //    curr_fifo_oc <= (2'b01+rd_data_count[DATA_CNT_WIDTH-1:0])*WORDS_IN_ENTRY ;
   //  end
   //end

   //map/un-map outputs based on offload selection
   generate if(C_LOG_DATA_OFFLD == 0) begin : ARREADY_OFF 
     assign s_axi_offld_arready = 1'b0;
     assign s_axi_offld_rdata = 32'h0;
   end else begin : ARREADY_ON
     assign s_axi_offld_arready = s_axi_offld_arready_i;
     assign s_axi_offld_rdata = s_axi_offld_rdata_i;
   end
   endgenerate

  //TODO:REMOVE:TBCODE
  //initial begin
  //  s_axi_offld_araddr <= 'h0; 
  //  s_axi_offld_arvalid <= 'h0; 
  //  s_axi_offld_arid <= 'h0; 
  //  s_axi_offld_arlen <= 'h1F; 
  //  #6567 ;
  //  #22;
  //  s_axi_offld_arvalid <= 1'b1;
  //  #22 ;
  //  s_axi_offld_arvalid <= 1'b1;
  //  s_axi_offld_arlen <= 'h5; 
  //  #1366220 ;
  //  s_axi_offld_arvalid <= 1'b1;
  //  s_axi_offld_arlen <= 'h1; 
  //end
  //initial begin
  //  s_axi_offld_rready <= 'h0; 
  //  #6650;
  //  s_axi_offld_rready <= 'h1; 
  //  #1260;
  //  s_axi_offld_rready <= 'h0; 
  //  #60;
  //  s_axi_offld_rready <= 'h1; 
  //  #824700;
  //  s_axi_offld_rready <= 'h0; 
  //  #100;
  //  s_axi_offld_rready <= 'h1; 
  //end

  //chker
   //always @(posedge rd_clk     ) begin
   //  if(m_axis_tvalid_int & m_axis_tready_int) begin
   //    $display ("PR:AXIS:%x",m_axis_tdata_int);
   //  end
   //end
   //always @(posedge rd_clk     ) begin
   //  if(s_axi_offld_rvalid & s_axi_offld_rready & (s_axi_offld_rresp == 2'b00)) begin
   //    $display ("PR:AXIM:%x",s_axi_offld_rdata);
   //  end
   //end
endmodule


//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename:        axi_perf_mon_v5_0_12_axi_interface.v
// Version:         v5.0
// Description:     This module takes care of AXI protocol interface for AXI4 
//                  AXI4-Lite interfaces. This supports word access and INCR 
//                  burst only.
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
// -- axi_perf_mon.v
//     \-- axi_perf_mon_v5_0_12_axi_interface.v
//
//-----------------------------------------------------------------------------
// Author:      Kalpanath
// History:
// Kalpanath    07/25/2012      First Version
// NLR          03/20/2013      Added AXI4 Full interface support with ID 
//                              reflection
//-----------------------------------------------------------------------------
`timescale 1ns/1ps
module axi_perf_mon_v5_0_12_axi_interface 
#(
   parameter                              C_FAMILY                = "virtex7",
   // AXI port dependant parameters
   parameter                              C_S_AXI_PROTOCOL        = "AXI4LITE",
   parameter                              C_S_AXI_ADDR_WIDTH      = 32,
   parameter                              C_S_AXI_DATA_WIDTH      = 32,
   parameter                              C_S_AXI_ID_WIDTH        = 1,
   parameter                              C_SUPPORT_ID_REFLECTION = 0
)
(
   input                                  S_AXI_ACLK,
   input                                  S_AXI_ARESETN,
   // AXI Write Address Channel
   input [C_S_AXI_ADDR_WIDTH - 1:0]       S_AXI_AWADDR, 
   input                                  S_AXI_AWVALID,   
   input [C_S_AXI_ID_WIDTH-1:0]           S_AXI_AWID,   
   output                                 S_AXI_AWREADY,    
   // AXI Write Data Channel
   input [C_S_AXI_DATA_WIDTH - 1:0]       S_AXI_WDATA, 
   input [(C_S_AXI_DATA_WIDTH / 8) - 1:0] S_AXI_WSTRB, 
   input                                  S_AXI_WVALID, 
   output                                 S_AXI_WREADY, 
   // AXI Write Response Channel
   output[1:0]                            S_AXI_BRESP, 
   output                                 S_AXI_BVALID,   
   output [C_S_AXI_ID_WIDTH-1:0]          S_AXI_BID,   
   input                                  S_AXI_BREADY, 
   // AXI Read Address Channel
   input [C_S_AXI_ADDR_WIDTH - 1:0]       S_AXI_ARADDR, 
   input                                  S_AXI_ARVALID, 
   input [C_S_AXI_ID_WIDTH-1:0]           S_AXI_ARID,   
   output                                 S_AXI_ARREADY, 
   // AXI Read Data Channel
   output[C_S_AXI_DATA_WIDTH - 1:0]       S_AXI_RDATA, 
   output[1:0]                            S_AXI_RRESP, 
   output                                 S_AXI_RVALID, 
   output [C_S_AXI_ID_WIDTH-1:0]          S_AXI_RID,   
   input                                  S_AXI_RREADY, 
   // Controls to the IP/IPIF modules
   output[(C_S_AXI_ADDR_WIDTH - 1):0]     Bus2IP_Addr,  
   output[(C_S_AXI_DATA_WIDTH - 1):0]     Bus2IP_Data,    
   output[((C_S_AXI_DATA_WIDTH / 8)-1):0] Bus2IP_BE, 
   output                                 Bus2IP_Burst,   
   output                                 Bus2IP_RdCE,   
   output                                 Bus2IP_WrCE,   
   input [(C_S_AXI_DATA_WIDTH - 1):0]     IP2Bus_Data, 
   input                                  IP2Bus_DataValid,
   input                                  IP2Bus_Error
);

//-------------------------------------------------------------------
// Parameter Declaration
//-------------------------------------------------------------------
localparam RST_ACTIVE = 1'b0;


//-------------------------------------------------------------------
// Signal Declaration
//-------------------------------------------------------------------
reg                                awready_i;
reg                                write_req;
reg                                read_req;
reg                                arready_i;
reg                                rvalid;
reg                                bvalid;
reg [(C_S_AXI_DATA_WIDTH - 1):0]   IP2Bus_Data_sampled;

reg [(C_S_AXI_ADDR_WIDTH - 1):0]   bus2ip_addr_i;
wire                               bus2ip_rdce_i;
reg                                bus2ip_rdce_i_d1;

//-------------------------------------------------------------------
// Begin architecture
//-------------------------------------------------------------------
wire wr_req_pend_pulse;
reg [(C_S_AXI_ADDR_WIDTH - 1):0]   wr_req_pend_addr;


// AXI signal assignment
assign  S_AXI_AWREADY = awready_i;
assign  S_AXI_WREADY  = write_req & !read_req;
assign  S_AXI_ARREADY = arready_i;
assign  S_AXI_BRESP   = 2'b0;
assign  S_AXI_BVALID  = bvalid;
assign  S_AXI_RDATA   = IP2Bus_Data_sampled;
assign  S_AXI_RRESP   = 2'b0;

//IPIC signal assignment          
assign  Bus2IP_Addr   = bus2ip_addr_i;
assign  Bus2IP_Data   = S_AXI_WDATA;
assign  Bus2IP_WrCE   = S_AXI_WVALID && write_req;
assign  Bus2IP_RdCE   = bus2ip_rdce_i;
assign  Bus2IP_BE     = S_AXI_WSTRB;
assign  Bus2IP_Burst  = 1'b0;

//CR#782670
reg wr_req_pend;
assign wr_req_pend_pulse = S_AXI_AWVALID & S_AXI_AWREADY & S_AXI_ARVALID & S_AXI_ARREADY;
always @(posedge S_AXI_ACLK) begin 
  if (S_AXI_ARESETN == RST_ACTIVE) begin
    wr_req_pend <=1'b0;
  end else if(S_AXI_AWVALID & S_AXI_AWREADY & S_AXI_ARVALID & S_AXI_ARREADY)begin
    wr_req_pend <= 1'b1; 
  end else if(Bus2IP_RdCE) begin
    wr_req_pend <= 1'b0; 
  end
end
// --------------------------------------------------------------------------
// ID reflection for AXI4 Full interface support
//---------------------------------------------------------------------------
 
generate 
if (C_SUPPORT_ID_REFLECTION == 1) begin : GEN_AXI4FULL
 
  reg [C_S_AXI_ID_WIDTH-1:0]  S_AXI_BID_Reg;
  reg [C_S_AXI_ID_WIDTH-1:0]  S_AXI_RID_Reg;

  // ------------------------------------------------------------------------
  // Process to reflect AWID over BID to support AXI4 Full Interface
  // ------------------------------------------------------------------------
  always @(posedge S_AXI_ACLK) begin : AXI_AWID_P
     if (S_AXI_ARESETN == RST_ACTIVE) begin
         S_AXI_BID_Reg <= 0;
     end
     else begin
         S_AXI_BID_Reg <= S_AXI_AWID;
     end
  end
  
  // ------------------------------------------------------------------------
  // Process to reflect ARID over RID to support AXI4 Full Interface
  // ------------------------------------------------------------------------
  always @(posedge S_AXI_ACLK) begin : AXI_ARID_P
     if (S_AXI_ARESETN == RST_ACTIVE) begin
         S_AXI_RID_Reg <= 0;
     end
     else begin
         S_AXI_RID_Reg <= S_AXI_ARID;
     end
  end

  assign S_AXI_BID = S_AXI_BID_Reg;
  assign S_AXI_RID = S_AXI_RID_Reg;

end

// ----------------------------------------------------------------------------
// No ID reflection for AXI4LITE Protocol
// ---------------------------------------------------------------------------

else if (C_SUPPORT_ID_REFLECTION == 0) begin : GEN_AXI4LIGHT

   assign S_AXI_BID = 0;
   assign S_AXI_RID = 0;
  
end
endgenerate



//  -----------------------------------------------------------------------
//  Process AXI_AWREADY_P to generate Write request on the IPIC
//  -----------------------------------------------------------------------
always @(posedge S_AXI_ACLK) begin : AXI_AWREADY_P
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       awready_i <= 1'b0;
   end
   else if ((S_AXI_AWVALID == 1'b1) && (awready_i == 1'b1)) begin
       awready_i <= 1'b0;
   end
   else begin
       awready_i <= (!write_req) && !(S_AXI_ARVALID || read_req || rvalid);
   end
end 

reg rd_in_progress;
always @(posedge S_AXI_ACLK) begin : AXI_ARREADY_P
  if (S_AXI_ARESETN == RST_ACTIVE) begin
    rd_in_progress <= 1'b0;
  end else if(read_req) begin
    rd_in_progress <= 1'b1;
  end else if(S_AXI_RVALID & S_AXI_RREADY) begin
    rd_in_progress <= 1'b0;
  end
end

//  -----------------------------------------------------------------------
//  Process AXI_ARREADY_P to generate Write request on the IPIC
//  -----------------------------------------------------------------------
always @(posedge S_AXI_ACLK) begin
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       arready_i <= 1'b0;
   end
   else if ((S_AXI_ARVALID == 1'b1) && (arready_i == 1'b1)) begin
       arready_i <= 1'b0;
   end
   else begin
       arready_i <= (!read_req) && (!rd_in_progress) && !(S_AXI_AWVALID || write_req);
   end
end 


//  -----------------------------------------------------------------------
//  Process AXI_READ_OUTPUT_P to generate Write request on the IPIC
//  -----------------------------------------------------------------------
assign S_AXI_RVALID = rvalid;

always @(posedge S_AXI_ACLK) begin 
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       IP2Bus_Data_sampled <= 0;
   end
   else if (IP2Bus_DataValid == 1'b1) begin
       IP2Bus_Data_sampled <= IP2Bus_Data;
   end
   else begin
       IP2Bus_Data_sampled <= IP2Bus_Data_sampled;
   end
end 


//  -----------------------------------------------------------------------
//  Process WRITE_REQUEST_P to generate Write request on the IPIC
//  -----------------------------------------------------------------------

always @(posedge S_AXI_ACLK) begin : WRITE_REQUEST_P
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       write_req <= 1'b0;
   end
   else if ((S_AXI_AWVALID == 1'b1) && (awready_i == 1'b1)) begin
       write_req <= 1'b1;
   end
   else if ((write_req == 1'b1) && (S_AXI_WVALID == 1'b1)) begin
       write_req <= 1'b0;
   end
   else begin
       write_req <= write_req;
   end
end 

//  -----------------------------------------------------------------------
//  Process READ_REQUEST_P to generate read request
//  -----------------------------------------------------------------------
always @(posedge S_AXI_ACLK) begin : READ_REQUEST_P
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       read_req <= 1'b0;
   end
   else if ((S_AXI_ARVALID == 1'b1) && (arready_i == 1'b1)) begin
       read_req <= 1'b1;
   end
   else if (read_req == 1'b1) begin
       read_req <= 1'b0;
   end
   else begin
       read_req <= read_req;
   end
end 

always @(posedge S_AXI_ACLK) begin 
 if (S_AXI_ARESETN == RST_ACTIVE) begin
   wr_req_pend_addr <= 0;
 end else if(wr_req_pend_pulse) begin
   wr_req_pend_addr <= S_AXI_AWADDR;
 end 
end
//  -----------------------------------------------------------------------
//  Process ADDR_GEN_P to generate bus2ip_addr for read/write
//  -----------------------------------------------------------------------
always @(posedge S_AXI_ACLK) begin : ADDR_GEN_P
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       bus2ip_addr_i <= 0;
   end
   else if ((S_AXI_ARVALID == 1'b1) && (arready_i == 1'b1)) begin
       bus2ip_addr_i <= S_AXI_ARADDR;
   end
   else if ((S_AXI_AWVALID == 1'b1) && (awready_i == 1'b1)) begin
       bus2ip_addr_i <= S_AXI_AWADDR;
   end
   else if (wr_req_pend) begin
       bus2ip_addr_i <= wr_req_pend_addr;
   end
   else begin
       bus2ip_addr_i <= bus2ip_addr_i;
   end
end 

//  -----------------------------------------------------------------------
//  Process WRITE_BVALID_P to generate Write Response valid
//  -----------------------------------------------------------------------
always @(posedge S_AXI_ACLK) begin : WRITE_BVALID_P
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       bvalid <= 1'b0;
   end
   else if ((S_AXI_WREADY == 1'b1) && (S_AXI_WVALID == 1'b1)) begin
   //else if (write_req == 1'b1) begin
       bvalid <= 1'b1;
   end
   else if (S_AXI_BREADY == 1'b1) begin
       bvalid <= 1'b0;
   end
   else begin
       bvalid <= bvalid;
   end
end 

//  -----------------------------------------------------------------------
//  Process READ_RVALID_P to generate Read valid
//  -----------------------------------------------------------------------
always @(posedge S_AXI_ACLK) begin : READ_RVALID_P
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       rvalid <= 1'b0;
   end
   else if (IP2Bus_DataValid == 1'b1) begin
       rvalid <= 1'b1;
   end
   else if (S_AXI_RREADY == 1'b1) begin
       rvalid <= 1'b0;
   end
   else begin
       rvalid <= rvalid;
   end
end 

// Read request on IPIC
assign bus2ip_rdce_i = read_req;
      
endmodule


//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename   :     axi_perf_mon_v5_0_12_counter.v
// Version    :     v5.0
// Description:     Implements a parameterizable N-bit axi_perf_mon_v5_0_12_counter
//                  Up/Down axi_perf_mon_v5_0_12_counter
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
// axi_perf_mon.v
//     \-- axi_perf_mon_v5_0_12_metric_calc.v
//         \-- axi_perf_mon_v5_0_12_counter.v
//      \-- axi_perf_mon_v5_0_12_glbl_clk_cnt.v
//         \-- axi_perf_mon_v5_0_12_counter.v
//      \-- axi_perf_mon_v5_0_12_metric_counters.v
//         \-- axi_perf_mon_v5_0_12_metric_sel_n_cnt.v 
//            \--axi_perf_mon_v5_0_12_acc_n_incr.v
//               \--axi_perf_mon_v5_0_12_counter.v
//      \-- axi_perf_mon_v5_0_12_samp_intl_cnt.v
//               \-- axi_perf_mon_v5_0_12_counter.v
//-----------------------------------------------------------------------------
// Author:      Kalpanath
// History:
// Kalpanath 07/25/2012      First Version
// ^^^^^^
//-----------------------------------------------------------------------------
`timescale 1ns/1ps
(* DowngradeIPIdentifiedWarnings="yes" *)

module axi_perf_mon_v5_0_12_counter 
#(
   parameter                          C_FAMILY             = "nofamily",
   parameter                          C_NUM_BITS           = 32,
   parameter                          COUNTER_LOAD_VALUE   = 32'h00000000
)
(
   input                              clk,
   input                              rst_n,

   input [(C_NUM_BITS - 1):0]         Load_In,  
   input                              Count_Enable,   
   input                              Count_Load,   
   input                              Count_Down,   
   output [(C_NUM_BITS - 1):0]        Count_Out,  
   output reg                         Carry_Out   

);

//-------------------------------------------------------------------
// Parameter Declaration
//-------------------------------------------------------------------
localparam RST_ACTIVE = 1'b0;

//-------------------------------------------------------------------
// Signal Declaration
//-------------------------------------------------------------------
wire [63:0] rst_load_64 = (COUNTER_LOAD_VALUE == 32'h00000000)?64'h0000000000000000:{32'hFFFFFFFF,COUNTER_LOAD_VALUE};
wire                    Overflow;
reg                     Overflow_D1;
reg  [C_NUM_BITS:0]     Count_Out_i;  

//-------------------------------------------------------------------
// Begin architecture
//-------------------------------------------------------------------
//-- counter
always @(posedge clk) begin
   if (rst_n == RST_ACTIVE) begin
       Count_Out_i <= {1'b0,rst_load_64[C_NUM_BITS-1:0]};
   end
   else begin
       if (Count_Load == 1'b1) begin
           Count_Out_i <= {1'b0, Load_In};
       end
       else if (Count_Enable == 1'b1) begin
           if (Count_Down == 1'b1) begin
               Count_Out_i <= Count_Out_i - 1;
           end
           else begin
               Count_Out_i <= Count_Out_i + 1;
           end
       end
       else begin
           Count_Out_i <= Count_Out_i;
       end
   end
end 


assign Overflow  = Count_Out_i[C_NUM_BITS] ;
assign Count_Out = Count_Out_i[C_NUM_BITS - 1:0];

//-- Delaying Overflow
always @(posedge clk) begin 
   if (rst_n == RST_ACTIVE) begin
       Overflow_D1 <= 1'b0;
   end
   else begin
       Overflow_D1 <= Overflow;
   end
end 

//-- Overflow Pulse
always @(posedge clk) begin 
   if (rst_n == RST_ACTIVE) begin
       Carry_Out <= 1'b0;
   end
   else begin
       Carry_Out <= Overflow & (~Overflow_D1);
   end
end 

endmodule




//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename   :     axi_perf_mon_v5_0_12_counter_ovf.v
// Version    :     v5.0
// Description:     Implements a parameterizable N-bit axi_perf_mon_v5_0_12_counter
//                  Up/Down axi_perf_mon_v5_0_12_counter
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
// axi_perf_mon.v
//     \-- axi_perf_mon_v5_0_12_metric_calc.v
//         \-- axi_perf_mon_v5_0_12_counte_ovf.v
//-----------------------------------------------------------------------------
// Author:      Kartheek
// History:
// Kartheek 12/18/2014      First Version
// ^^^^^^
//-----------------------------------------------------------------------------
`timescale 1ns/1ps
//(* DowngradeIPIdentifiedWarnings="yes" *)

module axi_perf_mon_v5_0_12_counter_ovf 
#(
   parameter                          C_FAMILY             = "nofamily",
   parameter                          C_NUM_BITS           = 32,
   parameter                          COUNTER_LOAD_VALUE   = 32'h00000000
)
(
   input                              clk,
   input                              rst_n,

   input [(C_NUM_BITS - 1):0]         Load_In,  
   input                              Count_Enable,   
   input                              Count_Load,   
   input                              Count_Down,   
   output [(C_NUM_BITS - 1):0]        Count_Out,  
   output                             Carry_Out   

);

//-------------------------------------------------------------------
// Parameter Declaration
//-------------------------------------------------------------------
localparam RST_ACTIVE = 1'b0;

//-------------------------------------------------------------------
// Signal Declaration
//-------------------------------------------------------------------
wire [63:0] rst_load_64 = (COUNTER_LOAD_VALUE == 32'h00000000)?64'h0000000000000000:{32'hFFFFFFFF,COUNTER_LOAD_VALUE};

   reg [C_NUM_BITS :0]        Count_Out_i; 

//-------------------------------------------------------------------
// Begin architecture
//-------------------------------------------------------------------
//-- counter
always @(posedge clk) begin
   if (rst_n == RST_ACTIVE) begin
       Count_Out_i <= {1'b0,rst_load_64[C_NUM_BITS-1:0]};
   end
   else begin
       if (Count_Load == 1'b1) begin
           Count_Out_i <= {1'b0, Load_In};
       end
       else if (Count_Enable == 1'b1) begin
           if (Count_Down == 1'b1) begin
               Count_Out_i <= Count_Out_i - 1;
           end
           else begin
               Count_Out_i <= Count_Out_i + 1;
           end
       end
       else begin
           Count_Out_i <= Count_Out_i;
       end
   end
end 


assign Carry_Out = Count_Out_i[C_NUM_BITS] ;
assign Count_Out = Count_Out_i[C_NUM_BITS - 1:0];


endmodule




//-------------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename     : axi_perf_mon_v5_0_12_cdc_sync.v
// Version      : v5.0
// Description  : This is the top level wrapper file for the monitor-Slots of AXI
//                interface. It has the AXI slots input and sends out the
//                synchronized outputs through Asynchronous FIFO
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
// --  axi_perf_mon.v
//      \-- axi_perf_mon_v5_0_12_cdc_sync.v
//
//-----------------------------------------------------------------------------
// Author :   NLR 
// History:    
// NLR       10/02/2013      First Version
// ^^^^^^
//-----------------------------------------------------------------------------
`timescale 1ns/1ps

module axi_perf_mon_v5_0_12_cdc_sync
   # (
       parameter [1:0] c_cdc_type      = 1,   // 0 Pulse synchronizer, 1 level synchronizer 2 level synchronizer with ACK 
       parameter [0:0] c_flop_input    = 0,   // 1 Adds one flop stage to the input prmry_in signal
       parameter [0:0] c_reset_state   = 0,   // 1 Reset needed for sync flops 
       parameter [0:0] c_single_bit    = 1,   // 1 single bit input.
       parameter [5:0] c_vector_width  = 32,  // defines the size of bus and irrelevant when C_SINGLE_BIT = 1
       parameter [2:0] c_mtbf_stages   = 2    // Number of sync stages needed
     )  
     (
       input                           prmry_aclk,
       input                           prmry_rst_n,
       input                           prmry_in,
       input [(c_vector_width-1 ):0]   prmry_vect_in,
       input                           scndry_aclk,
       input                           scndry_rst_n,
       output                          prmry_ack,
       output                          scndry_out,
       output [(c_vector_width-1 ):0]  scndry_vect_out
      );

  
    // Internal signal declarations
    wire s_out_re;
    wire p_level_in_int;
    wire [( c_vector_width - 1 ):0]p_level_in_bus_d1_cdc_from;
    wire [( c_vector_width - 1 ):0]s_level_out_bus_d1_cdc_tig;
    wire scndry_out_int;
    wire prmry_pulse_ack;
  
    // Internal Reg declarations
     (* async_reg = "true" *) reg p_level_in_d1_cdc_from;
     (* async_reg = "true" *) reg prmry_ack_int;
     (* async_reg = "true" *) reg p_level_out_d1_cdc_to;
     (* async_reg = "true" *) reg p_level_out_d2;
     (* async_reg = "true" *) reg p_level_out_d3;
     (* async_reg = "true" *) reg p_level_out_d4;
     (* async_reg = "true" *) reg p_level_out_d5;
     (* async_reg = "true" *) reg p_level_out_d6;
     (* async_reg = "true" *) reg p_level_out_d7;
     
     (* async_reg = "true" *) reg p_in_d1_cdc_from;
     (* async_reg = "true" *) reg s_out_d1_cdc_to;
     (* async_reg = "true" *) reg s_out_d2;
     (* async_reg = "true" *) reg s_out_d3;
     (* async_reg = "true" *) reg s_out_d4;
     (* async_reg = "true" *) reg s_out_d5;
     (* async_reg = "true" *) reg s_out_d6;
     (* async_reg = "true" *) reg s_out_d7;
     (* async_reg = "true" *) reg scndry_out_int_d1;
     
     (* async_reg = "true" *) reg s_level_out_d1_cdc_to;
     (* async_reg = "true" *) reg s_level_out_d2;
     (* async_reg = "true" *) reg s_level_out_d3;
     (* async_reg = "true" *) reg s_level_out_d4;
     (* async_reg = "true" *) reg s_level_out_d5;
     (* async_reg = "true" *) reg s_level_out_d6;
     
     (* async_reg = "true" *) reg [( c_vector_width - 1 ):0]s_level_out_bus_d1_cdc_to;
     (* async_reg = "true" *) reg [( c_vector_width - 1 ):0]s_level_out_bus_d2;
     (* async_reg = "true" *) reg [( c_vector_width - 1 ):0]s_level_out_bus_d3;
     (* async_reg = "true" *) reg [( c_vector_width - 1 ):0]s_level_out_bus_d4;
     (* async_reg = "true" *) reg [( c_vector_width - 1 ):0]s_level_out_bus_d5;
     (* async_reg = "true" *) reg [( c_vector_width - 1 ):0]s_level_out_bus_d6;


// Pulse synchronizer Logic
generate if (c_cdc_type == 0) begin 

    always @ (  posedge prmry_aclk)
    begin : REG_P_IN
            if ( ( prmry_rst_n == 1'b0 ) & ( c_reset_state == 1 ) ) 
            begin
                p_in_d1_cdc_from <= 1'b0;
            end
            else
            begin 
                p_in_d1_cdc_from <= prmry_in ^ p_in_d1_cdc_from;
            end
    end

    always @ (  posedge scndry_aclk)
    begin : P_IN_CROSS2SCNDRY
            if ( ( scndry_rst_n == 1'b0 ) & ( c_reset_state == 1 ) ) 
            begin
                s_out_d1_cdc_to <= 1'b0;
                s_out_d2 <= 1'b0;
                s_out_d3 <= 1'b0;
                s_out_d4 <= 1'b0;
                s_out_d5 <= 1'b0;
                s_out_d6 <= 1'b0;
                s_out_d7 <= 1'b0;
                scndry_out_int_d1 <= 1'b0;
            end
            else
            begin 
                s_out_d1_cdc_to <= p_in_d1_cdc_from;
                s_out_d2 <= s_out_d1_cdc_to;
                s_out_d3 <= s_out_d2;
                s_out_d4 <= s_out_d3;
                s_out_d5 <= s_out_d4;
                s_out_d6 <= s_out_d5;
                s_out_d7 <= s_out_d6;
                scndry_out_int_d1 <= s_out_re;
            end
    end
    assign scndry_out = scndry_out_int_d1;
    assign prmry_ack = 1'b0; 
    assign scndry_vect_out = 0;
end
endgenerate


generate if (c_mtbf_stages == 2 & c_cdc_type == 0) begin

    assign s_out_re = ( s_out_d2 ^ s_out_d3 );

end
endgenerate

generate if (c_mtbf_stages == 3 & c_cdc_type == 0) begin

    assign s_out_re = ( s_out_d3 ^ s_out_d4 );

end
endgenerate

generate if (c_mtbf_stages == 4 & c_cdc_type == 0) begin

    assign s_out_re = ( s_out_d4 ^ s_out_d5 );

end
endgenerate

generate if (c_mtbf_stages == 5 & c_cdc_type == 0) begin

    assign s_out_re = ( s_out_d5 ^ s_out_d6 );

end
endgenerate

generate if (c_mtbf_stages == 6 & c_cdc_type == 0) begin

    assign s_out_re = ( s_out_d6 ^ s_out_d7 );

end
endgenerate


//Level Synchronizer Logic with out ACK

generate if (c_flop_input == 1 & c_cdc_type == 1 & c_single_bit == 1) begin

    always @ (  posedge prmry_aclk)
    begin : FLOP_IN
            if ( ( prmry_rst_n == 1'b0 ) & ( c_reset_state == 1 ) ) 
            begin
                p_level_in_d1_cdc_from <= 1'b0;
            end
            else
            begin 
                p_level_in_d1_cdc_from <= prmry_in;
            end
    end

   assign p_level_in_int = p_level_in_d1_cdc_from;

end
endgenerate


generate if (c_flop_input == 0 & c_cdc_type == 1 & c_single_bit == 1) begin


   assign p_level_in_int = prmry_in;

end
endgenerate


//generate if (c_cdc_type == 1) begin 
generate if (c_single_bit == 1 & c_cdc_type == 1) begin

    assign prmry_ack = 1'b0; 
    assign scndry_vect_out = 0;

    always @ (  posedge scndry_aclk)
    begin : CROSS_PLEVEL_IN2SCNDRY
            if ( ( scndry_rst_n == 1'b0 ) & ( c_reset_state == 1 ) ) 
            begin
                s_level_out_d1_cdc_to <= 1'b0;
                s_level_out_d2 <= 1'b0;
                s_level_out_d3 <= 1'b0;
                s_level_out_d4 <= 1'b0;
                s_level_out_d5 <= 1'b0;
                s_level_out_d6 <= 1'b0;
            end
            else
            begin 
                s_level_out_d1_cdc_to <= p_level_in_int;
                s_level_out_d2 <= s_level_out_d1_cdc_to;
                s_level_out_d3 <= s_level_out_d2;
                s_level_out_d4 <= s_level_out_d3;
                s_level_out_d5 <= s_level_out_d4;
                s_level_out_d6 <= s_level_out_d5;
            end
    end
end
endgenerate


generate if (c_mtbf_stages == 1 & c_cdc_type == 1 & c_single_bit == 1) begin

    assign scndry_out = s_level_out_d1_cdc_to;
end
endgenerate

generate if (c_mtbf_stages == 2 & c_cdc_type == 1 & c_single_bit == 1) begin

    assign scndry_out = s_level_out_d2;
end
endgenerate

generate if (c_mtbf_stages == 3 & c_cdc_type == 1 & c_single_bit == 1) begin

    assign scndry_out = s_level_out_d3;
end
endgenerate

generate if (c_mtbf_stages == 4 & c_cdc_type == 1 & c_single_bit == 1) begin

    assign scndry_out = s_level_out_d4;
end
endgenerate

generate if (c_mtbf_stages == 5 & c_cdc_type == 1 & c_single_bit == 1) begin

    assign scndry_out = s_level_out_d5;
end
endgenerate

generate if (c_mtbf_stages == 6 & c_cdc_type == 1 & c_single_bit == 1) begin

    assign scndry_out = s_level_out_d6;
end
endgenerate

generate if (c_single_bit == 0 & c_cdc_type == 1) begin

    assign prmry_ack = 1'b0; 
    assign scndry_out = 1'b0;

    always @ (  posedge scndry_aclk)
    begin : CROSS_PLEVEL_IN2SCNDRY
            if ( ( scndry_rst_n == 1'b0 ) & ( c_reset_state == 1 ) ) 
            begin
                s_level_out_bus_d1_cdc_to <= 0;
                s_level_out_bus_d2 <= 0 ;
                s_level_out_bus_d3 <= 0 ;
                s_level_out_bus_d4 <= 0 ;
                s_level_out_bus_d5 <= 0 ;
                s_level_out_bus_d6 <= 0 ;
            end
            else
            begin 
                s_level_out_bus_d1_cdc_to <= prmry_vect_in;
                s_level_out_bus_d2 <= s_level_out_bus_d1_cdc_to;
                s_level_out_bus_d3 <= s_level_out_bus_d2;
                s_level_out_bus_d4 <= s_level_out_bus_d3;
                s_level_out_bus_d5 <= s_level_out_bus_d4;
                s_level_out_bus_d6 <= s_level_out_bus_d5;
            end
    end

end
endgenerate

generate if (c_mtbf_stages == 1 & c_single_bit == 0 & c_cdc_type == 1) begin

    assign scndry_vect_out = s_level_out_bus_d1_cdc_to;
end
endgenerate

generate if (c_mtbf_stages == 2 & c_single_bit == 0 & c_cdc_type == 1) begin

    assign scndry_vect_out = s_level_out_bus_d2;
end
endgenerate

generate if (c_mtbf_stages == 3 & c_single_bit == 0 & c_cdc_type == 1) begin

    assign scndry_vect_out = s_level_out_bus_d3;
end
endgenerate

generate if (c_mtbf_stages == 4 & c_single_bit == 0 & c_cdc_type == 1) begin

    assign scndry_vect_out = s_level_out_bus_d4;
end
endgenerate

generate if (c_mtbf_stages == 5 & c_single_bit == 0 & c_cdc_type == 1) begin

    assign scndry_vect_out = s_level_out_bus_d5;
end
endgenerate

generate if (c_mtbf_stages == 6 & c_single_bit == 0 & c_cdc_type == 1) begin

    assign scndry_vect_out = s_level_out_bus_d6;
end
endgenerate


//Level synchronizer logic with ACK
generate if (c_flop_input == 1 & c_cdc_type == 2) begin

    always @ (  posedge prmry_aclk)
    begin : FLOP_IN
            if ( ( prmry_rst_n == 1'b0 ) & ( c_reset_state == 1 ) ) 
            begin
                p_level_in_d1_cdc_from <= 1'b0;
            end
            else
            begin 
                p_level_in_d1_cdc_from <= prmry_in;
            end
    end

   assign p_level_in_int = p_level_in_d1_cdc_from;

end
endgenerate


generate if (c_flop_input == 0 & c_cdc_type == 2) begin

   assign p_level_in_int = prmry_in;

end
endgenerate

generate if (c_cdc_type == 2) begin
    always @ (  posedge scndry_aclk)
    begin : CROSS_PLEVEL_IN2SCNDRY
            if ( ( scndry_rst_n == 1'b0 ) & ( c_reset_state == 1 ) ) 
            begin
                s_level_out_d1_cdc_to <= 1'b0;
                s_level_out_d2 <= 1'b0;
                s_level_out_d3 <= 1'b0;
                s_level_out_d4 <= 1'b0;
                s_level_out_d5 <= 1'b0;
                s_level_out_d6 <= 1'b0;
            end
            else
            begin 
                s_level_out_d1_cdc_to <= p_level_in_int;
                s_level_out_d2 <= s_level_out_d1_cdc_to;
                s_level_out_d3 <= s_level_out_d2;
                s_level_out_d4 <= s_level_out_d3;
                s_level_out_d5 <= s_level_out_d4;
                s_level_out_d6 <= s_level_out_d5;
            end
    end

    always @ (  posedge prmry_aclk)
    begin : CROSS_PLEVEL_SCNDRY2PRMRY
            if ( ( prmry_rst_n == 1'b0 ) & ( c_reset_state == 1 ) ) 
            begin
                p_level_out_d1_cdc_to <= 1'b0;
                p_level_out_d2 <= 1'b0;
                p_level_out_d3 <= 1'b0;
                p_level_out_d4 <= 1'b0;
                p_level_out_d5 <= 1'b0;
                p_level_out_d6 <= 1'b0;
                p_level_out_d7 <= 1'b0;
                prmry_ack_int <= 1'b0;
            end
            else
            begin 
                p_level_out_d1_cdc_to <= scndry_out_int;
                p_level_out_d2 <= p_level_out_d1_cdc_to;
                p_level_out_d3 <= p_level_out_d2;
                p_level_out_d4 <= p_level_out_d3;
                p_level_out_d5 <= p_level_out_d4;
                p_level_out_d6 <= p_level_out_d5;
                p_level_out_d7 <= p_level_out_d6;
                prmry_ack_int <= prmry_pulse_ack;
            end
    end
    assign prmry_ack = prmry_ack_int;
    assign scndry_out = scndry_out_int;
    assign scndry_vect_out = 0;
end
endgenerate

  generate if ((c_mtbf_stages == 2 || c_mtbf_stages == 1) & c_cdc_type == 2) begin
  
      assign scndry_out_int = s_level_out_d2;
      assign prmry_pulse_ack = ( p_level_out_d3 ^ p_level_out_d2 );
  end
  endgenerate
  
  generate if (c_mtbf_stages == 3 & c_cdc_type == 2) begin
  
      assign scndry_out_int = s_level_out_d3;
      assign prmry_pulse_ack = ( p_level_out_d4 ^ p_level_out_d3 );
  end
  endgenerate
  
  generate if (c_mtbf_stages == 4 & c_cdc_type == 2) begin
  
      assign scndry_out_int = s_level_out_d4;
      assign prmry_pulse_ack = ( p_level_out_d5 ^ p_level_out_d4 );
  end
  endgenerate
  
  generate if (c_mtbf_stages == 5 & c_cdc_type == 2) begin
  
      assign scndry_out_int = s_level_out_d5;
      assign prmry_pulse_ack = ( p_level_out_d6 ^ p_level_out_d5 );
  end
  endgenerate
  
  generate if (c_mtbf_stages == 6 & c_cdc_type == 2) begin
  
      assign scndry_out_int = s_level_out_d6;
      assign prmry_pulse_ack = ( p_level_out_d7 ^ p_level_out_d6 );
  end
  endgenerate

endmodule 


//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename   : axi_perf_mon_v5_0_12_flags_gen.v
// Version    : v5.0
// Description: This module detects the events over AXI interface and generates
//              the flags
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
// axi_perf_mon.v
//       \-- axi_perf_mon_v5_0_12_flags_gen.v
//-----------------------------------------------------------------------------
// Author:      Kalpanath
// History:
// Kalpanath 07/25/2012      First Version
// ^^^^^^
// NLR       03/20/2012      Added external trigger start and stop
// ^^^^^^
//-----------------------------------------------------------------------------
`timescale 1ns/1ps
module axi_perf_mon_v5_0_12_flags_gen 
#(
   parameter C_FAMILY                 = "nofamily",
   parameter C_MON_FIFO_DATA_WIDTH    = 64,
   parameter C_LOG_WIDTH              = 71,
   parameter C_FLAG_WIDTH             = 7,  //-- 7: for AXI4   2: for AXI4S
   //AXI Slot Interface parameters
   parameter C_AXI_ADDR_WIDTH         = 32,
   parameter C_AXI_DATA_WIDTH         = 32,
   parameter C_AXI_ID_WIDTH           = 1,
   parameter C_AXI_PROTOCOL           = "AXI4",
   parameter C_AXIS_TDATA_WIDTH       = 32,
   parameter C_AXIS_TID_WIDTH         = 1,
   parameter C_AXIS_TDEST_WIDTH       = 1,
   parameter C_AXIS_TUSER_WIDTH       = 1,
   parameter C_SHOW_AXI_IDS           = 1,
   parameter C_SHOW_AXI_LEN           = 1,
   parameter C_SHOW_AXIS_TID          = 1,
   parameter C_SHOW_AXIS_TDEST        = 1,
   parameter C_SHOW_AXIS_TUSER        = 1,
   parameter C_EN_AXI_DEBUG              = 0
)
(
   input                                  clk,
   input                                  rst_n,

   input [C_MON_FIFO_DATA_WIDTH-1:0]      Data_In,
   input                                  Data_Valid,
   input [6:0]                            Flag_Enable_Reg,    
   input                                  Ext_Trig,
   input                                  Ext_Trig_Stop,
   input                                  Use_Ext_Trig_Log,
   output [C_LOG_WIDTH-1:0]               Log_Data,
   output                                 Log_En,
   input [2:0]                            Ext_Data_in,
   input                                  Ext_Data_Valid,
   input [2:0]                            Ext_Event_Flag_En,
   output reg [2:0]                       Ext_Event_Flags
    

);



//-------------------------------------------------------------------
// Parameter Declaration
//-------------------------------------------------------------------
localparam RST_ACTIVE = 1'b0;
localparam LOG_DATA_WIDTH = (C_AXI_PROTOCOL == "AXI4")?  
                            (4*C_AXI_ID_WIDTH + 16): (C_AXIS_TID_WIDTH +C_AXIS_TDEST_WIDTH + C_AXIS_TUSER_WIDTH);


//-------------------------------------------------------------------
// Signal Declaration
//-------------------------------------------------------------------

 reg                                Write_going_on;    
 reg                                Read_going_on;    
 reg [LOG_DATA_WIDTH-1:0]           Log_Data_int; 
 reg [LOG_DATA_WIDTH-1:0]           Log_Data_int1; 
 reg [C_FLAG_WIDTH-1:0]             Flags;  
 reg [C_FLAG_WIDTH-1:0]             Flags1;  
 reg                                Ext_Trig_log_en;
 reg [1:0]                          Ext_Triggers_Sync_d1;

 wire [1:0] Ext_Triggers = {Ext_Trig_Stop,Ext_Trig}; 
 wire [1:0] Ext_Triggers_Sync;
 wire Ext_Trig_Sync_Out;
 wire Ext_Trig_Stop_Sync_Out;
    wire [C_AXI_ADDR_WIDTH-1:0] AWADDR;
    wire [C_AXI_ADDR_WIDTH-1:0] ARADDR; 
 wire AWVALID,ARVALID;
wire Rd_Addr_Lat_Flag,Wr_Addr_Lat_Flag;
//-------------------------------------------------------------------
// Begin architecture
//-------------------------------------------------------------------

assign Log_En = Use_Ext_Trig_Log? ((|Flags) && Ext_Trig_log_en): (C_EN_AXI_DEBUG ? (| Flags1) : | Flags);  // Bit wise or of flags to generate fifo write enable

   // Synchronizing external trigger
   //-- Double Flop synchronization
    axi_perf_mon_v5_0_12_cdc_sync
    #(
       .c_cdc_type      (1             ),   
       .c_flop_input    (0             ),  
       .c_reset_state   (1             ),  
       .c_single_bit    (0             ),  
       .c_vector_width  (2             ),  
       .c_mtbf_stages   (4             )  
     )ext_trig_cdc_sync 
     (
       .prmry_aclk      (1'b0                ),
       .prmry_rst_n     (1'b1                ),
       .prmry_in        (1'b0                ),
       .prmry_vect_in   (Ext_Triggers        ),
       .scndry_aclk     (clk                 ),
       .scndry_rst_n    (rst_n               ),
       .prmry_ack       (                    ),
       .scndry_out      (                    ),
       .scndry_vect_out (Ext_Triggers_Sync   ) 
      );

   always @(posedge clk) begin
      if (rst_n == RST_ACTIVE) begin
          Ext_Triggers_Sync_d1 <= 0;
      end
      else begin
          Ext_Triggers_Sync_d1 <= Ext_Triggers_Sync;
      end
   end
  
   // Positive edge detection for the trigger start and stop 
   assign Ext_Trig_Sync_Out = Ext_Triggers_Sync[0] & ~(Ext_Triggers_Sync_d1[0]); 
   assign Ext_Trig_Stop_Sync_Out = Ext_Triggers_Sync[1] & ~(Ext_Triggers_Sync_d1[1]); 

   always @(posedge clk) begin
      if (rst_n == RST_ACTIVE) begin
          Ext_Trig_log_en <= 0;
      end
      else begin
          if(Use_Ext_Trig_Log == 1'b0 || Ext_Trig_Stop_Sync_Out == 1'b1) begin
            Ext_Trig_log_en <=  1'b0;
          end
          else if(Ext_Trig_Sync_Out == 1'b1) begin
            Ext_Trig_log_en <=  1'b1;
          end
          else begin
            Ext_Trig_log_en <= Ext_Trig_log_en;
          end
      end
   end

 
generate 
if (C_AXI_PROTOCOL == "AXI4") begin : GEN_FLAGS_AXI4
    //-- Decoding individual signals from output of fifo
    wire RREADY                           = Data_In[0];
    wire RVALID                           = Data_In[1];
    wire RLAST                            = Data_In[2];
    wire [1:0] RRESP                      = Data_In[4:3];
    wire [C_AXI_ID_WIDTH-1:0] RID         = Data_In[C_AXI_ID_WIDTH+4:5];

    wire ARREADY                          = Data_In[C_AXI_ID_WIDTH+5];
    assign ARVALID                        = Data_In[C_AXI_ID_WIDTH+6];
    wire [1:0] ARBURST                    = Data_In[C_AXI_ID_WIDTH+8:C_AXI_ID_WIDTH+7];
    wire [2:0] ARSIZE                     = Data_In[C_AXI_ID_WIDTH+11:C_AXI_ID_WIDTH+9];
    wire [7:0] ARLEN                      = Data_In[C_AXI_ID_WIDTH+19:C_AXI_ID_WIDTH+12];
    assign ARADDR    = Data_In[C_AXI_ADDR_WIDTH+C_AXI_ID_WIDTH+19:C_AXI_ID_WIDTH+20];
    wire [C_AXI_ID_WIDTH-1:0] ARID        = Data_In[(C_AXI_ADDR_WIDTH+(2*C_AXI_ID_WIDTH)+19):(C_AXI_ADDR_WIDTH+C_AXI_ID_WIDTH+20)];

    wire BREADY        = Data_In[(C_AXI_ADDR_WIDTH+(2*C_AXI_ID_WIDTH)+20)];
    wire BVALID        = Data_In[(C_AXI_ADDR_WIDTH+(2*C_AXI_ID_WIDTH)+21)];
    wire [1:0] BRESP   = Data_In[(C_AXI_ADDR_WIDTH+(2*C_AXI_ID_WIDTH)+23):(C_AXI_ADDR_WIDTH+(2*C_AXI_ID_WIDTH)+22)];
    wire [C_AXI_ID_WIDTH-1:0] BID = Data_In[(C_AXI_ADDR_WIDTH+(3*C_AXI_ID_WIDTH)+23):(C_AXI_ADDR_WIDTH+(2*C_AXI_ID_WIDTH)+24)];

    wire WREADY                           = Data_In[(C_AXI_ADDR_WIDTH+(3*C_AXI_ID_WIDTH)+24)];
    wire WVALID                           = Data_In[(C_AXI_ADDR_WIDTH+(3*C_AXI_ID_WIDTH)+25)];
    wire WLAST                            = Data_In[(C_AXI_ADDR_WIDTH+(3*C_AXI_ID_WIDTH)+26)];
    wire [C_AXI_DATA_WIDTH/8 -1 :0] WSTRB = 
    Data_In[(C_AXI_ADDR_WIDTH+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+26):(C_AXI_ADDR_WIDTH+(3*C_AXI_ID_WIDTH)+27)];

    wire AWREADY                          = Data_In[(C_AXI_ADDR_WIDTH+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+27)];
    assign AWVALID                        = Data_In[(C_AXI_ADDR_WIDTH+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+28)];
    wire [1:0] AWBURST = 
    Data_In[(C_AXI_ADDR_WIDTH+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+30):(C_AXI_ADDR_WIDTH+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+29)];
    wire [2:0] AWSIZE = 
    Data_In[(C_AXI_ADDR_WIDTH+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+33):(C_AXI_ADDR_WIDTH+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+31)];
    wire [7:0] AWLEN  = 
    Data_In[(C_AXI_ADDR_WIDTH+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+41):(C_AXI_ADDR_WIDTH+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+34)];
 assign AWADDR = Data_In[((2*C_AXI_ADDR_WIDTH)+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+41):(C_AXI_ADDR_WIDTH+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+42)];
    wire [C_AXI_ID_WIDTH-1:0] AWID   
    = Data_In[((2*C_AXI_ADDR_WIDTH)+(C_AXI_DATA_WIDTH/8)+(4*C_AXI_ID_WIDTH)+41):((2*C_AXI_ADDR_WIDTH)+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+42)];


    //-- Flags generation
    assign Wr_Addr_Lat_Flag = AWREADY && AWVALID && Data_Valid;
    wire First_Write_Flag = WVALID && WREADY && (!Write_going_on) && Data_Valid;
    wire Last_Write_Flag  = WLAST && WVALID && WREADY && Data_Valid;
    wire Response_Flag    = BVALID && BREADY && Data_Valid;
    assign Rd_Addr_Lat_Flag = ARREADY && ARVALID && Data_Valid;
    wire First_Read_Flag  = RVALID && RREADY && (!Read_going_on) && Data_Valid;
    wire Last_Read_Flag   = RLAST && RVALID && RREADY && Data_Valid;

    //-- Write_going_on for First_Write_Flag generation
    always @(posedge clk) begin 
       if (rst_n == RST_ACTIVE) begin
           Write_going_on <= 1'b0;
       end
       else begin
           if (Last_Write_Flag == 1'b1) begin
               Write_going_on <= 1'b0;
           end
           else if (First_Write_Flag == 1'b1)  begin
               Write_going_on <= 1'b1;
           end
           else begin
               Write_going_on <= Write_going_on;
           end
       end
    end 

    //-- Read_going_on for First_Read_Flag generation
    always @(posedge clk) begin 
       if (rst_n == RST_ACTIVE) begin
           Read_going_on <= 1'b0;
       end
       else begin
           if (Last_Read_Flag == 1'b1) begin
               Read_going_on <= 1'b0;
           end
           else if ((First_Read_Flag == 1'b1))  begin
               Read_going_on <= 1'b1;
           end
           else begin
               Read_going_on <= Read_going_on;
           end
       end
    end 

    //-- Flags
always @(posedge clk) begin
  if (rst_n == RST_ACTIVE) begin
    Flags <= 0;
  end
  else begin
    if (C_EN_AXI_DEBUG == 0 )
    Flags <= Flag_Enable_Reg & {Last_Read_Flag,First_Read_Flag,Rd_Addr_Lat_Flag,Response_Flag,Last_Write_Flag,First_Write_Flag,Wr_Addr_Lat_Flag};
    else
    Flags <= Flag_Enable_Reg & {Last_Read_Flag,1'b0,Rd_Addr_Lat_Flag,Response_Flag,1'b0,1'b0,Wr_Addr_Lat_Flag};
  end
end 

     
    //-- Data Log
    always @(posedge clk) begin
       if (rst_n == RST_ACTIVE) begin
           Log_Data_int <= 0;
       end
       else begin
           Log_Data_int <= {AWID, BID, ARID, RID, AWLEN, ARLEN};
       end
    end 

end
else if (C_AXI_PROTOCOL == "AXI4S") begin : GEN_FLAGS_AXI4S
  wire [C_AXIS_TUSER_WIDTH-1:0] TUSER     = Data_In[C_AXIS_TUSER_WIDTH-1:0];
  wire [C_AXIS_TDEST_WIDTH-1:0] TDEST     = Data_In[(C_AXIS_TDEST_WIDTH+C_AXIS_TUSER_WIDTH-1):(C_AXIS_TUSER_WIDTH)];
  wire [C_AXIS_TID_WIDTH-1:0] TID         = 
  Data_In[(C_AXIS_TID_WIDTH+C_AXIS_TDEST_WIDTH+C_AXIS_TUSER_WIDTH-1):(C_AXIS_TUSER_WIDTH+C_AXIS_TDEST_WIDTH)];
  wire  TLAST                             = Data_In[(C_AXIS_TID_WIDTH+C_AXIS_TDEST_WIDTH+C_AXIS_TUSER_WIDTH)];
  wire [(C_AXIS_TDATA_WIDTH/8)-1:0] TKEEP = 
  Data_In[((C_AXIS_TDATA_WIDTH/8)+C_AXIS_TID_WIDTH+C_AXIS_TDEST_WIDTH+C_AXIS_TUSER_WIDTH):(C_AXIS_TID_WIDTH+C_AXIS_TDEST_WIDTH+C_AXIS_TUSER_WIDTH+1)];
  wire [(C_AXIS_TDATA_WIDTH/8)-1:0] TSTRB = 
  Data_In[((2*(C_AXIS_TDATA_WIDTH/8))+C_AXIS_TID_WIDTH+C_AXIS_TDEST_WIDTH+C_AXIS_TUSER_WIDTH):((C_AXIS_TDATA_WIDTH/8)+C_AXIS_TID_WIDTH+C_AXIS_TDEST_WIDTH+C_AXIS_TUSER_WIDTH+1)];
  wire  TREADY   = Data_In[((2*(C_AXIS_TDATA_WIDTH/8))+C_AXIS_TID_WIDTH+C_AXIS_TDEST_WIDTH+C_AXIS_TUSER_WIDTH+1)];
  wire  TVALID   = Data_In[((2*(C_AXIS_TDATA_WIDTH/8))+C_AXIS_TID_WIDTH+C_AXIS_TDEST_WIDTH+C_AXIS_TUSER_WIDTH+2)];

  //-- Flags generation
  wire First_Write_Flag = TVALID && TREADY && (!Write_going_on) && Data_Valid;
  wire Last_Write_Flag  = TLAST && TVALID && TREADY && Data_Valid;

    //-- Write_going_on for First_Write_Flag generation
    always @(posedge clk) begin 
       if (rst_n == RST_ACTIVE) begin
           Write_going_on <= 1'b0;
       end
       else begin
           if (Last_Write_Flag == 1'b1) begin
               Write_going_on <= 1'b0;
           end
           else if ((First_Write_Flag == 1'b1))  begin
               Write_going_on <= 1'b1;
           end
           else begin
               Write_going_on <= Write_going_on;
           end
       end
    end 

    //-- Flags
    always @(posedge clk) begin
       if (rst_n == RST_ACTIVE) begin
           Flags <= 0;
       end
       else begin
           Flags <= {(Flag_Enable_Reg[2] && Last_Write_Flag), (Flag_Enable_Reg[1] && First_Write_Flag)} ;
       end
    end 

    //-- Data Log
    always @(posedge clk) begin
       if (rst_n == RST_ACTIVE) begin
           Log_Data_int <= 0;
       end
       else begin
           Log_Data_int <= {TID, TDEST, TUSER};
       end
    end 

end
endgenerate

 
reg [C_AXI_ADDR_WIDTH-1:0] AWADDR_d, ARADDR_d;
  reg [C_AXI_ADDR_WIDTH-1:0] AWADDR_d2, ARADDR_d2;
  wire [C_AXI_ADDR_WIDTH-1:0] AWRADDR, ARRADDR;
   
  generate if (C_EN_AXI_DEBUG == 1 && C_AXI_PROTOCOL == "AXI4") begin : GEN_AXI_DDR_DEBUG
  
   always @ (posedge clk)
     if (rst_n == RST_ACTIVE)
     begin
	   ARADDR_d2 <= {C_AXI_ADDR_WIDTH{1'b0}};
	   ARADDR_d <= {C_AXI_ADDR_WIDTH{1'b0}};
	   AWADDR_d2 <= {C_AXI_ADDR_WIDTH{1'b0}};
	   AWADDR_d <= {C_AXI_ADDR_WIDTH{1'b0}};
     end
     else begin
   	Flags1 <= Flags;
      Log_Data_int1 <= Log_Data_int;
      if (Wr_Addr_Lat_Flag) begin
      AWADDR_d <= AWADDR;
      end
      if (Rd_Addr_Lat_Flag) begin
    	ARADDR_d  <= ARADDR;
      end
      if(Flags[3] == 1'b1 && Flags[0] == 1'b0) begin
	   AWADDR_d2 <= AWRADDR;
      end
	   else begin
      	//if (Wr_Addr_Lat_Flag)
  	       AWADDR_d2 <= AWADDR_d;
      end
	   if(Flags[6] == 1'b1 && Flags[4] == 1'b0) begin
           ARADDR_d2 <= ARRADDR;
      end
	   else begin
      	//if (Rd_Addr_Lat_Flag)
           ARADDR_d2 <= ARADDR_d;
      end
     end
   end
      
   axi_perf_mon_v5_0_12_sync_fifo 
     #(
        .WIDTH      (C_AXI_ADDR_WIDTH),
        .DEPTH_LOG2 (5)
     ) RESP_FIFO
     (
       .rst_n    (rst_n),
       .clk      (clk),
       .wren     (Wr_Addr_Lat_Flag),
       .rden     (Response_Flag   ),
       .din      (AWADDR ),
       .dout     (AWRADDR ),
       .full     (       ),
       .empty    (   )
     );

   axi_perf_mon_v5_0_12_sync_fifo 
     #(
        .WIDTH      (C_AXI_ADDR_WIDTH),
        .DEPTH_LOG2 (5)
     ) RRESP_FIFO
     (
       .rst_n    (rst_n),
       .clk      (clk),
       .wren     (Rd_Addr_Lat_Flag),
       .rden     (Last_Read_Flag   ),
       .din      (ARADDR ),
       .dout     (ARRADDR ),
       .full     (       ),
       .empty    (   )
     );

endgenerate

// Assigning log data out based on the control parameters
// This assignment is to reduce the log data width

generate 
  //  Flags <= Flag_Enable_Reg & {Last_Read_Flag,First_Read_Flag,Rd_Addr_Lat_Flag,Response_Flag,Last_Write_Flag,First_Write_Flag,Wr_Addr_Lat_Flag};

// for AXI tranx debug purpose   
if (C_EN_AXI_DEBUG == 1 ) begin : GEN_LOGS_DEBUG
   assign Log_Data = {AWADDR_d2,Log_Data_int1[15:8],Flags1[0],Flags1[3],ARADDR_d2,Log_Data_int1[7:0],Flags1[4],Flags1[6]};
end
// for performance trace purpose 
else if (C_AXI_PROTOCOL == "AXI4" && C_SHOW_AXI_IDS == 1 && C_SHOW_AXI_LEN == 1) begin : GEN_LOGS_AXI4
   assign Log_Data = {Log_Data_int,Flags};
end
else if(C_AXI_PROTOCOL == "AXI4" && C_SHOW_AXI_IDS == 1 && C_SHOW_AXI_LEN == 0) begin :GEN_SHOW_IDS
   assign Log_Data = {Log_Data_int[LOG_DATA_WIDTH-1:16],Flags};
end
else if(C_AXI_PROTOCOL == "AXI4" && C_SHOW_AXI_IDS == 0 && C_SHOW_AXI_LEN == 1) begin :GEN_SHOW_LEN
   assign Log_Data = {Log_Data_int[15:0],Flags};
end
else if(C_AXI_PROTOCOL == "AXI4" && C_SHOW_AXI_IDS == 0 && C_SHOW_AXI_LEN == 0) begin :GEN_NO_LOG_DATA
   assign Log_Data = Flags;
end
else if(C_AXI_PROTOCOL == "AXI4S" && C_SHOW_AXIS_TID == 1 && C_SHOW_AXIS_TDEST == 1 && C_SHOW_AXIS_TUSER == 1) 
  begin : GEN_LOGS_AXI4S
   assign Log_Data = {Log_Data_int,Flags};
end
else if(C_AXI_PROTOCOL == "AXI4S" && C_SHOW_AXIS_TID == 1 && C_SHOW_AXIS_TDEST == 1 && C_SHOW_AXIS_TUSER == 0) 
   begin : GEN_SHOW_IDS_DEST 
   assign Log_Data = {Log_Data_int[LOG_DATA_WIDTH-1:C_AXIS_TUSER_WIDTH],Flags};
end
else if(C_AXI_PROTOCOL == "AXI4S" && C_SHOW_AXIS_TID == 1 && C_SHOW_AXIS_TDEST == 0 && C_SHOW_AXIS_TUSER == 0)
   begin : GEN_SHOW_TID
   assign Log_Data = {Log_Data_int[LOG_DATA_WIDTH-1:(C_AXIS_TDEST_WIDTH+C_AXIS_TUSER_WIDTH)],Flags};
end
else if(C_AXI_PROTOCOL == "AXI4S" && C_SHOW_AXIS_TID == 0 && C_SHOW_AXIS_TDEST == 1 && C_SHOW_AXIS_TUSER == 1) 
   begin : GEN_SHOW_TDEST_TUSER
   assign Log_Data = {Log_Data_int[(LOG_DATA_WIDTH-C_AXIS_TID_WIDTH-1):0],Flags};
end
else if(C_AXI_PROTOCOL == "AXI4S" && C_SHOW_AXIS_TID == 0 && C_SHOW_AXIS_TDEST == 1 && C_SHOW_AXIS_TUSER == 0) 
   begin : GEN_SHOW_TDEST
   assign Log_Data = {Log_Data_int[(LOG_DATA_WIDTH-C_AXIS_TID_WIDTH-1):C_AXIS_TUSER_WIDTH],Flags};
end
else if(C_AXI_PROTOCOL == "AXI4S" && C_SHOW_AXIS_TID == 0 && C_SHOW_AXIS_TDEST == 0 && C_SHOW_AXIS_TUSER == 1) 
   begin : GEN_SHOW_TUSER
   assign Log_Data = {Log_Data_int[(C_AXIS_TUSER_WIDTH-1):0],Flags};
end
else if(C_AXI_PROTOCOL == "AXI4S" && C_SHOW_AXIS_TID == 0 && C_SHOW_AXIS_TDEST == 0 && C_SHOW_AXIS_TUSER == 0) 
   begin :GEN_SHOW_NO_AXI4S_LOG 
   assign Log_Data = Flags;
end 
else
   begin:GEN_NO_LOGS
   assign Log_Data = 0;
end

endgenerate

 // External event flags generation
 wire Ext_Event_Start_Flag = Ext_Data_in[2] && Ext_Data_Valid; 
 wire Ext_Event_Stop_Flag =  Ext_Data_in[1] && Ext_Data_Valid;
 wire Ext_Event_Flag  =  Ext_Data_in[0] && Ext_Data_Valid;


  // External event flags
always @(posedge clk) begin
 if (rst_n == RST_ACTIVE) begin
    Ext_Event_Flags <= 0;
 end
 else begin
   Ext_Event_Flags <= {(Ext_Event_Flag_En[2] && Ext_Event_Start_Flag),
                       (Ext_Event_Flag_En[1] && Ext_Event_Stop_Flag), (Ext_Event_Flag_En[0] && Ext_Event_Flag)} ;
 end
end 

endmodule







//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename   :    axi_perf_mon_v5_0_12_glbl_clk_cnt.v
// Version    :    v5.0
// Description:    Free running global clock counter starts running
//                 when global clock count enable bit is set in control register 
//                 The width 32/64 is configurable 
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
// axi_perf_mon.v
//      \-- axi_perf_mon_v5_0_12_glbl_clk_cnt.v
//-----------------------------------------------------------------------------
// Author:      Kalpanath
// History:
// Kalpanath 07/25/2012      First Version
// ^^^^^^
//-----------------------------------------------------------------------------
`timescale 1ns/1ps

module axi_perf_mon_v5_0_12_glbl_clk_cnt 
#(
   parameter                          C_FAMILY             = "nofamily",
   parameter                          C_GLOBAL_COUNT_WIDTH = 32,
   parameter                          COUNTER_LOAD_VALUE   = 32'h00000000 
)
(
   input                                  clk,
   input                                  rst_n,

   input                                  Global_Clk_Cnt_En,   
   input                                  Global_Clk_Cnt_Reset,   
   output [(C_GLOBAL_COUNT_WIDTH - 1):0]  Global_Clk_Cnt,  
   output                                 Global_Clk_Cnt_OF   

);



//-------------------------------------------------------------------
// Parameter Declaration
//-------------------------------------------------------------------
localparam RST_ACTIVE = 1'b0;
localparam ALL_ZEROES = {C_GLOBAL_COUNT_WIDTH{1'b0}};

//-------------------------------------------------------------------
// Begin architecture
//-------------------------------------------------------------------

//-- Counter Instantiation
axi_perf_mon_v5_0_12_counter 
  #(
       .C_FAMILY             (C_FAMILY),
       .C_NUM_BITS           (C_GLOBAL_COUNT_WIDTH),
       .COUNTER_LOAD_VALUE   (COUNTER_LOAD_VALUE) 
   ) counter_inst 
   (
       .clk                  (clk),
       .rst_n                (rst_n),
       .Load_In              (ALL_ZEROES),
       .Count_Enable         (Global_Clk_Cnt_En),
       .Count_Load           (Global_Clk_Cnt_Reset),
       .Count_Down           (1'b0),
       .Count_Out            (Global_Clk_Cnt),
       .Carry_Out            (Global_Clk_Cnt_OF)
   );


endmodule





//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename   :  axi_perf_mon_v5_0_12_interrupt_module.v
// Version    :  v5.0
// Description:  AXI Performance monitor interrupt module generates
//               interrupt to processor based on different counter/fifo
//               overflow conditions
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
// axi_perf_mon.v
//      \-- axi_perf_mon_v5_0_12_interrupt_module.v
//-----------------------------------------------------------------------------
// Author:      Kalpanath
// History:
// Kalpanath 07/25/2012      First Version
// ^^^^^^
//----------------------------------------------------------------------------- 
`timescale 1ns/1ps

module axi_perf_mon_v5_0_12_interrupt_module 
#(
   parameter                          C_FAMILY          = "nofamily",
   parameter                          C_NUM_INTR_INPUTS = 10
)
(
   input                                  clk,
   input                                  rst_n,
   input      [(C_NUM_INTR_INPUTS - 1):0] Intr,
   input                                  Interrupt_Enable,

   input                                  IER_Wr_En,
   input                                  ISR_Wr_En,
   input      [(C_NUM_INTR_INPUTS - 1):0] Wr_Data,

   output reg [(C_NUM_INTR_INPUTS - 1):0] IER, 
   output reg [(C_NUM_INTR_INPUTS - 1):0] ISR, 

   output reg                             Interrupt


);

//-------------------------------------------------------------------
// Parameter Declaration
//-------------------------------------------------------------------
localparam RST_ACTIVE = 1'b0;

//-------------------------------------------------------------------
// Signal Declaration
//-------------------------------------------------------------------

wire                             irq_gen;  


//-------------------------------------------------------------------
// Begin architecture
//-------------------------------------------------------------------

always @(posedge clk) begin
   if (rst_n == RST_ACTIVE) begin
       IER <= 0;
   end
   else begin
       if (IER_Wr_En == 1'b1) begin
           IER <= Wr_Data;
       end
       else begin
           IER <= IER;
       end
   end
end 

genvar i;
generate
for (i=0; i < C_NUM_INTR_INPUTS ; i=i+1) begin : GEN_ISR_REG
    always @(posedge clk) begin
       if (rst_n == RST_ACTIVE) begin
           ISR[i] <= 1'b0;
       end
       else begin
           if ((ISR_Wr_En == 1'b1) && (Wr_Data[i] == 1'b1)) begin
               ISR[i] <= 1'b0;
           end
           else if ((Intr[i] == 1'b1)) begin
               ISR[i] <= 1'b1;
           end
           else begin
               ISR[i] <= ISR[i];
           end
       end
    end 
end    
endgenerate


assign irq_gen = | (ISR & IER);


always @(posedge clk) begin
   if (rst_n == RST_ACTIVE) begin
       Interrupt <= 1'b0;
   end
   else begin
       Interrupt <= irq_gen && Interrupt_Enable;
   end
end 

endmodule








//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename   :  axi_perf_mon_v5_0_12_intr_sync.v
// Version    :  v5.0
// Description:  Interrupt synchronization module. Interrupt generated
//               at core clock are synchronized with AXI4-Lite clock
//               pulse synchronization method is used for interrupt
//               synchronization
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
// axi_perf_mon.v
//    \-- axi_perf_mon_v5_0_12_intr_sync.v
//-----------------------------------------------------------------------------
// Author:      Kalpanath
// History:
// Kalpanath 07/25/2012      First Version
// ^^^^^^
//----------------------------------------------------------------------------- 
`timescale 1ns/1ps

module axi_perf_mon_v5_0_12_intr_sync 
#(
   parameter                          C_FAMILY    = "nofamily",
   parameter                          C_DWIDTH    = 32
)
(
   input                                  clk_1,
   input                                  rst_1_n,
   input  [(C_DWIDTH - 1):0]              DATA_IN, 
   input                                  clk_2,
   input                                  rst_2_n,
   output [(C_DWIDTH - 1):0]              SYNC_DATA_OUT 
);

//-------------------------------------------------------------------
// Parameter Declaration
//-------------------------------------------------------------------
localparam RST_ACTIVE = 1'b0;


//-------------------------------------------------------------------
// Begin architecture
//-------------------------------------------------------------------

genvar i;
generate
for (i=0; i<C_DWIDTH; i=i+1) begin : GEN_SYNC
    axi_perf_mon_v5_0_12_cdc_sync
    #(
       .c_cdc_type      (0    ),   
       .c_flop_input    (0    ),  
       .c_reset_state   (1    ),  
       .c_single_bit    (1    ),  
       .c_vector_width  (1    ),  
       .c_mtbf_stages   (4    )  
     )cdc_sync_inst 
     (
       .prmry_aclk      (clk_1             ),
       .prmry_rst_n     (rst_1_n           ),
       .prmry_in        (DATA_IN[i]        ),
       .prmry_vect_in   (1'b0              ),
       .scndry_aclk     (clk_2             ),
       .scndry_rst_n    (rst_2_n           ),
       .prmry_ack       (                  ),
       .scndry_out      (SYNC_DATA_OUT[i]  ),
       .scndry_vect_out (                  ) 
      );
end
endgenerate    

endmodule






//-------------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename   :     axi_perf_mon_v5_0_12_metric_calc.v 
// Version    :     v5.0
// Description:      Metric calculator module generates different metric count
//                   enables which will be used in metric counter 
// Verilog-Standard:  Verilog 2001 
//-----------------------------------------------------------------------------
// Structure:
//  axi_perf_mon.v
//      \-- axi_perf_mon_v5_0_12_metric_calc.v
//-----------------------------------------------------------------------------
// Author :  NLR  
// History: 
// NLR       07/25/2012      First Version
// ^^^^^^
// NLR       10/10/2012      Separated the external event calculation from
// ^^^^^^                    this module
//
// NLR       03/20/2013      Added external trigger stop to halt the metric
// ^^^^^^                    counters
//                           Added latency calculation by given ID
//
// NLR       10/02/2013      Added ID Filtering/Masking/ignoring support for all metrics
// ^^^^^^                    Latency start and end point selection 
// Kartheek  09/08/2014      Write latency logic updated , write before
//                           address support enabled
// Kartheek  11/27/2014      32 it ID filtering support added Read latency logic updated
//
//-----------------------------------------------------------------------------
`timescale 1ns/1ps
(* DowngradeIPIdentifiedWarnings="yes" *)

module axi_perf_mon_v5_0_12_metric_calc 
  #(
    parameter C_AXIID                  = 4,
    parameter C_AXIADDR                = 32,
    parameter C_AXIDATA                = 32,
    parameter C_AXISDATA               = 32,
    parameter C_AXISID                 = 4,
    parameter C_AXISDEST               = 1,
    parameter C_AXISUSER               = 1,
    parameter C_OUTSTAND_DEPTH         = 1,
    parameter C_METRIC_COUNT_WIDTH     = 32,
    parameter C_MON_FIFO_WIDTH         = 126,
    parameter C_AXI_PROTOCOL           = "AXI4",
    parameter C_AXI_SUB_PROTOCOL       = "AXI4LITE"
    )
   (
    //AXI Signals
    input                                 clk,        
    input                                 rst_n,  
    input [C_MON_FIFO_WIDTH -1:0]         Data_In,
    input                                 Data_Valid,
    // Register inputs
    input                                 Metrics_Cnt_En,
    input                                 Metrics_Cnt_Reset,
    // External Trigger inputs
    input                                 Use_Ext_Trig,
    input                                 Ext_Trig,
    input                                 Ext_Trig_Stop,
    // Latency ID's from Registers
    input  [15:0]                         Latency_WID,
    input  [15:0]                         Latency_RID,
    input  [15:0]                         WID_Mask,
    input  [15:0]                         RID_Mask,
    input                                 En_Id_Based,
    input                                 Wr_Lat_Start,  //1 Address Issue 0 Address acceptance
    input                                 Wr_Lat_End,    //1 First write   0 Last write  
    input                                 Rd_Lat_Start,  //1 Address Issue 0 Address acceptance 
    input                                 Rd_Lat_End,    //1 First Read    0 Last Read
    /// Metric outputs
    output reg                            Wtrans_Cnt_En,
    output reg                            Rtrans_Cnt_En,
    output     [C_METRIC_COUNT_WIDTH-1:0] Write_Byte_Cnt,
    output reg [C_METRIC_COUNT_WIDTH-1:0] Read_Byte_Cnt,
    output reg                            Read_Byte_Cnt_En,
    output                                Write_Beat_Cnt_En,
    output reg                            Read_Beat_Cnt_En,
    output     [C_METRIC_COUNT_WIDTH-1:0] Write_Beat_Cnt,
    output     [C_METRIC_COUNT_WIDTH-1:0] Read_Latency,
    output     [C_METRIC_COUNT_WIDTH-1:0] Write_Latency,
    output                                Read_Latency_En,
    output                                Write_Latency_En,
    output                                Slv_Wr_Idle_Cnt_En,        
    output     [C_METRIC_COUNT_WIDTH-1:0] Slv_Wr_Idle_Cnt,        
    output reg                            Mst_Rd_Idle_Cnt_En,        
    output reg                            Num_BValids_En,       
    output                                Num_WLasts_En,             
    output reg                            Num_RLasts_En,      
    //AXI Streaming metrics
    output reg                            S_Transfer_Cnt_En,
    output reg                            S_Packet_Cnt_En,  
    output reg [C_METRIC_COUNT_WIDTH-1:0] S_Data_Byte_Cnt,
    output reg [C_METRIC_COUNT_WIDTH-1:0] S_Position_Byte_Cnt,
    output reg [C_METRIC_COUNT_WIDTH-1:0] S_Null_Byte_Cnt,
    output reg                            S_Slv_Idle_Cnt_En,
    output reg                            S_Mst_Idle_Cnt_En,
    output     [C_METRIC_COUNT_WIDTH-1:0] Max_Write_Latency,                   
    output     [C_METRIC_COUNT_WIDTH-1:0] Min_Write_Latency,                   
    output     [C_METRIC_COUNT_WIDTH-1:0] Max_Read_Latency,                   
    output     [C_METRIC_COUNT_WIDTH-1:0] Min_Read_Latency                   
    );

    //Parameter Declarations
    localparam RST_ACTIVE              = 0; 

    //Register declarations
    reg Write_going_on;
    reg Write_iss_going_on;
    reg Read_going_on;

    reg Ext_Trig_Metric_en;
    reg [1:0] Ext_Triggers_Sync_d1;

    //wire declaration

    wire                   RREADY;
    wire                   RVALID;
    wire                   RLAST ;
    wire [1:0]             RRESP;
    wire [C_AXIID-1:0]     RID;
    wire                   ARREADY;
    wire                   ARVALID;
    wire [1:0]             ARBURST;
    wire [2:0]             ARSIZE;
    wire [7:0]             F1AR_Wr_Data;
    wire [7:0]             F1AR_Rd_Data;
    wire [7:0]             F1_ARSIZE;
    wire                   F1AR_Rd_En;
    wire                   F1AR_Wr_En;
    wire [7:0]             ARLEN;
    wire [C_AXIADDR-1:0]   ARADDR;
    wire [C_AXIID-1:0]     ARID;
    wire                   BREADY;
    wire                   BVALID;
    wire [1:0]             BRESP;
    wire [C_AXIID-1:0]     BID;
    wire                   WREADY;
    wire                   WVALID;
    wire                   WLAST;
    wire [C_AXIDATA/8-1:0] WSTRB;
    wire                   AWREADY;
    wire                   AWVALID;
    wire [1:0]             AWBURST;
    wire [2:0]             AWSIZE;
    wire [7:0]             AWLEN;
    wire [C_AXIADDR-1:0]   AWADDR;
    wire [C_AXIID-1:0]     AWID; 

    wire [C_AXISUSER-1:0] TUSER;
    wire [C_AXISDEST-1:0] TDEST;
    wire [C_AXISID-1:0] TID  ;
    wire TLAST;
    wire [C_AXISDATA/8-1:0] TKEEP;
    wire [C_AXISDATA/8-1:0] TSTRB;
    wire TREADY;
    wire TVALID;


    wire [C_METRIC_COUNT_WIDTH-1:0] zeros = 0;
    wire [C_METRIC_COUNT_WIDTH-1:0] wr_byte_cnt; 
    reg  [C_METRIC_COUNT_WIDTH-1:0] wr_byte_cnt_reg; 

    wire [C_METRIC_COUNT_WIDTH-1:0] Write_Latency_Cnt_Out;
    reg  [C_METRIC_COUNT_WIDTH-1:0] Write_Latency_Cnt_Out_D1;
    reg  [C_METRIC_COUNT_WIDTH-1:0] Write_Latency_Cnt_Out_D2;
    wire [C_METRIC_COUNT_WIDTH-1:0] Read_Latency_Cnt_Out;
    reg [C_METRIC_COUNT_WIDTH:0] Read_Latency_Cnt_Out_D1;
    reg [C_METRIC_COUNT_WIDTH:0] Read_Latency_Cnt_Out_D2;

    // read and write latency counter overflow signals
    wire Write_Latency_Cnt_Ovf;
    wire Read_Latency_Cnt_Ovf;

    wire wr_latency_start;
    wire wr_latency_end;
    wire rd_latency_start;
    wire rd_latency_end;
    wire First_Write_sel;
    wire Last_Write_sel;
    wire First_Read_sel;
    wire Last_Read_sel;

    // read and write latency counter enable signals 
    reg  Read_Latency_En_Int;
    reg  Write_Latency_En_Int;

    // Write Latency FIFO control signals
    //reg  Wr_Latency_Fifo_Wr_En;
    reg  Wr_Latency_Fifo_Rd_En;
    reg  Wr_Latency_Fifo_Rd_En_D1;
    reg  Wr_Latency_Fifo_Rd_En_D2;

    // Read Latency FIFO control signals
    reg  Rd_Latency_Fifo_Wr_En;
    reg  Rd_Latency_Fifo_Rd_En;
    reg  Rd_Latency_Fifo_Rd_En_D1;
    reg  Rd_Latency_Fifo_Rd_En_D2;

    // Write and read latency signals
    reg [C_METRIC_COUNT_WIDTH-1:0] Write_Latency_Int;
    reg [C_METRIC_COUNT_WIDTH-1:0] Read_Latency_Int;

    // read and write latency counter data signals
    //reg [C_METRIC_COUNT_WIDTH-1:0] Wr_Latency_Fifo_Wr_Data;
    reg [C_METRIC_COUNT_WIDTH:0] Rd_Latency_Fifo_Wr_Data;
    reg [C_METRIC_COUNT_WIDTH-1:0] Max_Write_Latency_Int;
    reg [C_METRIC_COUNT_WIDTH-1:0] Min_Write_Latency_Int;
    reg [C_METRIC_COUNT_WIDTH-1:0] Max_Read_Latency_Int;
    reg [C_METRIC_COUNT_WIDTH-1:0] Min_Read_Latency_Int;
    reg Write_Latency_One;            
    reg Write_Latency_One_D1;            
    reg Read_Latency_One;            
    reg Read_Latency_One_D1;  
    reg [4:0]      Wr_Latency_Occupancy;
    //reg [4:0]      Rd_Latency_Occupancy;
    reg  Write_Beat_reg;
    reg  Wr_Idle_reg;
    reg  Last_Write_reg;
    reg  First_Write_reg;
    reg  Last_Read_reg;
    reg  First_Read_reg;
    reg  rid_match_reg;

    wire [C_AXIID-1:0] AWID_COMP;
    wire [C_AXIID-1:0] ARID_COMP;
   // wire Wr_Latency_Fifo_Rd_En_out;
    wire Rd_Latency_Fifo_Rd_En_out;
      
   // wire [C_METRIC_COUNT_WIDTH-1:0] Wr_Latency_Fifo_Rd_Data;
    reg [C_METRIC_COUNT_WIDTH-1:0] Wr_Latency_Fifo_Rd_Data_D1;
    wire [C_METRIC_COUNT_WIDTH:0] Rd_Latency_Fifo_Rd_Data;
    reg [C_METRIC_COUNT_WIDTH:0] Rd_Latency_Fifo_Rd_Data_D1;
    //wire Wr_Latency_Fifo_Full; 
    //wire Wr_Latency_Fifo_Empty; 
    wire Rd_Latency_Fifo_Full; 
    wire Rd_Latency_Fifo_Empty; 
    wire Wr_Latcnt_rst_n; 
    wire Rd_Latcnt_rst_n; 
    wire [C_METRIC_COUNT_WIDTH-1:0] data_byte_cnt;
    wire [C_METRIC_COUNT_WIDTH-1:0] pos_byte_cnt;
    wire [C_METRIC_COUNT_WIDTH-1:0] null_byte_cnt;
    wire [C_METRIC_COUNT_WIDTH-1:0] ONE = 1;
    wire [C_METRIC_COUNT_WIDTH-1:0] TWO = {{(C_METRIC_COUNT_WIDTH-2){1'b0}},2'b10};
    wire [C_METRIC_COUNT_WIDTH-1:0] ALL_ONES = {C_METRIC_COUNT_WIDTH{1'b1}} ;
    wire [1:0] Ext_Triggers = {Ext_Trig_Stop,Ext_Trig}; 
    wire [1:0] Ext_Triggers_Sync;
    wire Ext_Trig_Sync_Out;
    wire Ext_Trig_Stop_Sync_Out;
    //reg Wr_Id_Fifo_Wr_En;
   // reg Wr_Id_Fifo_Rd_En;
   // reg Wr_Id_Fifo_Wr_Data;
   // wire Wr_Id_Fifo_Rd_Data;
   // wire Wr_Id_Fifo_Empty;
    wire wid_match;
   // reg wid_match_int;
   // reg wid_match_latch;
    //reg Write_access_done;
    reg Wr_Add_Issue;
    reg Wr_Valid_Issue;
    reg No_Wr_Ready;
    reg No_Write_Ready;
    reg [C_AXIID-1:0] AWID_reg;
    //reg Read_access_done;
    reg Rd_Add_Issue;
    reg No_Rd_Ready;
    reg [C_AXIID-1:0] ARID_reg;
    //wire Write_Latency_Ovf;
    //reg Read_Latency_Ovf;
    wire Wr_cnt_ld;
    wire Rd_cnt_ld;

    wire rst_int_n1 = rst_n &  ~(Metrics_Cnt_Reset);
    reg rst_int_n;
    always @(posedge clk) begin
      rst_int_n <= rst_int_n1;
    end
    // Function to find number of '1' in a n bit strobe vector 

    function [C_METRIC_COUNT_WIDTH-1:0] count;
    input [C_AXIDATA/8-1:0] strobe; //Strobe 
    //input valid;                    //Data valid
    integer j;
    reg [C_METRIC_COUNT_WIDTH-1:0] count_i;
    begin
      count_i = 0;
      for(j=0;j<=C_AXIDATA/8-1;j=j+1) begin
        //if(valid == 1) begin
          count_i = count_i+strobe[j]; 
        //end
      end
      count = count_i;
    end
    endfunction

   // Function to find number of '1' in 4-bit strobe

function [2:0] count_4;
    input [3:0] strobe;            //Strobe
    begin
    case (strobe) 
            4'b0001, 4'b0010, 4'b0100, 4'b1000:
              count_4 = 3'b001;
            4'b0011, 4'b0110, 4'b1100, 4'b1001, 4'b0101, 4'b1010 :
              count_4 = 3'b010;
            4'b0111, 4'b1011, 4'b1101, 4'b1110 :
              count_4 = 3'b011;
            4'b1111 :
              count_4 = 3'b100;
            default :
              count_4 = 3'b000;
    endcase
    end
    endfunction
    // Function to find number of '1' in 8-bit strobe
    function [3:0] count_8;
    input [7:0] strobe;      //Strobe
    //input valid;             //Data valid
    integer j;
    reg [2:0] count_1;
    reg [2:0] count_2;
    begin
      count_1 = count_4(strobe[3:0]);
      count_2 = count_4(strobe[7:4]);
      count_8 = count_1+count_2;
    end
    endfunction

   // Function to find number of '1' in 16-bit strobe
    function [4:0] count_16; 
    input [15:0] strobe;   //Strobe
    //input valid;           //Data valid
    integer j;
    reg [3:0] count_1;
    reg [3:0] count_2;
    begin
      count_1 = count_8(strobe[7:0]);
      count_2 = count_8(strobe[15:8]);
      count_16 = count_1+count_2;
    end
    endfunction

   // Function to find number of '1' in 32-bit strobe
    function [5:0] count_32;
    input [31:0] strobe;   //Strobe
    //input valid;           //Data valid
    integer j;
    reg [4:0] count_1;
    reg [4:0] count_2;
    begin
      count_1 = count_16(strobe[15:0]);
      count_2 = count_16(strobe[31:16]);
      count_32 = count_1+count_2;
    end
    endfunction

   // Function to find number of '1' in 64-bit strobe
    function [6:0] count_64;
    input [63:0] strobe;   //Strobe
    //input valid;           //Data valid
    integer j;
    reg [5:0] count_1;
    reg [5:0] count_2;
    begin
      count_1  = count_32(strobe[31:0]);
      count_2  = count_32(strobe[63:32]);
      count_64 = count_1+count_2;
    end
    endfunction

   // Function to find number of '1' in 128-bit strobe
    function [7:0] count_128;
    input [127:0] strobe;  //Strobe
    //input valid;           //Data valid
    reg [6:0] count_1;  
    reg [6:0] count_2;
    begin
      count_1  = count_64(strobe[63:0]);
      count_2  = count_64(strobe[127:64]);
      count_128 = count_1+count_2;
    end
    endfunction

  // Function to find ID match based on filtering/masking 
  // If mask bit is '1' ignores the corresponding bit for filtering
  function id_matched;
    input [C_AXIID-1:0] id_mask;     //ID mask
    input [C_AXIID-1:0] id_filter;   //ID filter
    input [C_AXIID-1:0] id;          //Actual ID
    integer j;
    reg [C_AXIID-1:0] id_match;
    begin
      id_match = 0;
      for(j=0;j<C_AXIID;j=j+1) begin
         id_match[j] = (id_mask[j] | (id_filter[j] ^~ id[j]));
      end
      id_matched = &(id_match);
  end
  endfunction

 // Synchronizing external trigger
 //--Level synchronization
    axi_perf_mon_v5_0_12_cdc_sync
    #(
       .c_cdc_type      (1             ),   
       .c_flop_input    (0             ),  
       .c_reset_state   (1             ),  
       .c_single_bit    (0             ),  
       .c_vector_width  (2             ),  
       .c_mtbf_stages   (4             )  
     )ext_trig_cdc_sync 
     (
       .prmry_aclk      (1'b0                ), //Not used as there is no setting for c_flop_input 
       .prmry_rst_n     (1'b1                ),
       .prmry_in        (1'b0                ),
       .prmry_vect_in   (Ext_Triggers        ),
       .scndry_aclk     (clk                 ),
       .scndry_rst_n    (rst_int_n           ),
       .prmry_ack       (                    ),
       .scndry_out      (                    ),
       .scndry_vect_out (Ext_Triggers_Sync   ) 
      );

   always @(posedge clk) begin
      if (rst_int_n == RST_ACTIVE) begin
          Ext_Triggers_Sync_d1 <= 0;
      end
      else begin
          Ext_Triggers_Sync_d1 <= Ext_Triggers_Sync;
      end
   end
  
   // Positive edge detection for the trigger start and stop 
   assign Ext_Trig_Sync_Out = Ext_Triggers_Sync[0] & ~(Ext_Triggers_Sync_d1[0]); 
   assign Ext_Trig_Stop_Sync_Out = Ext_Triggers_Sync[1] & ~(Ext_Triggers_Sync_d1[1]); 

   always @(posedge clk) begin
      if (rst_int_n == RST_ACTIVE) begin
          Ext_Trig_Metric_en <= 0;
      end
      else begin
          if(Use_Ext_Trig == 1'b0 || Ext_Trig_Stop_Sync_Out == 1'b1) begin
            Ext_Trig_Metric_en <=  1'b0;
          end
          else if(Ext_Trig_Sync_Out == 1'b1) begin
            Ext_Trig_Metric_en <=  1'b1;
          end
          else begin
            Ext_Trig_Metric_en <= Ext_Trig_Metric_en;
          end
      end
   end

   wire Metrics_Cnt_En_Int = Use_Ext_Trig?(Metrics_Cnt_En&Ext_Trig_Metric_en):Metrics_Cnt_En;
   wire Metrics_Cnt_En_Out;
   assign Metrics_Cnt_En_Out = Metrics_Cnt_En_Int;

   generate if(C_AXI_PROTOCOL == "AXI4") begin : GEN_AXI4

    // AXI Events from parallel FIFO data
    assign RREADY  = Data_In[0];
    assign RVALID  = Data_In[1];
    assign RLAST   = Data_In[2];
    assign RRESP   = Data_In[4:3];
    assign RID     = Data_In[C_AXIID+4:5];
    assign ARREADY = Data_In[C_AXIID+5];
    assign ARVALID = Data_In[C_AXIID+6];
    assign ARBURST = Data_In[C_AXIID+8:C_AXIID+7];
    assign ARSIZE  = Data_In[C_AXIID+11:C_AXIID+9];
    assign ARLEN   = Data_In[C_AXIID+19:C_AXIID+12];
    assign ARADDR  = Data_In[C_AXIADDR+C_AXIID+19:C_AXIID+20];
    assign ARID    = Data_In[(C_AXIADDR+(2*C_AXIID)+19):(C_AXIADDR+C_AXIID+20)];
    assign BREADY  = Data_In[(C_AXIADDR+(2*C_AXIID)+20)];
    assign BVALID  = Data_In[(C_AXIADDR+(2*C_AXIID)+21)];
    assign BRESP   = Data_In[(C_AXIADDR+(2*C_AXIID)+23):(C_AXIADDR+(2*C_AXIID)+22)];
    assign BID     = Data_In[(C_AXIADDR+(3*C_AXIID)+23):(C_AXIADDR+(2*C_AXIID)+24)];
    assign WREADY  = Data_In[(C_AXIADDR+(3*C_AXIID)+24)];
    assign WVALID  = Data_In[(C_AXIADDR+(3*C_AXIID)+25)];
    assign WLAST   = Data_In[(C_AXIADDR+(3*C_AXIID)+26)];
    assign WSTRB   = Data_In[(C_AXIADDR+(C_AXIDATA/8)+(3*C_AXIID)+26):(C_AXIADDR+(3*C_AXIID)+27)];
    assign AWREADY = Data_In[(C_AXIADDR+(C_AXIDATA/8)+(3*C_AXIID)+27)];
    assign AWVALID = Data_In[(C_AXIADDR+(C_AXIDATA/8)+(3*C_AXIID)+28)];
    assign AWBURST = Data_In[(C_AXIADDR+(C_AXIDATA/8)+(3*C_AXIID)+30):(C_AXIADDR+(C_AXIDATA/8)+(3*C_AXIID)+29)];
    assign AWSIZE  = Data_In[(C_AXIADDR+(C_AXIDATA/8)+(3*C_AXIID)+33):(C_AXIADDR+(C_AXIDATA/8)+(3*C_AXIID)+31)];
    assign AWLEN   = Data_In[(C_AXIADDR+(C_AXIDATA/8)+(3*C_AXIID)+41):(C_AXIADDR+(C_AXIDATA/8)+(3*C_AXIID)+34)];
    assign AWADDR  = Data_In[((2*C_AXIADDR)+(C_AXIDATA/8)+(3*C_AXIID)+41):(C_AXIADDR+(C_AXIDATA/8)+(3*C_AXIID)+42)];
    assign AWID    = Data_In[((2*C_AXIADDR)+(C_AXIDATA/8)+(4*C_AXIID)+41):((2*C_AXIADDR)+(C_AXIDATA/8)+(3*C_AXIID)+42)]; 
    assign TUSER   = 0; 
    assign TDEST   = 0;
    assign TID     = 0;
    assign TLAST   = 0;
    assign TKEEP   = 0;
    assign TSTRB   = 0;
    assign TREADY  = 0;
    assign TVALID  = 0;
    end
    endgenerate 

    generate if(C_AXI_PROTOCOL == "AXI4S") begin : GEN_AXI4S
    assign RREADY  = 0; 
    assign RVALID  = 0; 
    assign RLAST   = 0; 
    assign RRESP   = 0; 
    assign RID     = 0; 
    assign ARREADY = 0; 
    assign ARVALID = 0; 
    assign ARBURST = 0; 
    assign ARSIZE  = 0; 
    assign ARLEN   = 0; 
    assign ARADDR  = 0; 
    assign ARID    = 0; 
    assign BREADY  = 0; 
    assign BVALID  = 0; 
    assign BRESP   = 0; 
    assign BID     = 0; 
    assign WREADY  = 0; 
    assign WVALID  = 0; 
    assign WLAST   = 0; 
    assign WSTRB   = 0; 
    assign AWREADY = 0; 
    assign AWVALID = 0; 
    assign AWBURST = 0; 
    assign AWSIZE  = 0; 
    assign AWLEN   = 0; 
    assign AWADDR  = 0; 
    assign AWID    = 0;  
    assign TUSER   = Data_In[C_AXISUSER-1:0];
    assign TDEST   = Data_In[(C_AXISDEST+C_AXISUSER-1):(C_AXISUSER)];
    assign TID     = Data_In[(C_AXISID+C_AXISDEST+C_AXISUSER-1):(C_AXISUSER+C_AXISDEST)];
    assign TLAST   = Data_In[(C_AXISID+C_AXISDEST+C_AXISUSER)];
    assign TKEEP   = Data_In[((C_AXISDATA/8)+C_AXISID+C_AXISDEST+C_AXISUSER):(C_AXISID+C_AXISDEST+C_AXISUSER+1)];
    assign TSTRB   = Data_In[((2*(C_AXISDATA/8))+C_AXISID+C_AXISDEST+C_AXISUSER):((C_AXISDATA/8)+C_AXISID+C_AXISDEST+C_AXISUSER+1)];
    assign TREADY  = Data_In[((2*(C_AXISDATA/8))+C_AXISID+C_AXISDEST+C_AXISUSER+1)];
    assign TVALID  = Data_In[((2*(C_AXISDATA/8))+C_AXISID+C_AXISDEST+C_AXISUSER+2)];
    end
    endgenerate

    //AXI Memory map imp events capture 
    wire Wr_Addr_Lat = AWREADY & AWVALID & Data_Valid;
    wire Wr_Idle = WVALID & ~(WREADY) & Data_Valid;
    wire First_Write = WVALID & WREADY & ~(Write_going_on) & Data_Valid;
    wire First_Write_iss = WVALID & ~(Write_iss_going_on) & Data_Valid;
    wire Last_Write  = WLAST & WVALID & WREADY & Data_Valid;
    wire Response    = BVALID & BREADY & Data_Valid;
    wire Rd_Addr_Lat = ARREADY & ARVALID & Data_Valid;
    wire Rd_Idle     = RVALID & ~(RREADY) & Data_Valid;
    wire First_Read  = RVALID & RREADY & ~(Read_going_on) & Data_Valid;
    wire Last_Read   = RLAST & RVALID & RREADY & Data_Valid;
    reg Last_Read_buf;
    wire Write_Beat  = WVALID & WREADY & Data_Valid;
    wire Read_Beat   = RVALID & RREADY & Data_Valid; 
    wire [C_METRIC_COUNT_WIDTH-1:0] rd_byte_cnt = C_AXIDATA/8;
    reg [8:0] num_read_beat;
    reg [8:0] num_rd_beats;
  // Force WID/RID to 0 value from register interface if sub-protocol is
  // AXI4LITE
    wire [15:0] Latency_WID_l = (C_AXI_SUB_PROTOCOL == "AXI4LITE")? 16'h0: Latency_WID;
    wire [15:0] Latency_RID_l = (C_AXI_SUB_PROTOCOL == "AXI4LITE")? 16'h0: Latency_RID;
  // Id matching function calling for AWID, ARID, RID and BID
    wire awid_match     = id_matched(WID_Mask[C_AXIID-1:0],Latency_WID_l[C_AXIID-1:0],AWID_COMP);
    wire awid_match_lat = id_matched(WID_Mask[C_AXIID-1:0],Latency_WID_l[C_AXIID-1:0],AWID);
    wire arid_match     = id_matched(RID_Mask[C_AXIID-1:0],Latency_RID_l[C_AXIID-1:0],ARID_COMP);
    wire arid_match_lat = id_matched(RID_Mask[C_AXIID-1:0],Latency_RID_l[C_AXIID-1:0],ARID);
    wire rid_match_int  = id_matched(RID_Mask[C_AXIID-1:0],Latency_RID_l[C_AXIID-1:0],RID);
    wire bid_match      = id_matched(WID_Mask[C_AXIID-1:0],Latency_WID_l[C_AXIID-1:0],BID);
reg First_Write_d1;  
/*------------------Read Beat COunt Calculations for narrow reads KAR-----*/
     always @(posedge clk) begin 
       if (rst_int_n == RST_ACTIVE) begin
          num_read_beat      <= 0;
          num_rd_beats      <= 0;
          Last_Read_buf <= 0;
       end
       else begin
          Last_Read_buf <= Last_Read;         
           if(Read_Beat == 1'b1 && Last_Read == 1'b1) begin
             num_rd_beats <= num_read_beat + 1'b1;
             num_read_beat <= 0;//num_read_beat + 1'b1;
           end
           else if(Read_Beat == 1'b1 && Last_Read == 1'b0) begin
             num_read_beat <= num_read_beat + 1'b1;
           end
     end
     end
assign F1AR_Wr_En = Rd_Addr_Lat;

generate if(C_AXIDATA == 8 && C_AXI_SUB_PROTOCOL != "AXI4LITE") begin : GEN_8BIT_F1AR
       assign F1AR_Wr_Data = 8'h01;
    end
    endgenerate
generate if(C_AXIDATA == 16 && C_AXI_SUB_PROTOCOL != "AXI4LITE") begin : GEN_16BIT_F1AR
       assign F1AR_Wr_Data = (ARSIZE == 3'b000 ? 8'h01 : 8'h02);
    end
    endgenerate
generate if(C_AXIDATA == 32 && C_AXI_SUB_PROTOCOL != "AXI4LITE") begin : GEN_32BIT_F1AR
       assign F1AR_Wr_Data = (ARSIZE == 3'b000 ? 8'h01 : (ARSIZE == 3'b001 ? 8'h02 : 8'h04));
    end
    endgenerate
generate if(C_AXIDATA == 64 && C_AXI_SUB_PROTOCOL != "AXI4LITE") begin : GEN_64BIT_F1AR
       assign F1AR_Wr_Data = (ARSIZE == 3'b000 ? 8'h01 : (ARSIZE == 3'b001 ? 8'h02 : (ARSIZE == 3'b010 ? 8'h04 : 8'h08)));
    end
    endgenerate
generate if(C_AXIDATA == 128 && C_AXI_SUB_PROTOCOL != "AXI4LITE") begin : GEN_128BIT_F1AR
       assign F1AR_Wr_Data = (ARSIZE == 3'b000 ? 8'h01 : (ARSIZE == 3'b001 ? 8'h02 : (ARSIZE == 3'b010 ? 8'h04 : (ARSIZE == 3'b011 ? 8'h08 : 8'h10))));
    end
    endgenerate
generate if(C_AXIDATA == 256 && C_AXI_SUB_PROTOCOL != "AXI4LITE") begin : GEN_256BIT_F1AR
 assign F1AR_Wr_Data = (ARSIZE == 3'b000 ? 8'h01 : (ARSIZE == 3'b001 ? 8'h02 : (ARSIZE == 3'b010 ? 8'h04 : (ARSIZE == 3'b011 ? 8'h08 : (ARSIZE == 3'b100 ? 8'h10 : 8'h20)))));
    end
    endgenerate
generate if(C_AXIDATA == 512 && C_AXI_SUB_PROTOCOL != "AXI4LITE") begin : GEN_512BIT_F1AR
       assign F1AR_Wr_Data = (ARSIZE == 3'b000 ? 8'h01 : (ARSIZE == 3'b001 ? 8'h02 : (ARSIZE == 3'b010 ? 8'h04 : (ARSIZE == 3'b011 ? 8'h08 : (ARSIZE == 3'b100 ? 8'h10 : (ARSIZE == 3'b101 ? 8'h20 : 8'h40 ))))));
    end
    endgenerate
generate if(C_AXIDATA == 1024 && C_AXI_SUB_PROTOCOL != "AXI4LITE") begin : GEN_1024BIT_F1AR
       assign F1AR_Wr_Data = (ARSIZE == 3'b000 ? 8'h01 : (ARSIZE == 3'b001 ? 8'h02 : (ARSIZE == 3'b010 ? 8'h04 : (ARSIZE == 3'b011 ? 8'h08 : (ARSIZE == 3'b100 ? 8'h10 : (ARSIZE == 3'b101 ? 8'h20 : (ARSIZE == 3'b110 ? 8'h40 : (ARSIZE == 3'b111 ? 8'h80 : 8'h80))))))));
    end
    endgenerate

//assign F1AR_Wr_Data = (ARSIZE == 3'b000 ? 8'h01 : (ARSIZE == 3'b001 ? 8'h02 : (ARSIZE == 3'b010 ? 8'h04 : (ARSIZE == 3'b011 ? 8'h08 : (ARSIZE == 3'b100 ? 8'h10 : (ARSIZE == 3'b101 ? 8'h20 : (ARSIZE == 3'b110 ? 8'h40 : (ARSIZE == 3'b111 ? 8'h80 : 8'h04))))))));

generate if(C_AXI_SUB_PROTOCOL != "AXI4LITE") begin : GEN_ARSIZE_FIFO

assign F1AR_Rd_En = Last_Read;
assign F1_ARSIZE = F1AR_Rd_Data;

axi_perf_mon_v5_0_12_sync_fifo 
     #(
        .WIDTH      (8), 
        .DEPTH_LOG2 (5) 
     ) F1_ARSIZE_NARROW
     (
       .rst_n    (rst_int_n),
       .clk      (clk),
       .wren     (F1AR_Wr_En   ),
       .rden     (F1AR_Rd_En   ),
       .din      (F1AR_Wr_Data ),
       .dout     (F1AR_Rd_Data ),
       .full     (           ),
       .empty    (           )
     );
    end
    endgenerate
generate if(C_AXI_SUB_PROTOCOL == "AXI4LITE") begin : GEN_ARSIZE_AXI4FIFO

assign F1AR_Rd_En = 0;
assign F1_ARSIZE = 0;
     end
  endgenerate

/*------------------END Read Beat COunt Calculations for narrow reads KAR-----*/
  /*------------------Registering Write metrics to pipeline along with wid_match-----*/
     always @(posedge clk) begin 
       if (rst_int_n == RST_ACTIVE) begin
          //Write_Beat_reg     <= 0;
          //Wr_Idle_reg        <= 0;
          //Last_Write_reg     <= 0;
          First_Write_reg    <= 0;
          First_Write_d1    <= 0;
          First_Read_reg     <= 0;
          Last_Read_reg      <= 0;
          //wr_byte_cnt_reg    <= 0;
          AWID_reg           <= 0;
          ARID_reg           <= 0;
          rid_match_reg      <= 0;
       end
       else begin
          //Write_Beat_reg     <= Write_Beat;
          //Wr_Idle_reg        <= Wr_Idle;
          //Last_Write_reg     <= Last_Write;
          First_Write_d1    <= First_Write;
          First_Write_reg    <= First_Write_d1;
          First_Read_reg     <= First_Read;
          Last_Read_reg      <= Last_Read;
          //wr_byte_cnt_reg    <= wr_byte_cnt;
          AWID_reg           <= AWID;
          ARID_reg           <= ARID;
          rid_match_reg      <= rid_match_int;
       end
     end
//K K START 
// New architecture for id based filtering calculation.
// Take 4 FIFOs: 
// F1: To store awid match/not match information
// F2: To store first write on write channel for each transaction.
// F3: Time stamp at latency start point
// F4: Time stamp at latency end   point
// How this works:
// Write to F1 awid match information when a Address detected
// Write to F2 when the first write on write channel detected
// Write to F3 when "latency start point" detected
// Write to F4 when "latency end   point" detected
// 
// Read F1&F2 when both are not empty
// Generate wid-match if Rd.data.F1 = 1 and Rd.data.F2 = 1
//  use this as qualifier to generate beat cnt,idle cnt, wlast cnt. 
//  Delay the corresponding beat,idle,wlast data based on above read.
//
// Read F3&F4 when both are not empty
//  use wid-match generated above to qualify if we need calculate latency
//  if(wid.match)
//    update min/max/total latency
//  else no update  
//

//F1
wire F1_Wr_En,F1_Rd_En;
wire F1_Wr_Data,F1_Rd_Data;
reg awid_match_d1;
assign F1_Wr_En   = Wr_Add_Issue & Metrics_Cnt_En_Int;//wr_latency_start; 
assign F1_Wr_Data = awid_match_d1 || ~(En_Id_Based);

 
    axi_perf_mon_v5_0_12_sync_fifo 
     #(
        .WIDTH      (1), 
        .DEPTH_LOG2 (5) 
     ) F1_AWID_MATCH
     (
       .rst_n    (rst_int_n),
       .clk      (clk),
       .wren     (F1_Wr_En   ),
       .rden     (F1_Rd_En   ),
       .din      (F1_Wr_Data ),
       .dout     (F1_Rd_Data ),
       .full     (           ),
       .empty    (F1_Empty   )
     );

//F2
wire F2_Wr_En,F2_Rd_En;
wire F2_Wr_Data,F2_Rd_Data;
//assign F2_Wr_En   = First_Write; 
assign F2_Wr_En   = First_Write_iss & Metrics_Cnt_En_Int; 
//assign F2_Wr_En   = Wr_Valid_Issue;//First_Write; 
assign F2_Wr_Data = 1'b1; 

 
    axi_perf_mon_v5_0_12_sync_fifo 
     #(
        .WIDTH      (1),
        .DEPTH_LOG2 (5)
     ) F2_FIRST_WRITE
     (
       .rst_n    (rst_int_n),
       .clk      (clk),
       .wren     (F2_Wr_En   ),
       .rden     (F2_Rd_En   ),
       .din      (F2_Wr_Data ),
       .dout     (F2_Rd_Data ),
       .full     (           ),
       .empty    (F2_Empty   )
     );

//Rd F1,F2 and generate Wid_match
wire F12_Rd_En;
assign F12_Rd_En = (F1_Empty == 1'b0) && (F2_Empty == 1'b0);
assign F1_Rd_En = F12_Rd_En;
assign F2_Rd_En = F12_Rd_En;

reg F12_Rd_Vld;
  always @(posedge clk) begin
    if (rst_int_n == RST_ACTIVE) begin
        F12_Rd_Vld <= 1'b0;
    end else begin
        F12_Rd_Vld <= F12_Rd_En;
    end
  end

reg wid_match_reg;
assign wid_match = (F12_Rd_Vld)? (F1_Rd_Data&F2_Rd_Data): wid_match_reg;
  always @(posedge clk) begin
    if (rst_int_n == RST_ACTIVE) begin
        wid_match_reg <= 1'b0;
    end else begin
        wid_match_reg <= wid_match;
    end
  end
//Delay Write_Beat,Wr_Idle,Last_Write based on above FIFOs read data
//availability
//
reg  Write_Beat_d1,Write_Beat_d2,Write_Beat_d3,Write_Beat_d4;
reg  Wr_Idle_d1,Wr_Idle_d2,Wr_Idle_d3,Wr_Idle_d4;
//reg  Last_Write_d1;
//,Last_Write_d2;
reg  [C_METRIC_COUNT_WIDTH-1:0] wr_byte_cnt_d1;
reg [C_METRIC_COUNT_WIDTH-1:0] wr_byte_cnt_d2;
reg [C_METRIC_COUNT_WIDTH-1:0] wr_byte_cnt_d3;
reg [C_METRIC_COUNT_WIDTH-1:0] wr_byte_cnt_d4;
reg  Last_Write_d1,Last_Write_d2,Last_Write_d3,Last_Write_d4,Last_Write_cnt2;
always @(posedge clk) begin
  if (rst_int_n == RST_ACTIVE) begin
      Write_Beat_d1  <= 1'b0;
      Write_Beat_d2  <= 1'b0;
      Write_Beat_d3  <= 1'b0;
      Write_Beat_d4  <= 1'b0;
      Write_Beat_reg <= 1'b0;
      Wr_Idle_d1     <= 1'b0;
      Wr_Idle_d2     <= 1'b0;
      Wr_Idle_d3     <= 1'b0;
      Wr_Idle_d4     <= 1'b0;
      Wr_Idle_reg    <= 1'b0;
      Last_Write_d1  <= 1'b0;
      Last_Write_d2  <= 1'b0;
      Last_Write_d3  <= 1'b0;
      Last_Write_d4  <= 1'b0;
      Last_Write_reg <= 1'b0;
      Last_Write_cnt2 <= 1'b0;
      wr_byte_cnt_d1 <= 1'b0;
      wr_byte_cnt_d2 <= 1'b0;
      wr_byte_cnt_d3 <= 1'b0;
      wr_byte_cnt_d4 <= 1'b0;
      wr_byte_cnt_reg <= 1'b0;
  end else begin
      Write_Beat_d1  <= Write_Beat;
      Write_Beat_d2  <= Write_Beat_d1;
      Write_Beat_d3  <= Write_Beat_d2;
      Write_Beat_d4  <= Write_Beat_d3;
      Write_Beat_reg <= Write_Beat_d4;
      Wr_Idle_d1     <= Wr_Idle;
      Wr_Idle_d2     <= Wr_Idle_d1;
      Wr_Idle_d3     <= Wr_Idle_d2;
      Wr_Idle_d4     <= Wr_Idle_d3;
      Wr_Idle_reg    <= Wr_Idle_d4;
      Last_Write_d1  <= Last_Write;
      Last_Write_d2  <= Last_Write_d1;
      Last_Write_d3  <= Last_Write_d2;
      Last_Write_d4  <= Last_Write_d3;
      Last_Write_reg <= Last_Write_d4;
      if(Wr_Lat_Start == 1'b0 && Wr_Lat_End == 1'b0)
      Last_Write_cnt2 <= Last_Write_d3;
      else
      Last_Write_cnt2 <= Last_Write_d4;
      wr_byte_cnt_d1 <= (Data_Valid == 1'b1)?wr_byte_cnt:0;
      wr_byte_cnt_d2 <= wr_byte_cnt_d1;
      wr_byte_cnt_d3 <= wr_byte_cnt_d2;
      wr_byte_cnt_d4 <= wr_byte_cnt_d3;
      wr_byte_cnt_reg <= wr_byte_cnt_d4;
  end
end

//Latency Fifos
wire F3_Wr_En,F3_Rd_En;
reg F34_Rd_Vld;
wire F34_Rd_En;
//reg F3_Rd_En;
wire [C_METRIC_COUNT_WIDTH:0] F3_Wr_Data;
wire [C_METRIC_COUNT_WIDTH:0] F3_Rd_Data;
reg wr_latency_start_d1;//,awid_match_d1;
reg wr_latency_start_d2,awid_match_d2;
always @(posedge clk) begin
if (rst_int_n == RST_ACTIVE) begin
        wr_latency_start_d1 <= 1'b0;
        wr_latency_start_d2 <= 1'b0;
        awid_match_d1 <= 1'b0;
        awid_match_d2 <= 1'b0;
    end else begin
        wr_latency_start_d1 <= wr_latency_start;
        wr_latency_start_d2 <= wr_latency_start_d1;
        awid_match_d1 <= awid_match_lat;
        awid_match_d2 <= awid_match_d1;
    end
end
assign F3_Wr_En   = wr_latency_start_d2 & Metrics_Cnt_En_Int; 
assign F3_Wr_Data = {Write_Latency_Cnt_Ovf,Write_Latency_Cnt_Out}; 

 
    axi_perf_mon_v5_0_12_sync_fifo 
     #(
        .WIDTH      (C_METRIC_COUNT_WIDTH+1),
        .DEPTH_LOG2 (5)
     ) F3_WR_LAT_START
     (
       .rst_n    (rst_int_n),
       .clk      (clk),
       .wren     (F3_Wr_En   ),
       .rden     (F3_Rd_En   ),
       .din      (F3_Wr_Data ),
       .dout     (F3_Rd_Data ),
       .full     (           ),
       .empty    (F3_Empty   )
     );


wire F4_Wr_En,F4_Rd_En;
wire [C_METRIC_COUNT_WIDTH:0] F4_Wr_Data;
wire [C_METRIC_COUNT_WIDTH:0] F4_Rd_Data;
reg wr_latency_end_d1,wr_latency_end_d2;

always @(posedge clk) begin
if (rst_int_n == RST_ACTIVE) begin
        wr_latency_end_d1 <= 1'b0;
        wr_latency_end_d2 <= 1'b0;
    end else begin
        wr_latency_end_d1 <= wr_latency_end;
        wr_latency_end_d2 <= wr_latency_end_d1;
    end
end


//assign F4_Wr_En   = ((Wr_Lat_Start || Wr_Lat_End) == 1'b0)?wr_latency_end:wr_latency_end_d1; 
assign F4_Wr_En   = wr_latency_end_d2 & Metrics_Cnt_En_Int; 
assign F4_Wr_Data = {Write_Latency_Cnt_Ovf,Write_Latency_Cnt_Out}; 

 
    axi_perf_mon_v5_0_12_sync_fifo 
     #(
        .WIDTH      (C_METRIC_COUNT_WIDTH+1),
        .DEPTH_LOG2 (5)
     ) F4_WR_LAT_END
     (
       .rst_n    (rst_int_n),
       .clk      (clk),
       .wren     (F4_Wr_En   ),
       .rden     (F4_Rd_En   ),
       .din      (F4_Wr_Data ),
       .dout     (F4_Rd_Data ),
       .full     (           ),
       .empty    (F4_Empty   )
     );

//Rd F3,F4 and update latency if wid_matches 
assign F34_Rd_En = (F3_Empty == 1'b0) && (F4_Empty == 1'b0);
assign F3_Rd_En = F34_Rd_En;
assign F4_Rd_En = F34_Rd_En;

  always @(posedge clk) begin
    if (rst_int_n == RST_ACTIVE) begin
        F34_Rd_Vld <= 1'b0;
    end else begin
        F34_Rd_Vld <= F34_Rd_En;
    end
  end

//wire [C_METRIC_COUNT_WIDTH-1:0] Wr_Lat_Cnt_Diff;
reg update_min_Wr_Lat;
reg update_max_Wr_Lat;


//Below logic is for timing violation fix Wr_Lat_Cnt_Diff_reg F34_Rd_Vld_reg 
reg F34_Rd_Vld_reg; 
reg [C_METRIC_COUNT_WIDTH-1:0] Wr_Lat_Cnt_Diff_reg;
always @(posedge clk) begin
    if (rst_int_n == RST_ACTIVE) begin
      F34_Rd_Vld_reg       <= 0;
      Wr_Lat_Cnt_Diff_reg  <= 0;
    end else begin
      if(F34_Rd_Vld) begin
       if(F4_Rd_Data[C_METRIC_COUNT_WIDTH] ^ F3_Rd_Data[C_METRIC_COUNT_WIDTH]) begin
          if(F3_Rd_Data[C_METRIC_COUNT_WIDTH-1:0]>F4_Rd_Data[C_METRIC_COUNT_WIDTH-1:0]) begin
              Wr_Lat_Cnt_Diff_reg  <= (~(F3_Rd_Data[C_METRIC_COUNT_WIDTH-1:0]) + F4_Rd_Data[C_METRIC_COUNT_WIDTH-1:0])+1'b1;//:(F4_Rd_Data - F3_Rd_Data);;
          end else begin
              Wr_Lat_Cnt_Diff_reg <= (~F4_Rd_Data[C_METRIC_COUNT_WIDTH-1:0]) + F3_Rd_Data[C_METRIC_COUNT_WIDTH-1:0]+1'b1;
          end
      end
      else begin
        if(F3_Rd_Data[C_METRIC_COUNT_WIDTH-1:0]>F4_Rd_Data[C_METRIC_COUNT_WIDTH-1:0]) begin
             Wr_Lat_Cnt_Diff_reg  <= (F3_Rd_Data[C_METRIC_COUNT_WIDTH-1:0] - F4_Rd_Data[C_METRIC_COUNT_WIDTH-1:0]);//:(F4_Rd_Data - F3_Rd_Data);;
        end else begin
            Wr_Lat_Cnt_Diff_reg  <= F4_Rd_Data[C_METRIC_COUNT_WIDTH-1:0] - F3_Rd_Data[C_METRIC_COUNT_WIDTH-1:0];
        end
     end
    end
      F34_Rd_Vld_reg <= F34_Rd_Vld;
    end
  end
reg [C_METRIC_COUNT_WIDTH-1:0] Wr_Lat_Cnt_Diff_reg1;
reg F34_Rd_Vld_reg_d2,wid_match_reg_d2;
always @(posedge clk) begin
    if (rst_int_n == RST_ACTIVE) begin
      update_min_Wr_Lat    <= 0;
      update_max_Wr_Lat    <= 0;
      Wr_Lat_Cnt_Diff_reg1  <= 0;
    end else begin
      if(F34_Rd_Vld_reg) begin
       update_min_Wr_Lat    <= Wr_Lat_Cnt_Diff_reg < Min_Write_Latency_Int;
	    update_max_Wr_Lat    <= Wr_Lat_Cnt_Diff_reg > Max_Write_Latency_Int;
     end
     Wr_Lat_Cnt_Diff_reg1  <= Wr_Lat_Cnt_Diff_reg;
     F34_Rd_Vld_reg_d2 <= F34_Rd_Vld_reg;
     wid_match_reg_d2  <= wid_match_reg;
    end
end
  //Total wr.latency
  always @(posedge clk) begin
    if (rst_int_n == RST_ACTIVE) begin
        Write_Latency_Int <= 1'b0;
        Write_Latency_En_Int <= 1'b0;
    end else if(wid_match_reg_d2 == 1'b1 && F34_Rd_Vld_reg_d2) begin
        Write_Latency_Int <= Wr_Lat_Cnt_Diff_reg1;
        Write_Latency_En_Int <= Metrics_Cnt_En_Int;
    end else
        Write_Latency_En_Int <= 1'b0;
  end

//Min wr.latency
  always @(posedge clk) begin
    if (rst_int_n == RST_ACTIVE) begin
      Min_Write_Latency_Int    <= ALL_ONES;
    end else if(wid_match_reg_d2 == 1'b1 && F34_Rd_Vld_reg_d2 && update_min_Wr_Lat) begin
      Min_Write_Latency_Int    <= Wr_Lat_Cnt_Diff_reg1;
    end
  end

//Max wr.latency
  always @(posedge clk) begin
    if (rst_int_n == RST_ACTIVE) begin
      Max_Write_Latency_Int    <= 0;
    end else if(wid_match_reg_d2 == 1'b1 && F34_Rd_Vld_reg_d2 && update_max_Wr_Lat) begin
      Max_Write_Latency_Int    <= Wr_Lat_Cnt_Diff_reg1;
    end
  end

// K K END       
    // awid match latch for write transactions as there is no WID(No Interleaving support).
    // awid FIFO Instance to store outstanding transactions ID match
//commenting dead code - 22-07-2014 
   // Writing to FIFO when there is a write address latch

    // Write data byte counts for different data widths of the bus 

    generate if(C_AXIDATA == 8) begin : GEN_8BIT_BYTECNT
       assign wr_byte_cnt = {zeros[C_METRIC_COUNT_WIDTH-1:1],count(WSTRB)}; 
    end
    endgenerate

    generate if(C_AXIDATA ==16) begin : GEN_16BIT_BYTECNT
       assign wr_byte_cnt = {zeros[C_METRIC_COUNT_WIDTH-1:2],count(WSTRB)}; 
    end
    endgenerate

    generate if(C_AXIDATA == 32) begin : GEN_32BIT_BYTECNT
       assign wr_byte_cnt = {zeros[C_METRIC_COUNT_WIDTH-1:3],count_4(WSTRB)}; 
    end
    endgenerate

    generate if(C_AXIDATA == 64) begin : GEN_64BIT_BYTECNT
       assign wr_byte_cnt = {zeros[C_METRIC_COUNT_WIDTH-1:4],count_8(WSTRB)}; 
    end
    endgenerate

    generate if(C_AXIDATA == 128) begin : GEN_128BIT_BYTECNT
       assign wr_byte_cnt = {zeros[C_METRIC_COUNT_WIDTH-1:5],count_16(WSTRB)}; 
    end
    endgenerate

    generate if(C_AXIDATA == 256) begin : GEN_256BIT_BYTECNT
       assign wr_byte_cnt = {zeros[C_METRIC_COUNT_WIDTH-1:6],count_32(WSTRB)}; 
    end
    endgenerate

    generate if(C_AXIDATA == 512) begin : GEN_512BIT_BYTECNT
       assign wr_byte_cnt = {zeros[C_METRIC_COUNT_WIDTH-1:7],count_64(WSTRB)}; 
    end
    endgenerate

    generate if(C_AXIDATA == 1024) begin : GEN_1024BIT_BYTECNT
       assign wr_byte_cnt = {zeros[C_METRIC_COUNT_WIDTH-1:8],count_128(WSTRB)}; 
    end
    endgenerate
    
    //Latency start and end points selection based on control register
    //Write access done logic and registering address ID for identifying write address issue.
    //always @(posedge clk) begin
    //  if (rst_int_n == RST_ACTIVE) begin
    //     Write_access_done = 1'b0;
    //     Reg_AWID          = 0;
    //  end
    //  else begin
    //     Reg_AWID          = AWID;
    //    if (AWVALID == 1'b1 && AWREADY == 1'b1) begin
    //       Write_access_done = 1'b1;
    //    end
    //    else if ((AWVALID ^ AWREADY) == 1'b1) begin
    //       Write_access_done = 1'b0;
    //    end  
    //  end
    //end

    //Write address issuance logic
    always @(posedge clk) begin
      if (rst_int_n == RST_ACTIVE) begin
        Wr_Add_Issue <= 1'b0;
        No_Wr_Ready <= 1'b0;
      end
      else begin //if(Wr_Lat_Start == 1'b0) begin    // If address issue as start point 
        if(AWVALID == 1'b1 && AWREADY == 1'b1 && No_Wr_Ready == 1'b0 && Data_Valid == 1'b1) begin //Address issue&accept
          Wr_Add_Issue <= 1'b1;
          No_Wr_Ready <= 1'b0;
        end
        else if(AWVALID == 1'b1 && AWREADY == 1'b1 && No_Wr_Ready == 1'b1 && Data_Valid == 1'b1) begin//No_Wr_Readyreset
          Wr_Add_Issue <= 1'b0;
          No_Wr_Ready <= 1'b0;
        end
        else if(AWVALID == 1'b1 && AWREADY == 1'b0 && No_Wr_Ready == 1'b0 && Data_Valid == 1'b1)begin //Address issue
          Wr_Add_Issue <= 1'b1;
          No_Wr_Ready <=  1'b1;
        end
        else if(AWVALID == 1'b0 && Data_Valid == 1'b1) begin //No valid address
          Wr_Add_Issue <= 1'b0;
          No_Wr_Ready <=  1'b0;
        end
        else begin //This is to stop address issue assertion when there is no AWREADY
          Wr_Add_Issue <= 1'b0;  
          No_Wr_Ready <=  No_Wr_Ready;
        end
      end
    end  
 // Write valid issuance logic
//reg Wr_Valid_Issue,No_Write_Ready;
  always @(posedge clk) begin
      if (rst_int_n == RST_ACTIVE) begin
        Wr_Valid_Issue <= 1'b0;
        No_Write_Ready <= 1'b0;
      end
      else begin //if(Wr_Lat_Start == 1'b0) begin    // If address issue as start point 
        if(WVALID == 1'b1 && WREADY == 1'b1 && No_Write_Ready == 1'b0 && Data_Valid == 1'b1) begin //Address issue&accept
          Wr_Valid_Issue <= 1'b1;
          No_Write_Ready <= 1'b0;
        end
        else if(WVALID == 1'b1 && WREADY == 1'b1 && No_Write_Ready == 1'b1 && Data_Valid == 1'b1) begin//No_Write_Readyreset
          Wr_Valid_Issue <= 1'b0;
          No_Write_Ready <= 1'b0;
        end
        else if(WVALID == 1'b1 && WREADY == 1'b0 && No_Write_Ready == 1'b0 && Data_Valid == 1'b1)begin //Address issue
          Wr_Valid_Issue <= 1'b1;
          No_Write_Ready <=  1'b1;
        end
        else if(WVALID == 1'b0 && Data_Valid == 1'b1) begin //No valid address
          Wr_Valid_Issue <= 1'b0;
          No_Write_Ready <=  1'b0;
        end
        else begin //This is to stop address issue assertion when there is no WREADY
          Wr_Valid_Issue <= 1'b0;  
          No_Write_Ready <=  No_Write_Ready;
        end
      end
    end

    //Read address issuance logic
    always @(posedge clk) begin
      if (rst_int_n == RST_ACTIVE) begin
          Rd_Add_Issue <= 1'b0;
          No_Rd_Ready  <= 1'b0;
      end
      else if(Rd_Lat_Start == 1'b0) begin  //If address issue as start point
        if(ARVALID == 1'b1 && ARREADY == 1'b1 && No_Rd_Ready == 1'b0 && Data_Valid == 1'b1) begin //Address issue&accept
          Rd_Add_Issue <= 1'b1;
          No_Rd_Ready  <= 1'b0;
        end
      else if(ARVALID==1'b1 && ARREADY==1'b1 && No_Rd_Ready==1'b1 && Data_Valid==1'b1)begin//Resetting No_Rd_Ready 
          Rd_Add_Issue <= 1'b0;
          No_Rd_Ready  <=  1'b0;
        end
        else if(ARVALID == 1'b1 && ARREADY == 1'b0 && No_Rd_Ready == 1'b0 && Data_Valid == 1'b1)begin //Address issue 
          Rd_Add_Issue <= 1'b1;
          No_Rd_Ready  <=  1'b1;
        end
        else if(ARVALID == 1'b0 && Data_Valid == 1'b1) begin // No valid address
          Rd_Add_Issue <= 1'b0;
          No_Rd_Ready  <=  1'b0;
        end
        else begin 
          Rd_Add_Issue <= 1'b0;  //This is to stop address issue assertion when there is no ARREADY
          No_Rd_Ready  <= No_Rd_Ready;
        end
      end
      else begin
        Rd_Add_Issue <= 1'b0;
        No_Rd_Ready  <= 1'b0;
      end
    end  

    //Latency start and end points selection based on control register
    //Default latency calculation is from write/read address issue to last write/read
    assign wr_latency_start = Wr_Lat_Start?Wr_Addr_Lat:Wr_Add_Issue;
    assign First_Write_sel  = Wr_Lat_Start?First_Write:First_Write_d1; //reg;
    //assign Last_Write_sel   = Wr_Lat_Start?Last_Write:Last_Write_reg;
    assign Last_Write_sel   = Wr_Lat_Start?Last_Write:Last_Write_d1; 
    assign First_Read_sel  = Rd_Lat_Start?First_Read:First_Read_reg;
    assign Last_Read_sel   = Rd_Lat_Start?Last_Read:Last_Read_reg;
    assign wr_latency_end   = Wr_Lat_End?First_Write_sel:Last_Write_sel;
    assign rd_latency_start = Rd_Lat_Start?Rd_Addr_Lat:Rd_Add_Issue;
    assign rd_latency_end   = Rd_Lat_End?First_Read_sel:Last_Read_sel;
    wire [C_METRIC_COUNT_WIDTH-1:0] Latency_Load_value = ONE;
    assign AWID_COMP = Wr_Lat_Start?AWID:AWID_reg;
    assign ARID_COMP = Rd_Lat_Start?ARID:ARID_reg;
    wire rid_match = Rd_Lat_Start?rid_match_int:rid_match_reg;

    //-- Write_going_on for First_Write_Flag generation
    always @(posedge clk) begin 
       if (rst_int_n == RST_ACTIVE) begin
           Write_going_on <= 1'b0;
       end
       else begin
           if (Last_Write == 1'b1) begin
               Write_going_on <= 1'b0;
           end
           else if (First_Write == 1'b1)  begin
               Write_going_on <= 1'b1;
           end
           else begin
               Write_going_on <= Write_going_on;
           end
       end
    end 
//-- Write_going_on for First_Write_issuance_Flag generation
    always @(posedge clk) begin 
       if (rst_int_n == RST_ACTIVE) begin
           Write_iss_going_on <= 1'b0;
       end
       else begin
           if (Last_Write == 1'b1) begin
               Write_iss_going_on <= 1'b0;
           end
           else if (First_Write_iss == 1'b1)  begin
               Write_iss_going_on <= 1'b1;
           end
           else begin
               Write_iss_going_on <= Write_iss_going_on;
           end
       end
    end 

    //commenting dead code - 22-07-2014    
    //-- Write latency calculation based on AWID,BID
    //-- Id's are coming from register interface
//     always @(posedge clk) begin 
//       if(rst_int_n == RST_ACTIVE) begin
//           Wr_Latency_Fifo_Wr_En   <= 1'b0;
//           Wr_Latency_Fifo_Wr_Data <= 0;
//       end
//       else begin // Id filtering/ignoring 
//           if(wr_latency_start == 1'b1 && ((awid_match == 1'b1 && En_Id_Based == 1'b1) || En_Id_Based == 1'b0)) begin 
//              Wr_Latency_Fifo_Wr_En   <= ~ Wr_Latency_Fifo_Full;
//	      if(Wr_cnt_ld == 1'b1) begin
//                Wr_Latency_Fifo_Wr_Data <= ONE;
//              end
//	      else begin
//                Wr_Latency_Fifo_Wr_Data <= Write_Latency_Cnt_Out;
//              end
//           end
//           else begin
//              Wr_Latency_Fifo_Wr_En   <= 1'b0;
//              Wr_Latency_Fifo_Wr_Data <= Wr_Latency_Fifo_Wr_Data;
//           end
//       end
//    end

   // Reading the FIFO loaded with the count when write started 
//   always @(posedge clk) begin 
//       if(rst_int_n == RST_ACTIVE) begin
//           Wr_Latency_Fifo_Rd_En       <= 1'b0;
//           Wr_Latency_Fifo_Rd_En_D1    <= 1'b0;
//           Wr_Latency_Fifo_Rd_En_D2    <= 1'b0;
//           Write_Latency_Cnt_Out_D1    <= 0;  
//           Write_Latency_Cnt_Out_D2    <= 0;  
//           Write_Latency_One           <= 0;       //when write end comes with in one clock 
//           Write_Latency_One_D1        <= 0;
//           Wr_Latency_Fifo_Rd_Data_D1  <= 0;
//       end
//       else begin   // If ID based latency is set then only
//           Wr_Latency_Fifo_Rd_En_D1   <= Wr_Latency_Fifo_Rd_En;
//           Wr_Latency_Fifo_Rd_En_D2   <= Wr_Latency_Fifo_Rd_En_D1;
//           Write_Latency_Cnt_Out_D1   <= Write_Latency_Cnt_Out;  
//           Write_Latency_Cnt_Out_D2   <= Write_Latency_Cnt_Out_D1;  
//           Write_Latency_One_D1       <= Write_Latency_One && ~Wr_Latency_Fifo_Empty;
//           Wr_Latency_Fifo_Rd_Data_D1 <= Wr_Latency_Fifo_Rd_Data;
//           if(wr_latency_end==1'b1 && (((Wr_Id_Fifo_Rd_Data == 1'b1 || wid_match == 1'b1) 
//              && En_Id_Based == 1'b1) || En_Id_Based == 1'b0)) begin 
//              Wr_Latency_Fifo_Rd_En   <=  ~ Wr_Latency_Fifo_Empty;
//              Write_Latency_One       <=  Wr_Latency_Fifo_Empty;
//           end
//           else begin
//              Wr_Latency_Fifo_Rd_En  <= 1'b0;
//              Write_Latency_One      <= 0;
//           end
//       end
//    end
//    assign Wr_Latency_Fifo_Rd_En_out = Wr_Latency_Fifo_Rd_En |  Write_Latency_One_D1;
    

    // Write latency FIFO occupancy based on write and reads to FIFO
//    always @(posedge clk) begin 
//       if(rst_int_n == RST_ACTIVE) begin
//           Wr_Latency_Occupancy   <= 0;
//       end
//       else begin
//           if(wr_latency_start == 1'b1 && wr_latency_end == 1'b1 && 
//             ((awid_match == 1'b1 && En_Id_Based == 1'b1) || En_Id_Based == 1'b0)) begin
//              Wr_Latency_Occupancy   <= Wr_Latency_Occupancy;
//           end
//           else if(wr_latency_start==1'b1 && ((awid_match == 1'b1 && En_Id_Based ==1'b1) || En_Id_Based == 1'b0)) begin 
//              Wr_Latency_Occupancy   <= Wr_Latency_Occupancy + 1'b1;
//           end
//           else if(wr_latency_end == 1'b1 && Wr_Latency_Occupancy != 0 && 
//                  (((wid_match == 1'b1) &&
//                     En_Id_Based == 1'b1) || En_Id_Based == 1'b0)) begin
//              Wr_Latency_Occupancy   <= Wr_Latency_Occupancy - 1'b1;
//           end
//       end
//    end

     //-- WR latency FIFO Instance to store outstanding transactions
//    axi_perf_mon_v5_0_12_sync_fifo 
//     #(
//        .WIDTH      (C_METRIC_COUNT_WIDTH), // The width of the FIFO data
//        .DEPTH_LOG2 (5                   )  // Specify power-of-2 FIFO depth
//     ) wr_latency_fifo_inst
//     (
//       .rst_n    (rst_int_n),
//       .clk      (clk),
//       .wren     (Wr_Latency_Fifo_Wr_En),
//       .rden     (Wr_Latency_Fifo_Rd_En_out),
//       .din      (Wr_Latency_Fifo_Wr_Data),
//       .dout     (Wr_Latency_Fifo_Rd_Data),
//       .full     (Wr_Latency_Fifo_Full),
//       .empty    (Wr_Latency_Fifo_Empty)
//     );
    
    //-- Overflow capture of write latency counter for better timing  
    //To address overflow of the counter between Latency start and end `
    //always @(posedge clk) begin 
    //   if(rst_int_n == RST_ACTIVE) begin
    //      Write_Latency_Ovf <= 0;
    //   end
    //   else if(Wr_Latency_Fifo_Rd_En_D1 == 1'b1) begin
    //     if(Write_Latency_Cnt_Out_D1 < Wr_Latency_Fifo_Rd_Data) begin
    //        Write_Latency_Ovf <= 1'b1;
    //     end
    //     else begin  
    //        Write_Latency_Ovf <= 1'b0; 
    //     end
    //   end
    //end

    //-- Write latency capture from fifo read data with current counter value
    //-- TWO is for two clocks pipelining delay 1for Wr_Latency_Fifo_Rd_En_D2 and 1 for Write_Latency_Ovf 
//    always @(posedge clk) begin 
//       if(rst_int_n == RST_ACTIVE) begin
//         // Write_Latency_Int    <= 0;
//          Write_Latency_En_Int <= 0;
//       end
//       else begin
//          if(Write_Latency_One_D1 == 1'b1) begin
//           //   Write_Latency_Int    <= ONE;
//              Write_Latency_En_Int <= Metrics_Cnt_En_Int;
//          end
//          else if(Wr_Latency_Fifo_Rd_En_D2 == 1'b1) begin
//             Write_Latency_En_Int <= Metrics_Cnt_En_Int;
//             if(Write_Latency_Ovf == 1'b0) begin
//             //    Write_Latency_Int    <= Write_Latency_Cnt_Out_D2 - Wr_Latency_Fifo_Rd_Data_D1;
//             end
//             else begin  //To address overflow of the counter between Latency start and end 
//               //  Write_Latency_Int    <= ~(Wr_Latency_Fifo_Rd_Data_D1) +  Write_Latency_Cnt_Out_D2;
//             end
//          end
//          else begin
//           // Write_Latency_Int    <= Write_Latency_Int;
//            Write_Latency_En_Int <= 1'b0;
//          end
//       end
//    end

   assign Write_Latency    = Write_Latency_Int;     //Actual Latency
   assign Write_Latency_En = Write_Latency_En_Int; //Latency Valid
 reg Data_valid_reg,Data_valid_reg1,Data_valid_reg2;
 wire Data_valid_wire;
   always @(posedge clk) begin 
       if(rst_int_n == RST_ACTIVE) begin
          Data_valid_reg    <= 1'b0;
       end
       else begin
          Data_valid_reg    <= Data_Valid;
          Data_valid_reg1    <= Data_valid_reg;
          Data_valid_reg2    <= Data_valid_reg1;
       end
    end
  assign Data_valid_wire = Wr_Lat_Start?Data_valid_reg1:Data_valid_reg2;
  wire  Write_Lat_Cnt_en  = Metrics_Cnt_En_Int & Data_valid_wire; //Counter enable for ID based


    assign Min_Write_Latency = Min_Write_Latency_Int;

 
    assign Max_Write_Latency = Max_Write_Latency_Int;
    assign Wr_Latcnt_rst_n   = rst_int_n;
    assign Wr_cnt_ld           = ~(rst_int_n);

    //--Write latency counter
    //--Counter Instantiation
    //--This counter will be enabled only when id based latency is enabled
    axi_perf_mon_v5_0_12_counter_ovf 
    #(
         .C_FAMILY             ("nofamily"),
         .C_NUM_BITS           (C_METRIC_COUNT_WIDTH),
	      .COUNTER_LOAD_VALUE   (32'h00000000)
     ) wr_latency_cnt_inst 
     (
         .clk                  (clk),
         .rst_n                (Wr_Latcnt_rst_n),
         .Load_In              (Latency_Load_value),
         .Count_Enable         (Write_Lat_Cnt_en),
         .Count_Load           (Wr_cnt_ld),
         .Count_Down           (1'b0),
         .Count_Out            (Write_Latency_Cnt_Out),
         .Carry_Out            (Write_Latency_Cnt_Ovf)
     );


    //-- Read_going_on for First_Read_Flag generation
    //-- First read flag is only valid in case of id based latency
    always @(posedge clk) begin 
       if (rst_int_n == RST_ACTIVE) begin
           Read_going_on  <= 1'b0;
       end
       else begin
         if (Last_Read == 1'b1 && ((rid_match_int == 1'b1 && En_Id_Based == 1'b1) || En_Id_Based == 1'b0)) begin
             Read_going_on  <= 1'b0;
         end
         else if (First_Read == 1'b1 && ((rid_match_int == 1'b1 && En_Id_Based == 1'b1) || En_Id_Based == 1'b0)) begin 
             Read_going_on  <= 1'b1;
         end
         else begin
             Read_going_on  <= Read_going_on;
         end
       end
    end 

    //-- Read latency calculation based on ARID and RID's
    //-- Id's are coming from register interface
     always @(posedge clk) begin 
       if(rst_int_n == RST_ACTIVE) begin
           Rd_Latency_Fifo_Wr_En   <= 1'b0;
           Rd_Latency_Fifo_Wr_Data <= 0;
       end
       else begin   //ID Filtering/Masking/ignoring
           if(rd_latency_start == 1'b1 && ((arid_match == 1'b1 && En_Id_Based == 1'b1) || En_Id_Based == 1'b0)) begin
              Rd_Latency_Fifo_Wr_En   <= ~ Rd_Latency_Fifo_Full;
	     // if(Rd_cnt_ld == 1'b1) begin
        //        Rd_Latency_Fifo_Wr_Data <= ONE;
        //      end
	     // else begin
                Rd_Latency_Fifo_Wr_Data <= {Read_Latency_Cnt_Ovf,Read_Latency_Cnt_Out};
	     // end
           end
           else begin
              Rd_Latency_Fifo_Wr_En   <= 1'b0;
              Rd_Latency_Fifo_Wr_Data <= Rd_Latency_Fifo_Wr_Data;
           end
       end
    end

    // Reading the FIFO loaded with the count when read started 
   always @(posedge clk) begin 
       if(rst_int_n == RST_ACTIVE) begin
           Rd_Latency_Fifo_Rd_En      <= 1'b0;
           Rd_Latency_Fifo_Rd_En_D1   <= 1'b0;
           Rd_Latency_Fifo_Rd_En_D2   <= 1'b0;
           Read_Latency_Cnt_Out_D1    <= 0; 
           Read_Latency_Cnt_Out_D2    <= 0; 
           Read_Latency_One           <= 0;       //when read response comes with in one clock 
           Read_Latency_One_D1        <= 0;
           Rd_Latency_Fifo_Rd_Data_D1 <= 0;
       end
       else begin
           Rd_Latency_Fifo_Rd_En_D1   <= Rd_Latency_Fifo_Rd_En;
           Rd_Latency_Fifo_Rd_En_D2   <= Rd_Latency_Fifo_Rd_En_D1;
           Read_Latency_Cnt_Out_D1    <= {Read_Latency_Cnt_Ovf,Read_Latency_Cnt_Out}; 
           Read_Latency_Cnt_Out_D2    <= Read_Latency_Cnt_Out_D1; 
           Read_Latency_One_D1        <= Read_Latency_One & ~Rd_Latency_Fifo_Empty;
           Rd_Latency_Fifo_Rd_Data_D1 <= Rd_Latency_Fifo_Rd_Data;
           if(rd_latency_end == 1'b1 && ((rid_match == 1'b1 && En_Id_Based == 1'b1) || En_Id_Based == 1'b0)) begin
              Rd_Latency_Fifo_Rd_En   <=  ~Rd_Latency_Fifo_Empty;
              Read_Latency_One        <=   Rd_Latency_Fifo_Empty; 
           end
           else begin
              Rd_Latency_Fifo_Rd_En   <= 1'b0;
              Read_Latency_One        <= 0;    //when read response comes with in one clock 
           end
       end
    end

    assign Rd_Latency_Fifo_Rd_En_out = Rd_Latency_Fifo_Rd_En | Read_Latency_One_D1;

 //-- Rd latency FIFO Instance to store outstanding transactions
     axi_perf_mon_v5_0_12_sync_fifo 
     #(
        .WIDTH       (C_METRIC_COUNT_WIDTH+1), // The width of the FIFO data
        .DEPTH_LOG2  (5                   )  // Specify power-of-2 FIFO depth
     ) rd_latency_fifo_inst 
     (
       .rst_n    (rst_int_n),
       .clk      (clk),
       .wren     (Rd_Latency_Fifo_Wr_En & Metrics_Cnt_En_Int),
       .rden     (Rd_Latency_Fifo_Rd_En_out),
       .din      (Rd_Latency_Fifo_Wr_Data),
       .dout     (Rd_Latency_Fifo_Rd_Data),
       .full     (Rd_Latency_Fifo_Full),
       .empty    (Rd_Latency_Fifo_Empty)
     );
    
     // Read latency FIFO occupancy based on write and reads to FIFO
 //   always @(posedge clk) begin 
 //      if(rst_int_n == RST_ACTIVE) begin
 //          Rd_Latency_Occupancy   <= 0;
 //      end
 //      else begin
 //          if(rd_latency_start == 1'b1 && rd_latency_end == 1'b1 &&
 //            ((arid_match == 1'b1 && rid_match == 1'b1 && En_Id_Based == 1'b1) || En_Id_Based == 1'b0)) begin
 //            Rd_Latency_Occupancy   <= Rd_Latency_Occupancy;
 //          end
 //          else if(rd_latency_start==1'b1 && ((arid_match == 1'b1 && En_Id_Based == 1'b1) || En_Id_Based == 1'b0)) begin
 //             Rd_Latency_Occupancy   <= Rd_Latency_Occupancy + 1'b1;
 //          end
 //          else if(rd_latency_end == 1'b1 && ((rid_match == 1'b1 && En_Id_Based == 1'b1) || En_Id_Based == 1'b0)
 //                  && Rd_Latency_Occupancy != 0 ) begin 
 //             Rd_Latency_Occupancy   <= Rd_Latency_Occupancy - 1'b1;
 //          end
 //      end
 //   end

    //Overflow capture of read latency counter for better timing  
    //To address overflow of the counter between Latency start and end `
 //   always @(posedge clk) begin 
 //      if(rst_int_n == RST_ACTIVE) begin
 //         Read_Latency_Ovf <= 0;
 //      end
 //      else if(Rd_Latency_Fifo_Rd_En_D1 == 1'b1) begin
 //        if(Read_Latency_Cnt_Out_D1[C_METRIC_COUNT_WIDTH-1:0] < Rd_Latency_Fifo_Rd_Data[C_METRIC_COUNT_WIDTH-1:0]) begin
 //           Read_Latency_Ovf <= 1'b1;
 //        end
 //        else begin  
 //           Read_Latency_Ovf <= 1'b0; 
 //        end
 //      end
 //   end

    //Read latency capture from fifo read data with current counter value
    //-- TWO is for two clocks pipelining delay 1for Rd_Latency_Fifo_Rd_En_D2 and 1 for Read_Latency_Ovf 
    always @(posedge clk) begin 
       if(rst_int_n == RST_ACTIVE) begin
          Read_Latency_Int    <= 0;
          Read_Latency_En_Int <= 0;
       end
       else begin
          if(Read_Latency_One_D1 == 1'b1) begin
             Read_Latency_Int    <= ONE;
             Read_Latency_En_Int <= Metrics_Cnt_En_Int;
          end
          else if(Rd_Latency_Fifo_Rd_En_D1 == 1'b1) begin
         if(Read_Latency_Cnt_Out_D2[C_METRIC_COUNT_WIDTH] ^ Rd_Latency_Fifo_Rd_Data_D1[C_METRIC_COUNT_WIDTH]) begin
          if(Rd_Latency_Fifo_Rd_Data_D1[C_METRIC_COUNT_WIDTH-1:0] > Read_Latency_Cnt_Out_D2[C_METRIC_COUNT_WIDTH-1:0]) begin
              Read_Latency_Int  <= (~(Rd_Latency_Fifo_Rd_Data_D1[C_METRIC_COUNT_WIDTH-1:0]) + Read_Latency_Cnt_Out_D2[C_METRIC_COUNT_WIDTH-1:0])+1'b1;//:(F4_Rd_Data - F3_Rd_Data);;
          end else begin
              Read_Latency_Int <= (~Read_Latency_Cnt_Out_D2[C_METRIC_COUNT_WIDTH-1:0]) + Rd_Latency_Fifo_Rd_Data_D1[C_METRIC_COUNT_WIDTH-1:0]+1'b1;
          end
         end
        else begin
          if(Rd_Latency_Fifo_Rd_Data_D1[C_METRIC_COUNT_WIDTH-1:0] > Read_Latency_Cnt_Out_D2[C_METRIC_COUNT_WIDTH-1:0]) begin
             Read_Latency_Int  <= (Rd_Latency_Fifo_Rd_Data_D1[C_METRIC_COUNT_WIDTH-1:0] - Read_Latency_Cnt_Out_D2[C_METRIC_COUNT_WIDTH-1:0]);//:(F4_Rd_Data - F3_Rd_Data);;
          end else begin
            Read_Latency_Int  <= Read_Latency_Cnt_Out_D2[C_METRIC_COUNT_WIDTH-1:0] - Rd_Latency_Fifo_Rd_Data_D1[C_METRIC_COUNT_WIDTH-1:0];
          end
        end
                Read_Latency_En_Int <= Metrics_Cnt_En_Int;
        end
          else begin
            Read_Latency_Int    <= Read_Latency_Int;
            Read_Latency_En_Int <= 1'b0;
          end
       end
    end

    assign Read_Latency    = Read_Latency_Int;
    assign Read_Latency_En = Read_Latency_En_Int; 
 wire Read_Data_valid_wire;
  assign Read_Data_valid_wire = Rd_Lat_Start?Data_Valid:Data_valid_reg;
 
    wire Read_Lat_Cnt_en   = Metrics_Cnt_En_Int & Read_Data_valid_wire;

    //--Minimum read latency calculation
    //--Valid only for ID based latency
    always @(posedge clk) begin 
       if(rst_int_n == RST_ACTIVE) begin
          Min_Read_Latency_Int    <= ALL_ONES;
       end
       else begin
          if(Read_Latency_Int < Min_Read_Latency_Int && Read_Latency_En == 1'b1)begin
             Min_Read_Latency_Int    <= Read_Latency;
          end
          else begin
             Min_Read_Latency_Int    <= Min_Read_Latency_Int;
          end
       end
    end

    assign Min_Read_Latency = Min_Read_Latency_Int;

    //--Maximum read latency calculation
    //--Valid only for ID based latency
    always @(posedge clk) begin 
       if(rst_int_n == RST_ACTIVE) begin
          Max_Read_Latency_Int    <= 0;
       end
       else begin
          if(Read_Latency_Int > Max_Read_Latency_Int && Read_Latency_En == 1'b1)begin
             Max_Read_Latency_Int    <= Read_Latency;
          end
          else begin
             Max_Read_Latency_Int    <= Max_Read_Latency_Int;
          end
       end
    end
 
    assign Max_Read_Latency = Max_Read_Latency_Int;
    assign Rd_Latcnt_rst_n  = rst_int_n; 
    assign Rd_cnt_ld        = ~ (rst_int_n);//(|(Rd_Latency_Occupancy));

    //--Read latency counter
    //--Counter Instantiation
    axi_perf_mon_v5_0_12_counter_ovf 
    #(
         .C_FAMILY             ("nofamily"),
         .C_NUM_BITS           (C_METRIC_COUNT_WIDTH),
	      .COUNTER_LOAD_VALUE   (32'h00000000)
     ) rd_latency_cnt_inst 
     (
         .clk                  (clk),
         .rst_n                (Rd_Latcnt_rst_n),
         .Load_In              (Latency_Load_value),
         .Count_Enable         (Read_Lat_Cnt_en),
         .Count_Load           (Rd_cnt_ld),
         .Count_Down           (1'b0),
         .Count_Out            (Read_Latency_Cnt_Out),
         .Carry_Out            (Read_Latency_Cnt_Ovf)
     );

    /*------------------Registering all AXIMM metrics ------------------*/
generate if(C_AXI_SUB_PROTOCOL != "AXI4LITE") begin : GEN_ARSIZE_AXI4
    always @(posedge clk) begin 
       if (rst_int_n == RST_ACTIVE) begin
           Wtrans_Cnt_En     <= 1'b0;
           Rtrans_Cnt_En     <= 1'b0;
          // Write_Beat_Cnt_En <= 1'b0;
           Read_Beat_Cnt_En  <= 1'b0;
          // Slv_Wr_Idle_Cnt_En<= 1'b0;
           Mst_Rd_Idle_Cnt_En<= 1'b0; 
           Num_BValids_En    <= 1'b0;
           Num_RLasts_En     <= 1'b0;
         // Num_WLasts_En     <= 1'b0;
         // Write_Byte_Cnt    <= 0;
           Read_Byte_Cnt     <= 0; 
           Read_Byte_Cnt_En  <= 0; 
       end
       else begin
           Wtrans_Cnt_En     <=  Wr_Addr_Lat &  Metrics_Cnt_En_Int & ((awid_match_lat & En_Id_Based) || (~En_Id_Based));
           Rtrans_Cnt_En     <=  Rd_Addr_Lat &  Metrics_Cnt_En_Int & ((arid_match_lat & En_Id_Based) || (~En_Id_Based));
          // Write_Beat_Cnt_En <= Write_Beat_reg & Metrics_Cnt_En_Int & wid_match_reg_d2;// || Wr_Id_Fifo_Rd_Data) & En_Id_Based) || (~En_Id_Based));
           Read_Beat_Cnt_En  <= Read_Beat & Metrics_Cnt_En_Int & ((rid_match_int & En_Id_Based) || (~En_Id_Based));
          // Slv_Wr_Idle_Cnt_En<= Wr_Idle_reg & Metrics_Cnt_En_Int & wid_match_reg_d2;// & En_Id_Based) || (~En_Id_Based));
           Mst_Rd_Idle_Cnt_En<= Rd_Idle & Metrics_Cnt_En_Int & ((rid_match_int & En_Id_Based) || (~En_Id_Based)); 
           Num_BValids_En    <=  Response & Metrics_Cnt_En_Int & ((bid_match & En_Id_Based) || (~En_Id_Based));
          // Num_WLasts_En     <= Last_Write_reg & Metrics_Cnt_En_Int & wid_match_reg_d2;// || Wr_Id_Fifo_Rd_Data) & En_Id_Based) || (~En_Id_Based)); 
           Num_RLasts_En     <=  Last_Read & Metrics_Cnt_En_Int & ((rid_match_int & En_Id_Based) || (~En_Id_Based));
          // Write_Byte_Cnt    <= wr_byte_cnt_reg;
          if(Metrics_Cnt_En_Int == 1'b1) begin
          Read_Byte_Cnt     <= F1_ARSIZE * num_rd_beats;//rd_byte_cnt ; 
          Read_Byte_Cnt_En  <= Last_Read_buf;
          end
          //else begin
          //Read_Byte_Cnt     <= 0; 
          //Read_Byte_Cnt_En  <= 0;   
          //end 

       end
    end
    end
    endgenerate
generate if(C_AXI_SUB_PROTOCOL == "AXI4LITE") begin : GEN_ARSIZE_F1
    always @(posedge clk) begin 
       if (rst_int_n == RST_ACTIVE) begin
           Wtrans_Cnt_En     <= 1'b0;
           Rtrans_Cnt_En     <= 1'b0;
          // Write_Beat_Cnt_En <= 1'b0;
           Read_Beat_Cnt_En  <= 1'b0;
          // Slv_Wr_Idle_Cnt_En<= 1'b0;
           Mst_Rd_Idle_Cnt_En<= 1'b0; 
           Num_BValids_En    <= 1'b0;
           Num_RLasts_En     <= 1'b0;
         // Num_WLasts_En     <= 1'b0;
         // Write_Byte_Cnt    <= 0;
           Read_Byte_Cnt     <= 0; 
           Read_Byte_Cnt_En  <= 0; 
       end
       else begin
           Wtrans_Cnt_En     <=  Wr_Addr_Lat &  Metrics_Cnt_En_Int & ((awid_match_lat & En_Id_Based) || (~En_Id_Based));
           Rtrans_Cnt_En     <=  Rd_Addr_Lat &  Metrics_Cnt_En_Int & ((arid_match_lat & En_Id_Based) || (~En_Id_Based));
          // Write_Beat_Cnt_En <= Write_Beat_reg & Metrics_Cnt_En_Int & wid_match_reg_d2;// || Wr_Id_Fifo_Rd_Data) & En_Id_Based) || (~En_Id_Based));
           Read_Beat_Cnt_En  <= Read_Beat & Metrics_Cnt_En_Int & ((rid_match_int & En_Id_Based) || (~En_Id_Based));
          // Slv_Wr_Idle_Cnt_En<= Wr_Idle_reg & Metrics_Cnt_En_Int & wid_match_reg_d2;// & En_Id_Based) || (~En_Id_Based));
           Mst_Rd_Idle_Cnt_En<= Rd_Idle & Metrics_Cnt_En_Int & ((rid_match_int & En_Id_Based) || (~En_Id_Based)); 
           Num_BValids_En    <=  Response & Metrics_Cnt_En_Int & ((bid_match & En_Id_Based) || (~En_Id_Based));
          // Num_WLasts_En     <= Last_Write_reg & Metrics_Cnt_En_Int & wid_match_reg_d2;// || Wr_Id_Fifo_Rd_Data) & En_Id_Based) || (~En_Id_Based)); 
           Num_RLasts_En     <=  Last_Read & Metrics_Cnt_En_Int & ((rid_match_int & En_Id_Based) || (~En_Id_Based));
          // Write_Byte_Cnt    <= wr_byte_cnt_reg;
          Read_Byte_Cnt     <= rd_byte_cnt ; 
          Read_Byte_Cnt_En  <= Read_Beat & Metrics_Cnt_En_Int & ((rid_match_int & En_Id_Based) || (~En_Id_Based));
          
       end
    end

    end
    endgenerate

    
/*------------------Registering Beat Count metric  for all scenarios------------------*/
 reg [C_METRIC_COUNT_WIDTH-1:0] Write_Beat_Cnt_i;  
 reg [C_METRIC_COUNT_WIDTH-1:0] Write_Byte_Cnt_i;  
 reg Beat_fifo_Wr_en;  
 reg [(C_METRIC_COUNT_WIDTH*2)-1:0] Beat_fifo_Wr_data;  
 wire [(C_METRIC_COUNT_WIDTH*2)-1:0] FBC1_Rd_Data;  
 wire FBC1_Empty;  
 wire FBC_Empty;  
 wire FBC_Rd_Data;  
  always @(posedge clk) begin 
       if (rst_int_n == RST_ACTIVE) begin
           Write_Beat_Cnt_i     <= { {31{1'b0}}, 1'b1 };
           Write_Byte_Cnt_i     <= zeros;
           Beat_fifo_Wr_en <= 1'b0;
       end
       else begin
           if(Last_Write_d1) begin
           Beat_fifo_Wr_en <= 1'b1;
           Beat_fifo_Wr_data <= {(Write_Byte_Cnt_i+wr_byte_cnt_d1),Write_Beat_Cnt_i};
           Write_Byte_Cnt_i     <=  zeros;
           Write_Beat_Cnt_i     <=  { {31{1'b0}}, 1'b1 };
           end
           else if(Write_Beat_d1) begin
           Beat_fifo_Wr_en <= 1'b0;
           Write_Beat_Cnt_i     <=  Write_Beat_Cnt_i+1'b1;
           Write_Byte_Cnt_i     <=  Write_Byte_Cnt_i+wr_byte_cnt_d1;
          end
          else
           Beat_fifo_Wr_en <= 1'b0;
    end 
  end
    axi_perf_mon_v5_0_12_sync_fifo 
     #(
        .WIDTH      (C_METRIC_COUNT_WIDTH*2),
        .DEPTH_LOG2 (5)
     ) FBC_WR_BEAT_CNT
     (
       .rst_n    (rst_int_n),
       .clk      (clk),
       .wren     (Beat_fifo_Wr_en & Metrics_Cnt_En_Int ),
       .rden     (FBC_Rd_En   ),
       .din      (Beat_fifo_Wr_data ),
       .dout     (FBC1_Rd_Data ),
       .full     (           ),
       .empty    (FBC1_Empty   )
     );

//assign F1_Wr_En   = Wr_Add_Issue;//wr_latency_start; 
//assign F1_Wr_Data = awid_match_d1 || ~(En_Id_Based);
   axi_perf_mon_v5_0_12_sync_fifo 
     #(
        .WIDTH      (1), 
        .DEPTH_LOG2 (5) 
     ) BEAT_CNT_AWID_MATCH
     (
       .rst_n    (rst_int_n),
       .clk      (clk),
       .wren     (F1_Wr_En   ),
       .rden     (FBC_Rd_En   ),
       .din      (F1_Wr_Data ),
       .dout     (FBC_Rd_Data ),
       .full     (           ),
       .empty    (FBC_Empty   )
     );
assign FBC_Rd_En = (FBC1_Empty == 1'b0) && (FBC_Empty == 1'b0);

reg FBC_Rd_Vld;
  always @(posedge clk) begin
    if (rst_int_n == RST_ACTIVE) begin
        FBC_Rd_Vld <= 1'b0;
    end else begin
        FBC_Rd_Vld <= FBC_Rd_En;
    end
  end

assign Write_Beat_Cnt_En = (FBC_Rd_Vld)? FBC_Rd_Data: 1'b0;
assign Write_Beat_Cnt = (FBC_Rd_Vld)? FBC1_Rd_Data[C_METRIC_COUNT_WIDTH-1:0]: zeros;
assign Write_Byte_Cnt = (FBC_Rd_Vld)? FBC1_Rd_Data[(C_METRIC_COUNT_WIDTH*2)-1:C_METRIC_COUNT_WIDTH]: zeros;

 /*------------------Registering write last Count metric for all scenarios------------------*/
// reg Lw;  
 reg [C_METRIC_COUNT_WIDTH-1:0] Write_Last_Cnt_i;  
 reg Last_fifo_Wr_en;  
 wire FWL1_Rd_Data;  
 wire FWL1_Empty;  
 wire FWL_Empty;  
 wire FWL_Rd_Data;  
  always @(posedge clk) begin 
       if (rst_int_n == RST_ACTIVE) begin
           Last_fifo_Wr_en <= 1'b0;
       end
       else begin
          if(Last_Write) begin
           Last_fifo_Wr_en <= 1'b1;
           end
           else begin
           Last_fifo_Wr_en <= 1'b0;
           end
       end
    end 

    axi_perf_mon_v5_0_12_sync_fifo 
     #(
        .WIDTH      (1),
        .DEPTH_LOG2 (5)
     ) FWL_WR_LAST_CNT
     (
       .rst_n    (rst_int_n),
       .clk      (clk),
       .wren     (Last_fifo_Wr_en & Metrics_Cnt_En_Int ),
       .rden     (FWL_Rd_En   ),
       .din      (1'b1 ),
       .dout     (FWL1_Rd_Data ),
       .full     (           ),
       .empty    (FWL1_Empty   )
     );

//assign F1_Wr_En   = Wr_Add_Issue;//wr_latency_start; 
//assign F1_Wr_Data = awid_match_d1 || ~(En_Id_Based);
   axi_perf_mon_v5_0_12_sync_fifo 
     #(
        .WIDTH      (1), 
        .DEPTH_LOG2 (5) 
     ) LAST_CNT_AWID_MATCH
     (
       .rst_n    (rst_int_n),
       .clk      (clk),
       .wren     (F1_Wr_En   ),
       .rden     (FWL_Rd_En   ),
       .din      (F1_Wr_Data ),
       .dout     (FWL_Rd_Data ),
       .full     (           ),
       .empty    (FWL_Empty   )
     );
assign FWL_Rd_En = (FWL1_Empty == 1'b0) && (FWL_Empty == 1'b0);

reg FWL_Rd_Vld;
  always @(posedge clk) begin
    if (rst_int_n == RST_ACTIVE) begin
        FWL_Rd_Vld <= 1'b0;
    end else begin
        FWL_Rd_Vld <= FWL_Rd_En;
    end
  end

assign Num_WLasts_En = (FWL_Rd_Vld)? FWL_Rd_Data: 1'b0;
//assign Num_WLasts = (FWL_Rd_Vld)? FWL1_Rd_Data: zeros;

 /*------------------Registering Slave Write Idle Count metric  for all scenarios------------------*/
// reg Lw;  
 reg [C_METRIC_COUNT_WIDTH-1:0] Slv_Wr_Idle_Cnt_i;  
 reg [C_METRIC_COUNT_WIDTH-1:0] Slv_Wr_Idle_Fifo_Wr_data;  
 wire [C_METRIC_COUNT_WIDTH-1:0] FSWI1_Rd_Data;  
 wire FSWI1_Empty;  
 wire FSWI_Empty;  
 wire FSWI_Rd_Data;  
 reg Slv_Wr_Idle_Fifo_Wr_en;  
  always @(posedge clk) begin 
       if (rst_int_n == RST_ACTIVE) begin
           Slv_Wr_Idle_Cnt_i     <= zeros;//{ {31{1'b0}}, 1'b1 };
           Slv_Wr_Idle_Fifo_Wr_en <= 1'b0;
       end
       else begin
           if(Last_Write) begin
           Slv_Wr_Idle_Fifo_Wr_en <= 1'b1;
           Slv_Wr_Idle_Fifo_Wr_data <= Slv_Wr_Idle_Cnt_i;
           Slv_Wr_Idle_Cnt_i     <=  zeros;
           end
           else if(Wr_Idle) begin
           Slv_Wr_Idle_Fifo_Wr_en <= 1'b0;
           Slv_Wr_Idle_Cnt_i     <=  Slv_Wr_Idle_Cnt_i+1'b1;
           end
           else 
           Slv_Wr_Idle_Fifo_Wr_en <= 1'b0;
       end
    end 

    axi_perf_mon_v5_0_12_sync_fifo 
     #(
        .WIDTH      (C_METRIC_COUNT_WIDTH),
        .DEPTH_LOG2 (5)
     ) FSWI_WR_LAST_CNT
     (
       .rst_n    (rst_int_n),
       .clk      (clk),
       .wren     (Slv_Wr_Idle_Fifo_Wr_en & Metrics_Cnt_En_Int ),
       .rden     (FSWI_Rd_En   ),
       .din      (Slv_Wr_Idle_Fifo_Wr_data ),
       .dout     (FSWI1_Rd_Data ),
       .full     (           ),
       .empty    (FSWI1_Empty   )
     );

//assign F1_Wr_En   = Wr_Add_Issue;//wr_latency_start; 
//assign F1_Wr_Data = awid_match_d1 || ~(En_Id_Based);
   axi_perf_mon_v5_0_12_sync_fifo 
     #(
        .WIDTH      (1), 
        .DEPTH_LOG2 (5) 
     ) IDLE_CNT_AWID_MATCH
     (
       .rst_n    (rst_int_n),
       .clk      (clk),
       .wren     (F1_Wr_En   ),
       .rden     (FSWI_Rd_En   ),
       .din      (F1_Wr_Data ),
       .dout     (FSWI_Rd_Data ),
       .full     (           ),
       .empty    (FSWI_Empty   )
     );
assign FSWI_Rd_En = (FSWI1_Empty == 1'b0) && (FSWI_Empty == 1'b0);

reg FSWI_Rd_Vld;
  always @(posedge clk) begin
    if (rst_int_n == RST_ACTIVE) begin
        FSWI_Rd_Vld <= 1'b0;
    end else begin
        FSWI_Rd_Vld <= FSWI_Rd_En;
    end
  end

assign Slv_Wr_Idle_Cnt_En = (FSWI_Rd_Vld)? FSWI_Rd_Data: 1'b0;
assign Slv_Wr_Idle_Cnt = (FSWI_Rd_Vld)? FSWI1_Rd_Data: zeros;

    //-- AXI Streaming Imp Events generation 
    wire Stream_Write = TVALID & TREADY & Data_Valid;
    wire Stream_Last_Write  = TLAST & TVALID & TREADY & Data_Valid;
    wire Slave_Idle = TVALID & ~(TREADY) & Data_Valid;
    wire Master_Idle = ~(TVALID) & TREADY & Data_Valid; 
    wire [C_AXISDATA/8-1:0] data_strb = TSTRB & TKEEP;
    wire [C_AXISDATA/8-1:0] pos_strb = ~(TSTRB) & TKEEP;
    wire [C_AXISDATA/8-1:0] null_strb = ~(TSTRB) & ~(TKEEP);

     // Data, Postional and null byte counts for different widths of the streaming data bus 
    generate if(C_AXISDATA == 8 || C_AXISDATA == 16) begin : GEN_AXIS_BYTECNT
       assign data_byte_cnt =count(data_strb);
       assign pos_byte_cnt  =count(pos_strb);
       assign null_byte_cnt =count(null_strb);
    end
    endgenerate

    generate if(C_AXISDATA == 32) begin : GEN_AXIS32BIT_BYTECNT
       assign data_byte_cnt ={zeros[C_METRIC_COUNT_WIDTH-1:3],count_4(data_strb)};
       assign pos_byte_cnt  ={zeros[C_METRIC_COUNT_WIDTH-1:3],count_4(pos_strb)};
       assign null_byte_cnt ={zeros[C_METRIC_COUNT_WIDTH-1:3],count_4(null_strb)};
    end
    endgenerate

    generate if(C_AXISDATA == 64) begin : GEN_AXIS64BIT_BYTECNT
       assign data_byte_cnt ={zeros[C_METRIC_COUNT_WIDTH-1:4],count_8(data_strb)};
       assign pos_byte_cnt  ={zeros[C_METRIC_COUNT_WIDTH-1:4],count_8(pos_strb)};
       assign null_byte_cnt ={zeros[C_METRIC_COUNT_WIDTH-1:4],count_8(null_strb)};
    end
    endgenerate

    generate if(C_AXISDATA == 128) begin : GEN_AXIS128BIT_BYTECNT
       assign data_byte_cnt ={zeros[C_METRIC_COUNT_WIDTH-1:5],count_16(data_strb)};
       assign pos_byte_cnt  ={zeros[C_METRIC_COUNT_WIDTH-1:5],count_16(pos_strb)};
       assign null_byte_cnt ={zeros[C_METRIC_COUNT_WIDTH-1:5],count_16(null_strb)};
    end
    endgenerate

    generate if(C_AXISDATA == 256) begin : GEN_AXIS256BIT_BYTECNT
       assign data_byte_cnt ={zeros[C_METRIC_COUNT_WIDTH-1:6],count_32(data_strb)};
       assign pos_byte_cnt  ={zeros[C_METRIC_COUNT_WIDTH-1:6],count_32(pos_strb)};
       assign null_byte_cnt ={zeros[C_METRIC_COUNT_WIDTH-1:6],count_32(null_strb)};
    end
    endgenerate

    generate if(C_AXISDATA == 512) begin : GEN_AXIS512BIT_BYTECNT
       assign data_byte_cnt ={zeros[C_METRIC_COUNT_WIDTH-1:7],count_64(data_strb)};
       assign pos_byte_cnt  ={zeros[C_METRIC_COUNT_WIDTH-1:7],count_64(pos_strb)};
       assign null_byte_cnt ={zeros[C_METRIC_COUNT_WIDTH-1:7],count_64(null_strb)};

    end
    endgenerate

    generate if(C_AXISDATA == 1024) begin : GEN_AXIS1024BIT_BYTECNT
       assign data_byte_cnt ={zeros[C_METRIC_COUNT_WIDTH-1:8],count_128(data_strb)};
       assign pos_byte_cnt  ={zeros[C_METRIC_COUNT_WIDTH-1:8],count_128(pos_strb)};
       assign null_byte_cnt ={zeros[C_METRIC_COUNT_WIDTH-1:8],count_128(null_strb)};
    end
    endgenerate

   
     /*------------------Registering all streaming metrics ------------------*/
    always @(posedge clk) begin 
       if (rst_int_n == RST_ACTIVE) begin
          S_Transfer_Cnt_En   <= 1'b0;
          S_Packet_Cnt_En     <= 1'b0;
          S_Slv_Idle_Cnt_En   <= 1'b0;
          S_Mst_Idle_Cnt_En   <= 1'b0;
          S_Data_Byte_Cnt     <= 0;
          S_Position_Byte_Cnt <= 0;
          S_Null_Byte_Cnt     <= 0;
       end
       else begin
          S_Transfer_Cnt_En   <= Stream_Write & Metrics_Cnt_En_Int;
          S_Packet_Cnt_En     <= Stream_Last_Write & Metrics_Cnt_En_Int;
          S_Slv_Idle_Cnt_En   <= Slave_Idle & Metrics_Cnt_En_Int;
          S_Mst_Idle_Cnt_En   <= Master_Idle & Metrics_Cnt_En_Int;
          S_Data_Byte_Cnt     <= (Data_Valid == 1'b1)?data_byte_cnt:0;
          S_Position_Byte_Cnt <= (Data_Valid == 1'b1)?pos_byte_cnt:0;
          S_Null_Byte_Cnt     <= (Data_Valid == 1'b1)?null_byte_cnt:0;
       end
    end 


endmodule


//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename     : axi_perf_mon_v5_0_12_metric_counters.v
// Version      : v5.0
// Description  : Metric counter module instantiates the metric selection
//                and accumulator and incrementor modules based on the
//                number of metric counts required 
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
//  axi_perf_mon.v
//      \--
//      \-- axi_perf_mon_v5_0_12_metric_counters.v
//
//-----------------------------------------------------------------------------
// Author:    Kalpanath
// History: 
// Kalpanath 07/25/2012      First Version  
// ~~~~~~
// NLR       10/10/2012      Updated to have eight monitor slots metric selection
// ~~~~~~
//-----------------------------------------------------------------------------
`timescale 1ns/1ps
module axi_perf_mon_v5_0_12_metric_counters 
#(
   parameter                       C_FAMILY             = "virtex7",
   parameter                       C_NUM_MONITOR_SLOTS  = 8,
   parameter                       C_ENABLE_EVENT_COUNT = 1,  //-- enables/disables perf mon counting logic
   parameter                       C_NUM_OF_COUNTERS    = 10,
   parameter                       C_METRIC_COUNT_WIDTH = 32,  //-- enables/disables perf mon counting logic
   parameter                       C_METRIC_COUNT_SCALE = 1,
   parameter                       COUNTER_LOAD_VALUE   = 32'h00000000  

)
(
   input                            clk,
   input                            rst_n,

    //-- AXI4 metrics
   input [C_NUM_MONITOR_SLOTS-1:0]  Wtrans_Cnt_En,
   input [C_NUM_MONITOR_SLOTS-1:0]  Rtrans_Cnt_En,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Slv_Wr_Idle_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Slv_Wr_Idle_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Slv_Wr_Idle_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Slv_Wr_Idle_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Slv_Wr_Idle_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Slv_Wr_Idle_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Slv_Wr_Idle_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Slv_Wr_Idle_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Write_Beat_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Write_Beat_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Write_Beat_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Write_Beat_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Write_Beat_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Write_Beat_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Write_Beat_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Write_Beat_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Read_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Read_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Read_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Read_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Read_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Read_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Read_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Read_Byte_Cnt,
   input                            S0_Read_Byte_Cnt_En,
   input                            S1_Read_Byte_Cnt_En,
   input                            S2_Read_Byte_Cnt_En,
   input                            S3_Read_Byte_Cnt_En,
   input                            S4_Read_Byte_Cnt_En,
   input                            S5_Read_Byte_Cnt_En,
   input                            S6_Read_Byte_Cnt_En,
   input                            S7_Read_Byte_Cnt_En,
   input [C_NUM_MONITOR_SLOTS-1:0]  Write_Beat_Cnt_En,
   input [C_NUM_MONITOR_SLOTS-1:0]  Read_Beat_Cnt_En,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Write_Latency,
   input [C_NUM_MONITOR_SLOTS-1:0]  Read_Latency_En,        
   input [C_NUM_MONITOR_SLOTS-1:0]  Write_Latency_En,        
   input [C_NUM_MONITOR_SLOTS-1:0]  Slv_Wr_Idle_Cnt_En,        
   input [C_NUM_MONITOR_SLOTS-1:0]  Mst_Rd_Idle_Cnt_En,        
   input [C_NUM_MONITOR_SLOTS-1:0]  Num_BValids_En,       
   input [C_NUM_MONITOR_SLOTS-1:0]  Num_WLasts_En,             
   input [C_NUM_MONITOR_SLOTS-1:0]  Num_RLasts_En,      

   //-- AXI Streaming metrics
   input [C_NUM_MONITOR_SLOTS-1:0]  S_Transfer_Cnt_En,
   input [C_NUM_MONITOR_SLOTS-1:0]  S_Packet_Cnt_En,  
   input [C_METRIC_COUNT_WIDTH-1:0] S0_S_Data_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_S_Data_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_S_Data_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_S_Data_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_S_Data_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_S_Data_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_S_Data_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_S_Data_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_S_Position_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_S_Position_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_S_Position_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_S_Position_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_S_Position_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_S_Position_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_S_Position_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_S_Position_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_S_Null_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_S_Null_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_S_Null_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_S_Null_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_S_Null_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_S_Null_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_S_Null_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_S_Null_Byte_Cnt,
   input [C_NUM_MONITOR_SLOTS-1:0]  S_Slv_Idle_Cnt_En,
   input [C_NUM_MONITOR_SLOTS-1:0]  S_Mst_Idle_Cnt_En,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Max_Write_Latency,                 
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Max_Write_Latency,                 
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Max_Write_Latency,         
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Max_Write_Latency,         
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Max_Write_Latency,         
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Max_Write_Latency,         
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Max_Write_Latency,         
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Max_Write_Latency,         
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Min_Write_Latency,       
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Min_Write_Latency,       
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Min_Write_Latency,       
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Min_Write_Latency,       
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Min_Write_Latency,       
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Min_Write_Latency,       
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Min_Write_Latency,       
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Min_Write_Latency,       
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Max_Read_Latency,     
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Max_Read_Latency,                 
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Max_Read_Latency,                 
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Max_Read_Latency,                 
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Max_Read_Latency,                 
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Max_Read_Latency,                 
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Max_Read_Latency,                 
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Max_Read_Latency,                 
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Min_Read_Latency,            
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Min_Read_Latency,            
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Min_Read_Latency,            
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Min_Read_Latency,            
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Min_Read_Latency,            
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Min_Read_Latency,            
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Min_Read_Latency,            
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Min_Read_Latency,           
   //-- External Events
   input [C_NUM_MONITOR_SLOTS-1:0]  External_Event_Cnt_En,

   //-- Cnt Enable and Reset
   input                            Metrics_Cnt_En,
   input                            Metrics_Cnt_Reset,

   // Metric Selector Registers - in axi clk domain
   input  [7:0]                     Metric_Sel_0,    
   input  [7:0]                     Metric_Sel_1,    
   input  [7:0]                     Metric_Sel_2,    
   input  [7:0]                     Metric_Sel_3,    
   input  [7:0]                     Metric_Sel_4,    
   input  [7:0]                     Metric_Sel_5,    
   input  [7:0]                     Metric_Sel_6,    
   input  [7:0]                     Metric_Sel_7,    
   input  [7:0]                     Metric_Sel_8,    
   input  [7:0]                     Metric_Sel_9,    

   // Range Registers - in axi clk domain
   input  [31:0]                    Range_Reg_0,    
   input  [31:0]                    Range_Reg_1,    
   input  [31:0]                    Range_Reg_2,    
   input  [31:0]                    Range_Reg_3,    
   input  [31:0]                    Range_Reg_4,    
   input  [31:0]                    Range_Reg_5,    
   input  [31:0]                    Range_Reg_6,    
   input  [31:0]                    Range_Reg_7,    
   input  [31:0]                    Range_Reg_8,    
   input  [31:0]                    Range_Reg_9,    

   // Metric Counters - in core clk domain
   output [31:0]                    Metric_Cnt_0,    
   output [31:0]                    Metric_Cnt_1,    
   output [31:0]                    Metric_Cnt_2,    
   output [31:0]                    Metric_Cnt_3,    
   output [31:0]                    Metric_Cnt_4,    
   output [31:0]                    Metric_Cnt_5,    
   output [31:0]                    Metric_Cnt_6,    
   output [31:0]                    Metric_Cnt_7,    
   output [31:0]                    Metric_Cnt_8,    
   output [31:0]                    Metric_Cnt_9,    

   // Incrementers in core clk domain
   output [31:0]                    Incrementer_0,    
   output [31:0]                    Incrementer_1,    
   output [31:0]                    Incrementer_2,    
   output [31:0]                    Incrementer_3,    
   output [31:0]                    Incrementer_4,    
   output [31:0]                    Incrementer_5,    
   output [31:0]                    Incrementer_6,    
   output [31:0]                    Incrementer_7,    
   output [31:0]                    Incrementer_8,    
   output [31:0]                    Incrementer_9,    

   // OverFlows
   output                           Acc_OF_0,    
   output                           Acc_OF_1,    
   output                           Acc_OF_2,    
   output                           Acc_OF_3,    
   output                           Acc_OF_4,    
   output                           Acc_OF_5,    
   output                           Acc_OF_6,    
   output                           Acc_OF_7,    
   output                           Acc_OF_8,    
   output                           Acc_OF_9,    

   output                           Incr_OF_0,    
   output                           Incr_OF_1,    
   output                           Incr_OF_2,    
   output                           Incr_OF_3,    
   output                           Incr_OF_4,    
   output                           Incr_OF_5,    
   output                           Incr_OF_6,    
   output                           Incr_OF_7,    
   output                           Incr_OF_8,    
   output                           Incr_OF_9    
);


//-------------------------------------------------------------------
// Parameter Declaration
//-------------------------------------------------------------------
localparam RST_ACTIVE = 1'b0;

//-------------------------------------------------------------------
// Begin architecture
//-------------------------------------------------------------------


//-- Mux n Metric Counter_0
axi_perf_mon_v5_0_12_metric_sel_n_cnt 
  #(
       .C_FAMILY             (C_FAMILY),
       .C_NUM_MONITOR_SLOTS  (C_NUM_MONITOR_SLOTS), 
       .C_ENABLE_EVENT_COUNT (C_ENABLE_EVENT_COUNT),
       .C_METRIC_COUNT_WIDTH (C_METRIC_COUNT_WIDTH),
       .C_METRIC_COUNT_SCALE (C_METRIC_COUNT_SCALE),
       .COUNTER_LOAD_VALUE   (COUNTER_LOAD_VALUE)  

   ) axi_perf_mon_v5_0_12_metric_sel_n_cnt_inst_0 
   (
       .clk                    (clk),
       .rst_n                  (rst_n),
       .Wtrans_Cnt_En          (Wtrans_Cnt_En),
       .Rtrans_Cnt_En          (Rtrans_Cnt_En),
       .S0_Write_Byte_Cnt      (S0_Write_Byte_Cnt),
       .S1_Write_Byte_Cnt      (S1_Write_Byte_Cnt),
       .S2_Write_Byte_Cnt      (S2_Write_Byte_Cnt),
       .S3_Write_Byte_Cnt      (S3_Write_Byte_Cnt),
       .S4_Write_Byte_Cnt      (S4_Write_Byte_Cnt),
       .S5_Write_Byte_Cnt      (S5_Write_Byte_Cnt),
       .S6_Write_Byte_Cnt      (S6_Write_Byte_Cnt),
       .S7_Write_Byte_Cnt      (S7_Write_Byte_Cnt),
       .S0_Slv_Wr_Idle_Cnt      (S0_Slv_Wr_Idle_Cnt),
       .S1_Slv_Wr_Idle_Cnt      (S1_Slv_Wr_Idle_Cnt),
       .S2_Slv_Wr_Idle_Cnt      (S2_Slv_Wr_Idle_Cnt),
       .S3_Slv_Wr_Idle_Cnt      (S3_Slv_Wr_Idle_Cnt),
       .S4_Slv_Wr_Idle_Cnt      (S4_Slv_Wr_Idle_Cnt),
       .S5_Slv_Wr_Idle_Cnt      (S5_Slv_Wr_Idle_Cnt),
       .S6_Slv_Wr_Idle_Cnt      (S6_Slv_Wr_Idle_Cnt),
       .S7_Slv_Wr_Idle_Cnt      (S7_Slv_Wr_Idle_Cnt),
       .S0_Read_Byte_Cnt       (S0_Read_Byte_Cnt),
     .S0_Read_Byte_Cnt_En       (S0_Read_Byte_Cnt_En),
       .S1_Read_Byte_Cnt       (S1_Read_Byte_Cnt),
       .S1_Read_Byte_Cnt_En       (S1_Read_Byte_Cnt_En),
       .S2_Read_Byte_Cnt       (S2_Read_Byte_Cnt),
       .S2_Read_Byte_Cnt_En       (S2_Read_Byte_Cnt_En),
       .S3_Read_Byte_Cnt       (S3_Read_Byte_Cnt),
       .S3_Read_Byte_Cnt_En       (S3_Read_Byte_Cnt_En),
       .S4_Read_Byte_Cnt       (S4_Read_Byte_Cnt),
       .S4_Read_Byte_Cnt_En       (S4_Read_Byte_Cnt_En),
       .S5_Read_Byte_Cnt       (S5_Read_Byte_Cnt),
       .S5_Read_Byte_Cnt_En       (S5_Read_Byte_Cnt_En),
       .S6_Read_Byte_Cnt       (S6_Read_Byte_Cnt),
       .S6_Read_Byte_Cnt_En       (S6_Read_Byte_Cnt_En),
       .S7_Read_Byte_Cnt       (S7_Read_Byte_Cnt),
       .S7_Read_Byte_Cnt_En       (S7_Read_Byte_Cnt_En),
       .S0_Write_Beat_Cnt       (S0_Write_Beat_Cnt),
       .S1_Write_Beat_Cnt       (S1_Write_Beat_Cnt),
       .S2_Write_Beat_Cnt       (S2_Write_Beat_Cnt),
       .S3_Write_Beat_Cnt       (S3_Write_Beat_Cnt),
       .S4_Write_Beat_Cnt       (S4_Write_Beat_Cnt),
       .S5_Write_Beat_Cnt       (S5_Write_Beat_Cnt),
       .S6_Write_Beat_Cnt       (S6_Write_Beat_Cnt),
       .S7_Write_Beat_Cnt       (S7_Write_Beat_Cnt),
       .Write_Beat_Cnt_En      (Write_Beat_Cnt_En),
       .Read_Beat_Cnt_En       (Read_Beat_Cnt_En),
       .S0_Read_Latency        (S0_Read_Latency),
       .S1_Read_Latency        (S1_Read_Latency),
       .S2_Read_Latency        (S2_Read_Latency),
       .S3_Read_Latency        (S3_Read_Latency),
       .S4_Read_Latency        (S4_Read_Latency),
       .S5_Read_Latency        (S5_Read_Latency),
       .S6_Read_Latency        (S6_Read_Latency),
       .S7_Read_Latency        (S7_Read_Latency),
       .S0_Write_Latency       (S0_Write_Latency),
       .S1_Write_Latency       (S1_Write_Latency),
       .S2_Write_Latency       (S2_Write_Latency),
       .S3_Write_Latency       (S3_Write_Latency),
       .S4_Write_Latency       (S4_Write_Latency),
       .S5_Write_Latency       (S5_Write_Latency),
       .S6_Write_Latency       (S6_Write_Latency),
       .S7_Write_Latency       (S7_Write_Latency),
       .Read_Latency_En        (Read_Latency_En),    
       .Write_Latency_En       (Write_Latency_En),   
       .Slv_Wr_Idle_Cnt_En     (Slv_Wr_Idle_Cnt_En), 
       .Mst_Rd_Idle_Cnt_En     (Mst_Rd_Idle_Cnt_En), 
       .Num_BValids_En         (Num_BValids_En),     
       .Num_WLasts_En          (Num_WLasts_En),      
       .Num_RLasts_En          (Num_RLasts_En),      
       .S_Transfer_Cnt_En      (S_Transfer_Cnt_En),
       .S_Packet_Cnt_En        (S_Packet_Cnt_En),  
       .S0_S_Data_Byte_Cnt     (S0_S_Data_Byte_Cnt),
       .S1_S_Data_Byte_Cnt     (S1_S_Data_Byte_Cnt),
       .S2_S_Data_Byte_Cnt     (S2_S_Data_Byte_Cnt),
       .S3_S_Data_Byte_Cnt     (S3_S_Data_Byte_Cnt),
       .S4_S_Data_Byte_Cnt     (S4_S_Data_Byte_Cnt),
       .S5_S_Data_Byte_Cnt     (S5_S_Data_Byte_Cnt),
       .S6_S_Data_Byte_Cnt     (S6_S_Data_Byte_Cnt),
       .S7_S_Data_Byte_Cnt     (S7_S_Data_Byte_Cnt),
       .S0_S_Position_Byte_Cnt (S0_S_Position_Byte_Cnt),
       .S1_S_Position_Byte_Cnt (S1_S_Position_Byte_Cnt),
       .S2_S_Position_Byte_Cnt (S2_S_Position_Byte_Cnt),
       .S3_S_Position_Byte_Cnt (S3_S_Position_Byte_Cnt),
       .S4_S_Position_Byte_Cnt (S4_S_Position_Byte_Cnt),
       .S5_S_Position_Byte_Cnt (S5_S_Position_Byte_Cnt),
       .S6_S_Position_Byte_Cnt (S6_S_Position_Byte_Cnt),
       .S7_S_Position_Byte_Cnt (S7_S_Position_Byte_Cnt),
       .S0_S_Null_Byte_Cnt     (S0_S_Null_Byte_Cnt),
       .S1_S_Null_Byte_Cnt     (S1_S_Null_Byte_Cnt),
       .S2_S_Null_Byte_Cnt     (S2_S_Null_Byte_Cnt),
       .S3_S_Null_Byte_Cnt     (S3_S_Null_Byte_Cnt),
       .S4_S_Null_Byte_Cnt     (S4_S_Null_Byte_Cnt),
       .S5_S_Null_Byte_Cnt     (S5_S_Null_Byte_Cnt),
       .S6_S_Null_Byte_Cnt     (S6_S_Null_Byte_Cnt),
       .S7_S_Null_Byte_Cnt     (S7_S_Null_Byte_Cnt),
       .S_Slv_Idle_Cnt_En      (S_Slv_Idle_Cnt_En),
       .S_Mst_Idle_Cnt_En      (S_Mst_Idle_Cnt_En),
      .S0_Max_Write_Latency     (S0_Max_Write_Latency),         
      .S1_Max_Write_Latency     (S1_Max_Write_Latency),         
      .S2_Max_Write_Latency     (S2_Max_Write_Latency),         
      .S3_Max_Write_Latency     (S3_Max_Write_Latency),         
      .S4_Max_Write_Latency     (S4_Max_Write_Latency),         
      .S5_Max_Write_Latency     (S5_Max_Write_Latency),         
      .S6_Max_Write_Latency     (S6_Max_Write_Latency),         
      .S7_Max_Write_Latency     (S7_Max_Write_Latency),         
      .S0_Min_Write_Latency     (S0_Min_Write_Latency),       
      .S1_Min_Write_Latency     (S1_Min_Write_Latency),       
      .S2_Min_Write_Latency     (S2_Min_Write_Latency),       
      .S3_Min_Write_Latency     (S3_Min_Write_Latency),       
      .S4_Min_Write_Latency     (S4_Min_Write_Latency),       
      .S5_Min_Write_Latency     (S5_Min_Write_Latency),       
      .S6_Min_Write_Latency     (S6_Min_Write_Latency),       
      .S7_Min_Write_Latency     (S7_Min_Write_Latency),       
      .S0_Max_Read_Latency      (S0_Max_Read_Latency),                  
      .S1_Max_Read_Latency      (S1_Max_Read_Latency),                  
      .S2_Max_Read_Latency      (S2_Max_Read_Latency),                  
      .S3_Max_Read_Latency      (S3_Max_Read_Latency),                  
      .S4_Max_Read_Latency      (S4_Max_Read_Latency),                  
      .S5_Max_Read_Latency      (S5_Max_Read_Latency),                  
      .S6_Max_Read_Latency      (S6_Max_Read_Latency),                  
      .S7_Max_Read_Latency      (S7_Max_Read_Latency),                  
      .S0_Min_Read_Latency      (S0_Min_Read_Latency), 
      .S1_Min_Read_Latency      (S1_Min_Read_Latency), 
      .S2_Min_Read_Latency      (S2_Min_Read_Latency), 
      .S3_Min_Read_Latency      (S3_Min_Read_Latency), 
      .S4_Min_Read_Latency      (S4_Min_Read_Latency), 
      .S5_Min_Read_Latency      (S5_Min_Read_Latency), 
      .S6_Min_Read_Latency      (S6_Min_Read_Latency), 
      .S7_Min_Read_Latency      (S7_Min_Read_Latency), 
      .External_Event_Cnt_En    (External_Event_Cnt_En),
      .Metrics_Cnt_En           (Metrics_Cnt_En),
      .Metrics_Cnt_Reset        (Metrics_Cnt_Reset),
      .Metric_Sel               (Metric_Sel_0),
      .Range_Reg                (Range_Reg_0),
      .Metric_Cnt               (Metric_Cnt_0),
      .Incrementer              (Incrementer_0),
      .Acc_OF                   (Acc_OF_0),
      .Incr_OF                  (Incr_OF_0)
   );


//-- Metric Counter_1
generate
if (C_NUM_OF_COUNTERS > 1) begin : GEN_METRIC_CNT_1

    //-- Mux n Metric Counter_1
    axi_perf_mon_v5_0_12_metric_sel_n_cnt 
      #(
           .C_FAMILY             (C_FAMILY),
           .C_NUM_MONITOR_SLOTS  (C_NUM_MONITOR_SLOTS), 
           .C_ENABLE_EVENT_COUNT (C_ENABLE_EVENT_COUNT),
           .C_METRIC_COUNT_WIDTH (C_METRIC_COUNT_WIDTH),
           .C_METRIC_COUNT_SCALE (C_METRIC_COUNT_SCALE),
           .COUNTER_LOAD_VALUE   (COUNTER_LOAD_VALUE)  

       ) axi_perf_mon_v5_0_12_metric_sel_n_cnt_inst_1 
       (
           .clk                    (clk),
           .rst_n                  (rst_n),
           .Wtrans_Cnt_En          (Wtrans_Cnt_En),
           .Rtrans_Cnt_En          (Rtrans_Cnt_En),
           .S0_Write_Byte_Cnt      (S0_Write_Byte_Cnt),
           .S1_Write_Byte_Cnt      (S1_Write_Byte_Cnt),
           .S2_Write_Byte_Cnt      (S2_Write_Byte_Cnt),
           .S3_Write_Byte_Cnt      (S3_Write_Byte_Cnt),
           .S4_Write_Byte_Cnt      (S4_Write_Byte_Cnt),
           .S5_Write_Byte_Cnt      (S5_Write_Byte_Cnt),
           .S6_Write_Byte_Cnt      (S6_Write_Byte_Cnt),
           .S7_Write_Byte_Cnt      (S7_Write_Byte_Cnt),
           .S0_Slv_Wr_Idle_Cnt      (S0_Slv_Wr_Idle_Cnt),
           .S1_Slv_Wr_Idle_Cnt      (S1_Slv_Wr_Idle_Cnt),
           .S2_Slv_Wr_Idle_Cnt      (S2_Slv_Wr_Idle_Cnt),
           .S3_Slv_Wr_Idle_Cnt      (S3_Slv_Wr_Idle_Cnt),
           .S4_Slv_Wr_Idle_Cnt      (S4_Slv_Wr_Idle_Cnt),
           .S5_Slv_Wr_Idle_Cnt      (S5_Slv_Wr_Idle_Cnt),
           .S6_Slv_Wr_Idle_Cnt      (S6_Slv_Wr_Idle_Cnt),
           .S7_Slv_Wr_Idle_Cnt      (S7_Slv_Wr_Idle_Cnt),
           .S0_Read_Byte_Cnt       (S0_Read_Byte_Cnt),
     .S0_Read_Byte_Cnt_En       (S0_Read_Byte_Cnt_En),
           .S1_Read_Byte_Cnt       (S1_Read_Byte_Cnt),
           .S1_Read_Byte_Cnt_En       (S1_Read_Byte_Cnt_En),
           .S2_Read_Byte_Cnt       (S2_Read_Byte_Cnt),
           .S2_Read_Byte_Cnt_En       (S2_Read_Byte_Cnt_En),
           .S3_Read_Byte_Cnt       (S3_Read_Byte_Cnt),
           .S3_Read_Byte_Cnt_En       (S3_Read_Byte_Cnt_En),
           .S4_Read_Byte_Cnt       (S4_Read_Byte_Cnt),
           .S4_Read_Byte_Cnt_En       (S4_Read_Byte_Cnt_En),
           .S5_Read_Byte_Cnt       (S5_Read_Byte_Cnt),
           .S5_Read_Byte_Cnt_En       (S5_Read_Byte_Cnt_En),
           .S6_Read_Byte_Cnt       (S6_Read_Byte_Cnt),
           .S6_Read_Byte_Cnt_En       (S6_Read_Byte_Cnt_En),
           .S7_Read_Byte_Cnt       (S7_Read_Byte_Cnt),
           .S7_Read_Byte_Cnt_En       (S7_Read_Byte_Cnt_En),
           .Write_Beat_Cnt_En      (Write_Beat_Cnt_En),
           .Read_Beat_Cnt_En       (Read_Beat_Cnt_En),
           .S0_Read_Latency        (S0_Read_Latency),
           .S1_Read_Latency        (S1_Read_Latency),
           .S2_Read_Latency        (S2_Read_Latency),
           .S3_Read_Latency        (S3_Read_Latency),
           .S4_Read_Latency        (S4_Read_Latency),
           .S5_Read_Latency        (S5_Read_Latency),
           .S6_Read_Latency        (S6_Read_Latency),
           .S7_Read_Latency        (S7_Read_Latency),
           .S0_Write_Latency       (S0_Write_Latency),
           .S1_Write_Latency       (S1_Write_Latency),
           .S2_Write_Latency       (S2_Write_Latency),
           .S3_Write_Latency       (S3_Write_Latency),
           .S4_Write_Latency       (S4_Write_Latency),
           .S5_Write_Latency       (S5_Write_Latency),
           .S6_Write_Latency       (S6_Write_Latency),
           .S7_Write_Latency       (S7_Write_Latency),
           .Read_Latency_En        (Read_Latency_En),    
           .Write_Latency_En       (Write_Latency_En),   
           .Slv_Wr_Idle_Cnt_En     (Slv_Wr_Idle_Cnt_En), 
           .Mst_Rd_Idle_Cnt_En     (Mst_Rd_Idle_Cnt_En), 
           .Num_BValids_En         (Num_BValids_En),     
           .Num_WLasts_En          (Num_WLasts_En),      
           .Num_RLasts_En          (Num_RLasts_En),      
           .S_Transfer_Cnt_En      (S_Transfer_Cnt_En),
           .S_Packet_Cnt_En        (S_Packet_Cnt_En),  
           .S0_S_Data_Byte_Cnt     (S0_S_Data_Byte_Cnt),
           .S1_S_Data_Byte_Cnt     (S1_S_Data_Byte_Cnt),
           .S2_S_Data_Byte_Cnt     (S2_S_Data_Byte_Cnt),
           .S3_S_Data_Byte_Cnt     (S3_S_Data_Byte_Cnt),
           .S4_S_Data_Byte_Cnt     (S4_S_Data_Byte_Cnt),
           .S5_S_Data_Byte_Cnt     (S5_S_Data_Byte_Cnt),
           .S6_S_Data_Byte_Cnt     (S6_S_Data_Byte_Cnt),
           .S7_S_Data_Byte_Cnt     (S7_S_Data_Byte_Cnt),
       .S0_Write_Beat_Cnt       (S0_Write_Beat_Cnt),
       .S1_Write_Beat_Cnt       (S1_Write_Beat_Cnt),
       .S2_Write_Beat_Cnt       (S2_Write_Beat_Cnt),
       .S3_Write_Beat_Cnt       (S3_Write_Beat_Cnt),
       .S4_Write_Beat_Cnt       (S4_Write_Beat_Cnt),
       .S5_Write_Beat_Cnt       (S5_Write_Beat_Cnt),
       .S6_Write_Beat_Cnt       (S6_Write_Beat_Cnt),
       .S7_Write_Beat_Cnt       (S7_Write_Beat_Cnt),
           .S0_S_Position_Byte_Cnt (S0_S_Position_Byte_Cnt),
           .S1_S_Position_Byte_Cnt (S1_S_Position_Byte_Cnt),
           .S2_S_Position_Byte_Cnt (S2_S_Position_Byte_Cnt),
           .S3_S_Position_Byte_Cnt (S3_S_Position_Byte_Cnt),
           .S4_S_Position_Byte_Cnt (S4_S_Position_Byte_Cnt),
           .S5_S_Position_Byte_Cnt (S5_S_Position_Byte_Cnt),
           .S6_S_Position_Byte_Cnt (S6_S_Position_Byte_Cnt),
           .S7_S_Position_Byte_Cnt (S7_S_Position_Byte_Cnt),
           .S0_S_Null_Byte_Cnt     (S0_S_Null_Byte_Cnt),
           .S1_S_Null_Byte_Cnt     (S1_S_Null_Byte_Cnt),
           .S2_S_Null_Byte_Cnt     (S2_S_Null_Byte_Cnt),
           .S3_S_Null_Byte_Cnt     (S3_S_Null_Byte_Cnt),
           .S4_S_Null_Byte_Cnt     (S4_S_Null_Byte_Cnt),
           .S5_S_Null_Byte_Cnt     (S5_S_Null_Byte_Cnt),
           .S6_S_Null_Byte_Cnt     (S6_S_Null_Byte_Cnt),
           .S7_S_Null_Byte_Cnt     (S7_S_Null_Byte_Cnt),
           .S0_Max_Write_Latency   (S0_Max_Write_Latency),         
           .S1_Max_Write_Latency   (S1_Max_Write_Latency),         
           .S2_Max_Write_Latency   (S2_Max_Write_Latency),         
           .S3_Max_Write_Latency   (S3_Max_Write_Latency),         
           .S4_Max_Write_Latency   (S4_Max_Write_Latency),         
           .S5_Max_Write_Latency   (S5_Max_Write_Latency),         
           .S6_Max_Write_Latency   (S6_Max_Write_Latency),         
           .S7_Max_Write_Latency   (S7_Max_Write_Latency),         
           .S0_Min_Write_Latency   (S0_Min_Write_Latency),       
           .S1_Min_Write_Latency   (S1_Min_Write_Latency),       
           .S2_Min_Write_Latency   (S2_Min_Write_Latency),       
           .S3_Min_Write_Latency   (S3_Min_Write_Latency),       
           .S4_Min_Write_Latency   (S4_Min_Write_Latency),       
           .S5_Min_Write_Latency   (S5_Min_Write_Latency),       
           .S6_Min_Write_Latency   (S6_Min_Write_Latency),       
           .S7_Min_Write_Latency   (S7_Min_Write_Latency),       
           .S0_Max_Read_Latency    (S0_Max_Read_Latency),                  
           .S1_Max_Read_Latency    (S1_Max_Read_Latency),                  
           .S2_Max_Read_Latency    (S2_Max_Read_Latency),                  
           .S3_Max_Read_Latency    (S3_Max_Read_Latency),                  
           .S4_Max_Read_Latency    (S4_Max_Read_Latency),                  
           .S5_Max_Read_Latency    (S5_Max_Read_Latency),                  
           .S6_Max_Read_Latency    (S6_Max_Read_Latency),                  
           .S7_Max_Read_Latency    (S7_Max_Read_Latency),                  
           .S0_Min_Read_Latency    (S0_Min_Read_Latency), 
           .S1_Min_Read_Latency    (S1_Min_Read_Latency), 
           .S2_Min_Read_Latency    (S2_Min_Read_Latency), 
           .S3_Min_Read_Latency    (S3_Min_Read_Latency), 
           .S4_Min_Read_Latency    (S4_Min_Read_Latency), 
           .S5_Min_Read_Latency    (S5_Min_Read_Latency), 
           .S6_Min_Read_Latency    (S6_Min_Read_Latency), 
           .S7_Min_Read_Latency    (S7_Min_Read_Latency), 
           .S_Slv_Idle_Cnt_En      (S_Slv_Idle_Cnt_En),
           .S_Mst_Idle_Cnt_En      (S_Mst_Idle_Cnt_En),
           .External_Event_Cnt_En  (External_Event_Cnt_En),
           .Metrics_Cnt_En         (Metrics_Cnt_En),
           .Metrics_Cnt_Reset      (Metrics_Cnt_Reset),
           .Metric_Sel             (Metric_Sel_1),
           .Range_Reg              (Range_Reg_1),
           .Metric_Cnt             (Metric_Cnt_1),
           .Incrementer            (Incrementer_1),
           .Acc_OF                 (Acc_OF_1),
           .Incr_OF                (Incr_OF_1)
       );
    
end    
else begin : GEN_NO_METRIC_CNT_1
    assign Metric_Cnt_1  = 0;
    assign Incrementer_1 = 0;
    assign Acc_OF_1      = 1'b0;
    assign Incr_OF_1     = 1'b0;

end
endgenerate


//-- Metric Counter_2
generate
if (C_NUM_OF_COUNTERS > 2) begin : GEN_METRIC_CNT_2

    //-- Mux n Metric Counter_2
    axi_perf_mon_v5_0_12_metric_sel_n_cnt 
      #(
           .C_FAMILY             (C_FAMILY),
           .C_NUM_MONITOR_SLOTS  (C_NUM_MONITOR_SLOTS), 
           .C_ENABLE_EVENT_COUNT (C_ENABLE_EVENT_COUNT),
           .C_METRIC_COUNT_WIDTH (C_METRIC_COUNT_WIDTH),
           .C_METRIC_COUNT_SCALE (C_METRIC_COUNT_SCALE),
           .COUNTER_LOAD_VALUE   (COUNTER_LOAD_VALUE)  

       ) axi_perf_mon_v5_0_12_metric_sel_n_cnt_inst_2 
       (
           .clk                    (clk),
           .rst_n                  (rst_n),
           .Wtrans_Cnt_En          (Wtrans_Cnt_En),
           .Rtrans_Cnt_En          (Rtrans_Cnt_En),
           .S0_Write_Byte_Cnt      (S0_Write_Byte_Cnt),
           .S1_Write_Byte_Cnt      (S1_Write_Byte_Cnt),
           .S2_Write_Byte_Cnt      (S2_Write_Byte_Cnt),
           .S3_Write_Byte_Cnt      (S3_Write_Byte_Cnt),
           .S4_Write_Byte_Cnt      (S4_Write_Byte_Cnt),
           .S5_Write_Byte_Cnt      (S5_Write_Byte_Cnt),
           .S6_Write_Byte_Cnt      (S6_Write_Byte_Cnt),
           .S7_Write_Byte_Cnt      (S7_Write_Byte_Cnt),
           .S0_Slv_Wr_Idle_Cnt      (S0_Slv_Wr_Idle_Cnt),
           .S1_Slv_Wr_Idle_Cnt      (S1_Slv_Wr_Idle_Cnt),
           .S2_Slv_Wr_Idle_Cnt      (S2_Slv_Wr_Idle_Cnt),
           .S3_Slv_Wr_Idle_Cnt      (S3_Slv_Wr_Idle_Cnt),
           .S4_Slv_Wr_Idle_Cnt      (S4_Slv_Wr_Idle_Cnt),
           .S5_Slv_Wr_Idle_Cnt      (S5_Slv_Wr_Idle_Cnt),
           .S6_Slv_Wr_Idle_Cnt      (S6_Slv_Wr_Idle_Cnt),
           .S7_Slv_Wr_Idle_Cnt      (S7_Slv_Wr_Idle_Cnt),
       .S0_Write_Beat_Cnt       (S0_Write_Beat_Cnt),
       .S1_Write_Beat_Cnt       (S1_Write_Beat_Cnt),
       .S2_Write_Beat_Cnt       (S2_Write_Beat_Cnt),
       .S3_Write_Beat_Cnt       (S3_Write_Beat_Cnt),
       .S4_Write_Beat_Cnt       (S4_Write_Beat_Cnt),
       .S5_Write_Beat_Cnt       (S5_Write_Beat_Cnt),
       .S6_Write_Beat_Cnt       (S6_Write_Beat_Cnt),
       .S7_Write_Beat_Cnt       (S7_Write_Beat_Cnt),
           .S0_Read_Byte_Cnt       (S0_Read_Byte_Cnt),
     .S0_Read_Byte_Cnt_En       (S0_Read_Byte_Cnt_En),
           .S1_Read_Byte_Cnt       (S1_Read_Byte_Cnt),
           .S1_Read_Byte_Cnt_En       (S1_Read_Byte_Cnt_En),
           .S2_Read_Byte_Cnt       (S2_Read_Byte_Cnt),
           .S2_Read_Byte_Cnt_En       (S2_Read_Byte_Cnt_En),
           .S3_Read_Byte_Cnt       (S3_Read_Byte_Cnt),
           .S3_Read_Byte_Cnt_En       (S3_Read_Byte_Cnt_En),
           .S4_Read_Byte_Cnt       (S4_Read_Byte_Cnt),
           .S4_Read_Byte_Cnt_En       (S4_Read_Byte_Cnt_En),
           .S5_Read_Byte_Cnt       (S5_Read_Byte_Cnt),
           .S5_Read_Byte_Cnt_En       (S5_Read_Byte_Cnt_En),
           .S6_Read_Byte_Cnt       (S6_Read_Byte_Cnt),
           .S6_Read_Byte_Cnt_En       (S6_Read_Byte_Cnt_En),
           .S7_Read_Byte_Cnt       (S7_Read_Byte_Cnt),
           .S7_Read_Byte_Cnt_En       (S7_Read_Byte_Cnt_En),
           .Write_Beat_Cnt_En      (Write_Beat_Cnt_En),
           .Read_Beat_Cnt_En       (Read_Beat_Cnt_En),
           .S0_Read_Latency        (S0_Read_Latency),
           .S1_Read_Latency        (S1_Read_Latency),
           .S2_Read_Latency        (S2_Read_Latency),
           .S3_Read_Latency        (S3_Read_Latency),
           .S4_Read_Latency        (S4_Read_Latency),
           .S5_Read_Latency        (S5_Read_Latency),
           .S6_Read_Latency        (S6_Read_Latency),
           .S7_Read_Latency        (S7_Read_Latency),
           .S0_Write_Latency       (S0_Write_Latency),
           .S1_Write_Latency       (S1_Write_Latency),
           .S2_Write_Latency       (S2_Write_Latency),
           .S3_Write_Latency       (S3_Write_Latency),
           .S4_Write_Latency       (S4_Write_Latency),
           .S5_Write_Latency       (S5_Write_Latency),
           .S6_Write_Latency       (S6_Write_Latency),
           .S7_Write_Latency       (S7_Write_Latency),
           .Read_Latency_En        (Read_Latency_En),    
           .Write_Latency_En       (Write_Latency_En),   
           .Slv_Wr_Idle_Cnt_En     (Slv_Wr_Idle_Cnt_En), 
           .Mst_Rd_Idle_Cnt_En     (Mst_Rd_Idle_Cnt_En), 
           .Num_BValids_En         (Num_BValids_En),     
           .Num_WLasts_En          (Num_WLasts_En),      
           .Num_RLasts_En          (Num_RLasts_En),      
           .S_Transfer_Cnt_En      (S_Transfer_Cnt_En),
           .S_Packet_Cnt_En        (S_Packet_Cnt_En),  
           .S0_S_Data_Byte_Cnt     (S0_S_Data_Byte_Cnt),
           .S1_S_Data_Byte_Cnt     (S1_S_Data_Byte_Cnt),
           .S2_S_Data_Byte_Cnt     (S2_S_Data_Byte_Cnt),
           .S3_S_Data_Byte_Cnt     (S3_S_Data_Byte_Cnt),
           .S4_S_Data_Byte_Cnt     (S4_S_Data_Byte_Cnt),
           .S5_S_Data_Byte_Cnt     (S5_S_Data_Byte_Cnt),
           .S6_S_Data_Byte_Cnt     (S6_S_Data_Byte_Cnt),
           .S7_S_Data_Byte_Cnt     (S7_S_Data_Byte_Cnt),
           .S0_S_Position_Byte_Cnt (S0_S_Position_Byte_Cnt),
           .S1_S_Position_Byte_Cnt (S1_S_Position_Byte_Cnt),
           .S2_S_Position_Byte_Cnt (S2_S_Position_Byte_Cnt),
           .S3_S_Position_Byte_Cnt (S3_S_Position_Byte_Cnt),
           .S4_S_Position_Byte_Cnt (S4_S_Position_Byte_Cnt),
           .S5_S_Position_Byte_Cnt (S5_S_Position_Byte_Cnt),
           .S6_S_Position_Byte_Cnt (S6_S_Position_Byte_Cnt),
           .S7_S_Position_Byte_Cnt (S7_S_Position_Byte_Cnt),
           .S0_S_Null_Byte_Cnt     (S0_S_Null_Byte_Cnt),
           .S1_S_Null_Byte_Cnt     (S1_S_Null_Byte_Cnt),
           .S2_S_Null_Byte_Cnt     (S2_S_Null_Byte_Cnt),
           .S3_S_Null_Byte_Cnt     (S3_S_Null_Byte_Cnt),
           .S4_S_Null_Byte_Cnt     (S4_S_Null_Byte_Cnt),
           .S5_S_Null_Byte_Cnt     (S5_S_Null_Byte_Cnt),
           .S6_S_Null_Byte_Cnt     (S6_S_Null_Byte_Cnt),
           .S7_S_Null_Byte_Cnt     (S7_S_Null_Byte_Cnt),
           .S_Slv_Idle_Cnt_En      (S_Slv_Idle_Cnt_En),
           .S_Mst_Idle_Cnt_En      (S_Mst_Idle_Cnt_En),
           .S0_Max_Write_Latency   (S0_Max_Write_Latency),         
           .S1_Max_Write_Latency   (S1_Max_Write_Latency),         
           .S2_Max_Write_Latency   (S2_Max_Write_Latency),         
           .S3_Max_Write_Latency   (S3_Max_Write_Latency),         
           .S4_Max_Write_Latency   (S4_Max_Write_Latency),         
           .S5_Max_Write_Latency   (S5_Max_Write_Latency),         
           .S6_Max_Write_Latency   (S6_Max_Write_Latency),         
           .S7_Max_Write_Latency   (S7_Max_Write_Latency),         
           .S0_Min_Write_Latency   (S0_Min_Write_Latency),       
           .S1_Min_Write_Latency   (S1_Min_Write_Latency),       
           .S2_Min_Write_Latency   (S2_Min_Write_Latency),       
           .S3_Min_Write_Latency   (S3_Min_Write_Latency),       
           .S4_Min_Write_Latency   (S4_Min_Write_Latency),       
           .S5_Min_Write_Latency   (S5_Min_Write_Latency),       
           .S6_Min_Write_Latency   (S6_Min_Write_Latency),       
           .S7_Min_Write_Latency   (S7_Min_Write_Latency),       
           .S0_Max_Read_Latency    (S0_Max_Read_Latency),                  
           .S1_Max_Read_Latency    (S1_Max_Read_Latency),                  
           .S2_Max_Read_Latency    (S2_Max_Read_Latency),                  
           .S3_Max_Read_Latency    (S3_Max_Read_Latency),                  
           .S4_Max_Read_Latency    (S4_Max_Read_Latency),                  
           .S5_Max_Read_Latency    (S5_Max_Read_Latency),                  
           .S6_Max_Read_Latency    (S6_Max_Read_Latency),                  
           .S7_Max_Read_Latency    (S7_Max_Read_Latency),                  
           .S0_Min_Read_Latency    (S0_Min_Read_Latency), 
           .S1_Min_Read_Latency    (S1_Min_Read_Latency), 
           .S2_Min_Read_Latency    (S2_Min_Read_Latency), 
           .S3_Min_Read_Latency    (S3_Min_Read_Latency), 
           .S4_Min_Read_Latency    (S4_Min_Read_Latency), 
           .S5_Min_Read_Latency    (S5_Min_Read_Latency), 
           .S6_Min_Read_Latency    (S6_Min_Read_Latency), 
           .S7_Min_Read_Latency    (S7_Min_Read_Latency), 
           .External_Event_Cnt_En  (External_Event_Cnt_En),
           .Metrics_Cnt_En         (Metrics_Cnt_En),
           .Metrics_Cnt_Reset      (Metrics_Cnt_Reset),
           .Metric_Sel             (Metric_Sel_2),
           .Range_Reg              (Range_Reg_2),
           .Metric_Cnt             (Metric_Cnt_2),
           .Incrementer            (Incrementer_2),
           .Acc_OF                 (Acc_OF_2),
           .Incr_OF                (Incr_OF_2)
       );
    
end    
else begin : GEN_NO_METRIC_CNT_2
    assign Metric_Cnt_2  = 0;
    assign Incrementer_2 = 0;
    assign Acc_OF_2      = 1'b0;
    assign Incr_OF_2     = 1'b0;

end
endgenerate




//-- Metric Counter_3
generate
if (C_NUM_OF_COUNTERS > 3) begin : GEN_METRIC_CNT_3

    //-- Mux n Metric Counter_3
    axi_perf_mon_v5_0_12_metric_sel_n_cnt 
      #(
           .C_FAMILY             (C_FAMILY),
           .C_NUM_MONITOR_SLOTS  (C_NUM_MONITOR_SLOTS), 
           .C_ENABLE_EVENT_COUNT (C_ENABLE_EVENT_COUNT),
           .C_METRIC_COUNT_WIDTH (C_METRIC_COUNT_WIDTH),
           .C_METRIC_COUNT_SCALE (C_METRIC_COUNT_SCALE),
           .COUNTER_LOAD_VALUE   (COUNTER_LOAD_VALUE)  

       ) axi_perf_mon_v5_0_12_metric_sel_n_cnt_inst_3 
       (
           .clk                    (clk),
           .rst_n                  (rst_n),
           .Wtrans_Cnt_En          (Wtrans_Cnt_En),
           .Rtrans_Cnt_En          (Rtrans_Cnt_En),
           .S0_Write_Byte_Cnt      (S0_Write_Byte_Cnt),
           .S1_Write_Byte_Cnt      (S1_Write_Byte_Cnt),
           .S2_Write_Byte_Cnt      (S2_Write_Byte_Cnt),
           .S3_Write_Byte_Cnt      (S3_Write_Byte_Cnt),
           .S4_Write_Byte_Cnt      (S4_Write_Byte_Cnt),
           .S5_Write_Byte_Cnt      (S5_Write_Byte_Cnt),
           .S6_Write_Byte_Cnt      (S6_Write_Byte_Cnt),
           .S7_Write_Byte_Cnt      (S7_Write_Byte_Cnt),
           .S0_Slv_Wr_Idle_Cnt      (S0_Slv_Wr_Idle_Cnt),
           .S1_Slv_Wr_Idle_Cnt      (S1_Slv_Wr_Idle_Cnt),
           .S2_Slv_Wr_Idle_Cnt      (S2_Slv_Wr_Idle_Cnt),
           .S3_Slv_Wr_Idle_Cnt      (S3_Slv_Wr_Idle_Cnt),
           .S4_Slv_Wr_Idle_Cnt      (S4_Slv_Wr_Idle_Cnt),
           .S5_Slv_Wr_Idle_Cnt      (S5_Slv_Wr_Idle_Cnt),
           .S6_Slv_Wr_Idle_Cnt      (S6_Slv_Wr_Idle_Cnt),
           .S7_Slv_Wr_Idle_Cnt      (S7_Slv_Wr_Idle_Cnt),
       .S0_Write_Beat_Cnt       (S0_Write_Beat_Cnt),
       .S1_Write_Beat_Cnt       (S1_Write_Beat_Cnt),
       .S2_Write_Beat_Cnt       (S2_Write_Beat_Cnt),
       .S3_Write_Beat_Cnt       (S3_Write_Beat_Cnt),
       .S4_Write_Beat_Cnt       (S4_Write_Beat_Cnt),
       .S5_Write_Beat_Cnt       (S5_Write_Beat_Cnt),
       .S6_Write_Beat_Cnt       (S6_Write_Beat_Cnt),
       .S7_Write_Beat_Cnt       (S7_Write_Beat_Cnt),
           .S0_Read_Byte_Cnt       (S0_Read_Byte_Cnt),
     .S0_Read_Byte_Cnt_En       (S0_Read_Byte_Cnt_En),
           .S1_Read_Byte_Cnt       (S1_Read_Byte_Cnt),
           .S1_Read_Byte_Cnt_En       (S1_Read_Byte_Cnt_En),
           .S2_Read_Byte_Cnt       (S2_Read_Byte_Cnt),
           .S2_Read_Byte_Cnt_En       (S2_Read_Byte_Cnt_En),
           .S3_Read_Byte_Cnt       (S3_Read_Byte_Cnt),
           .S3_Read_Byte_Cnt_En       (S3_Read_Byte_Cnt_En),
           .S4_Read_Byte_Cnt       (S4_Read_Byte_Cnt),
           .S4_Read_Byte_Cnt_En       (S4_Read_Byte_Cnt_En),
           .S5_Read_Byte_Cnt       (S5_Read_Byte_Cnt),
           .S5_Read_Byte_Cnt_En       (S5_Read_Byte_Cnt_En),
           .S6_Read_Byte_Cnt       (S6_Read_Byte_Cnt),
           .S6_Read_Byte_Cnt_En       (S6_Read_Byte_Cnt_En),
           .S7_Read_Byte_Cnt       (S7_Read_Byte_Cnt),
           .S7_Read_Byte_Cnt_En       (S7_Read_Byte_Cnt_En),
           .Write_Beat_Cnt_En      (Write_Beat_Cnt_En),
           .Read_Beat_Cnt_En       (Read_Beat_Cnt_En),
           .S0_Read_Latency        (S0_Read_Latency),
           .S1_Read_Latency        (S1_Read_Latency),
           .S2_Read_Latency        (S2_Read_Latency),
           .S3_Read_Latency        (S3_Read_Latency),
           .S4_Read_Latency        (S4_Read_Latency),
           .S5_Read_Latency        (S5_Read_Latency),
           .S6_Read_Latency        (S6_Read_Latency),
           .S7_Read_Latency        (S7_Read_Latency),
           .S0_Write_Latency       (S0_Write_Latency),
           .S1_Write_Latency       (S1_Write_Latency),
           .S2_Write_Latency       (S2_Write_Latency),
           .S3_Write_Latency       (S3_Write_Latency),
           .S4_Write_Latency       (S4_Write_Latency),
           .S5_Write_Latency       (S5_Write_Latency),
           .S6_Write_Latency       (S6_Write_Latency),
           .S7_Write_Latency       (S7_Write_Latency),
           .Read_Latency_En        (Read_Latency_En),    
           .Write_Latency_En       (Write_Latency_En),   
           .Slv_Wr_Idle_Cnt_En     (Slv_Wr_Idle_Cnt_En), 
           .Mst_Rd_Idle_Cnt_En     (Mst_Rd_Idle_Cnt_En), 
           .Num_BValids_En         (Num_BValids_En),     
           .Num_WLasts_En          (Num_WLasts_En),      
           .Num_RLasts_En          (Num_RLasts_En),      
           .S_Transfer_Cnt_En      (S_Transfer_Cnt_En),
           .S_Packet_Cnt_En        (S_Packet_Cnt_En),  
           .S0_S_Data_Byte_Cnt     (S0_S_Data_Byte_Cnt),
           .S1_S_Data_Byte_Cnt     (S1_S_Data_Byte_Cnt),
           .S2_S_Data_Byte_Cnt     (S2_S_Data_Byte_Cnt),
           .S3_S_Data_Byte_Cnt     (S3_S_Data_Byte_Cnt),
           .S4_S_Data_Byte_Cnt     (S4_S_Data_Byte_Cnt),
           .S5_S_Data_Byte_Cnt     (S5_S_Data_Byte_Cnt),
           .S6_S_Data_Byte_Cnt     (S6_S_Data_Byte_Cnt),
           .S7_S_Data_Byte_Cnt     (S7_S_Data_Byte_Cnt),
           .S0_S_Position_Byte_Cnt (S0_S_Position_Byte_Cnt),
           .S1_S_Position_Byte_Cnt (S1_S_Position_Byte_Cnt),
           .S2_S_Position_Byte_Cnt (S2_S_Position_Byte_Cnt),
           .S3_S_Position_Byte_Cnt (S3_S_Position_Byte_Cnt),
           .S4_S_Position_Byte_Cnt (S4_S_Position_Byte_Cnt),
           .S5_S_Position_Byte_Cnt (S5_S_Position_Byte_Cnt),
           .S6_S_Position_Byte_Cnt (S6_S_Position_Byte_Cnt),
           .S7_S_Position_Byte_Cnt (S7_S_Position_Byte_Cnt),
           .S0_S_Null_Byte_Cnt     (S0_S_Null_Byte_Cnt),
           .S1_S_Null_Byte_Cnt     (S1_S_Null_Byte_Cnt),
           .S2_S_Null_Byte_Cnt     (S2_S_Null_Byte_Cnt),
           .S3_S_Null_Byte_Cnt     (S3_S_Null_Byte_Cnt),
           .S4_S_Null_Byte_Cnt     (S4_S_Null_Byte_Cnt),
           .S5_S_Null_Byte_Cnt     (S5_S_Null_Byte_Cnt),
           .S6_S_Null_Byte_Cnt     (S6_S_Null_Byte_Cnt),
           .S7_S_Null_Byte_Cnt     (S7_S_Null_Byte_Cnt),
           .S_Slv_Idle_Cnt_En      (S_Slv_Idle_Cnt_En),
           .S_Mst_Idle_Cnt_En      (S_Mst_Idle_Cnt_En),
           .S0_Max_Write_Latency   (S0_Max_Write_Latency),         
           .S1_Max_Write_Latency   (S1_Max_Write_Latency),         
           .S2_Max_Write_Latency   (S2_Max_Write_Latency),         
           .S3_Max_Write_Latency   (S3_Max_Write_Latency),         
           .S4_Max_Write_Latency   (S4_Max_Write_Latency),         
           .S5_Max_Write_Latency   (S5_Max_Write_Latency),         
           .S6_Max_Write_Latency   (S6_Max_Write_Latency),         
           .S7_Max_Write_Latency   (S7_Max_Write_Latency),         
           .S0_Min_Write_Latency   (S0_Min_Write_Latency),       
           .S1_Min_Write_Latency   (S1_Min_Write_Latency),       
           .S2_Min_Write_Latency   (S2_Min_Write_Latency),       
           .S3_Min_Write_Latency   (S3_Min_Write_Latency),       
           .S4_Min_Write_Latency   (S4_Min_Write_Latency),       
           .S5_Min_Write_Latency   (S5_Min_Write_Latency),       
           .S6_Min_Write_Latency   (S6_Min_Write_Latency),       
           .S7_Min_Write_Latency   (S7_Min_Write_Latency),       
           .S0_Max_Read_Latency    (S0_Max_Read_Latency),                  
           .S1_Max_Read_Latency    (S1_Max_Read_Latency),                  
           .S2_Max_Read_Latency    (S2_Max_Read_Latency),                  
           .S3_Max_Read_Latency    (S3_Max_Read_Latency),                  
           .S4_Max_Read_Latency    (S4_Max_Read_Latency),                  
           .S5_Max_Read_Latency    (S5_Max_Read_Latency),                  
           .S6_Max_Read_Latency    (S6_Max_Read_Latency),                  
           .S7_Max_Read_Latency    (S7_Max_Read_Latency),                  
           .S0_Min_Read_Latency    (S0_Min_Read_Latency), 
           .S1_Min_Read_Latency    (S1_Min_Read_Latency), 
           .S2_Min_Read_Latency    (S2_Min_Read_Latency), 
           .S3_Min_Read_Latency    (S3_Min_Read_Latency), 
           .S4_Min_Read_Latency    (S4_Min_Read_Latency), 
           .S5_Min_Read_Latency    (S5_Min_Read_Latency), 
           .S6_Min_Read_Latency    (S6_Min_Read_Latency), 
           .S7_Min_Read_Latency    (S7_Min_Read_Latency), 
           .External_Event_Cnt_En  (External_Event_Cnt_En),
           .Metrics_Cnt_En         (Metrics_Cnt_En),
           .Metrics_Cnt_Reset      (Metrics_Cnt_Reset),
           .Metric_Sel             (Metric_Sel_3),
           .Range_Reg              (Range_Reg_3),
           .Metric_Cnt             (Metric_Cnt_3),
           .Incrementer            (Incrementer_3),
           .Acc_OF                 (Acc_OF_3),
           .Incr_OF                (Incr_OF_3)
       );
    
end    
else begin : GEN_NO_METRIC_CNT_3
    assign Metric_Cnt_3  = 0;
    assign Incrementer_3 = 0;
    assign Acc_OF_3      = 1'b0;
    assign Incr_OF_3     = 1'b0;

end
endgenerate



//-- Metric Counter_4
generate
if (C_NUM_OF_COUNTERS > 4) begin : GEN_METRIC_CNT_4

    //-- Mux n Metric Counter_4
    axi_perf_mon_v5_0_12_metric_sel_n_cnt 
      #(
           .C_FAMILY             (C_FAMILY),
           .C_NUM_MONITOR_SLOTS  (C_NUM_MONITOR_SLOTS), 
           .C_ENABLE_EVENT_COUNT (C_ENABLE_EVENT_COUNT),
           .C_METRIC_COUNT_WIDTH (C_METRIC_COUNT_WIDTH),
           .C_METRIC_COUNT_SCALE (C_METRIC_COUNT_SCALE),
           .COUNTER_LOAD_VALUE   (COUNTER_LOAD_VALUE)  

       ) axi_perf_mon_v5_0_12_metric_sel_n_cnt_inst_4 
       (
           .clk                    (clk),
           .rst_n                  (rst_n),
           .Wtrans_Cnt_En          (Wtrans_Cnt_En),
           .Rtrans_Cnt_En          (Rtrans_Cnt_En),
           .S0_Write_Byte_Cnt      (S0_Write_Byte_Cnt),
           .S1_Write_Byte_Cnt      (S1_Write_Byte_Cnt),
           .S2_Write_Byte_Cnt      (S2_Write_Byte_Cnt),
           .S3_Write_Byte_Cnt      (S3_Write_Byte_Cnt),
           .S4_Write_Byte_Cnt      (S4_Write_Byte_Cnt),
           .S5_Write_Byte_Cnt      (S5_Write_Byte_Cnt),
           .S6_Write_Byte_Cnt      (S6_Write_Byte_Cnt),
           .S7_Write_Byte_Cnt      (S7_Write_Byte_Cnt),
           .S0_Slv_Wr_Idle_Cnt      (S0_Slv_Wr_Idle_Cnt),
           .S1_Slv_Wr_Idle_Cnt      (S1_Slv_Wr_Idle_Cnt),
           .S2_Slv_Wr_Idle_Cnt      (S2_Slv_Wr_Idle_Cnt),
           .S3_Slv_Wr_Idle_Cnt      (S3_Slv_Wr_Idle_Cnt),
           .S4_Slv_Wr_Idle_Cnt      (S4_Slv_Wr_Idle_Cnt),
           .S5_Slv_Wr_Idle_Cnt      (S5_Slv_Wr_Idle_Cnt),
           .S6_Slv_Wr_Idle_Cnt      (S6_Slv_Wr_Idle_Cnt),
           .S7_Slv_Wr_Idle_Cnt      (S7_Slv_Wr_Idle_Cnt),
       .S0_Write_Beat_Cnt       (S0_Write_Beat_Cnt),
       .S1_Write_Beat_Cnt       (S1_Write_Beat_Cnt),
       .S2_Write_Beat_Cnt       (S2_Write_Beat_Cnt),
       .S3_Write_Beat_Cnt       (S3_Write_Beat_Cnt),
       .S4_Write_Beat_Cnt       (S4_Write_Beat_Cnt),
       .S5_Write_Beat_Cnt       (S5_Write_Beat_Cnt),
       .S6_Write_Beat_Cnt       (S6_Write_Beat_Cnt),
       .S7_Write_Beat_Cnt       (S7_Write_Beat_Cnt),
           .S0_Read_Byte_Cnt       (S0_Read_Byte_Cnt),
     .S0_Read_Byte_Cnt_En       (S0_Read_Byte_Cnt_En),
           .S1_Read_Byte_Cnt       (S1_Read_Byte_Cnt),
           .S1_Read_Byte_Cnt_En       (S1_Read_Byte_Cnt_En),
           .S2_Read_Byte_Cnt       (S2_Read_Byte_Cnt),
           .S2_Read_Byte_Cnt_En       (S2_Read_Byte_Cnt_En),
           .S3_Read_Byte_Cnt       (S3_Read_Byte_Cnt),
           .S3_Read_Byte_Cnt_En       (S3_Read_Byte_Cnt_En),
           .S4_Read_Byte_Cnt       (S4_Read_Byte_Cnt),
           .S4_Read_Byte_Cnt_En       (S4_Read_Byte_Cnt_En),
           .S5_Read_Byte_Cnt       (S5_Read_Byte_Cnt),
           .S5_Read_Byte_Cnt_En       (S5_Read_Byte_Cnt_En),
           .S6_Read_Byte_Cnt       (S6_Read_Byte_Cnt),
           .S6_Read_Byte_Cnt_En       (S6_Read_Byte_Cnt_En),
           .S7_Read_Byte_Cnt       (S7_Read_Byte_Cnt),
           .S7_Read_Byte_Cnt_En       (S7_Read_Byte_Cnt_En),
           .Write_Beat_Cnt_En      (Write_Beat_Cnt_En),
           .Read_Beat_Cnt_En       (Read_Beat_Cnt_En),
           .S0_Read_Latency        (S0_Read_Latency),
           .S1_Read_Latency        (S1_Read_Latency),
           .S2_Read_Latency        (S2_Read_Latency),
           .S3_Read_Latency        (S3_Read_Latency),
           .S4_Read_Latency        (S4_Read_Latency),
           .S5_Read_Latency        (S5_Read_Latency),
           .S6_Read_Latency        (S6_Read_Latency),
           .S7_Read_Latency        (S7_Read_Latency),
           .S0_Write_Latency       (S0_Write_Latency),
           .S1_Write_Latency       (S1_Write_Latency),
           .S2_Write_Latency       (S2_Write_Latency),
           .S3_Write_Latency       (S3_Write_Latency),
           .S4_Write_Latency       (S4_Write_Latency),
           .S5_Write_Latency       (S5_Write_Latency),
           .S6_Write_Latency       (S6_Write_Latency),
           .S7_Write_Latency       (S7_Write_Latency),
           .Read_Latency_En        (Read_Latency_En),    
           .Write_Latency_En       (Write_Latency_En),   
           .Slv_Wr_Idle_Cnt_En     (Slv_Wr_Idle_Cnt_En), 
           .Mst_Rd_Idle_Cnt_En     (Mst_Rd_Idle_Cnt_En), 
           .Num_BValids_En         (Num_BValids_En),     
           .Num_WLasts_En          (Num_WLasts_En),      
           .Num_RLasts_En          (Num_RLasts_En),      
           .S_Transfer_Cnt_En      (S_Transfer_Cnt_En),
           .S_Packet_Cnt_En        (S_Packet_Cnt_En),  
           .S0_S_Data_Byte_Cnt     (S0_S_Data_Byte_Cnt),
           .S1_S_Data_Byte_Cnt     (S1_S_Data_Byte_Cnt),
           .S2_S_Data_Byte_Cnt     (S2_S_Data_Byte_Cnt),
           .S3_S_Data_Byte_Cnt     (S3_S_Data_Byte_Cnt),
           .S4_S_Data_Byte_Cnt     (S4_S_Data_Byte_Cnt),
           .S5_S_Data_Byte_Cnt     (S5_S_Data_Byte_Cnt),
           .S6_S_Data_Byte_Cnt     (S6_S_Data_Byte_Cnt),
           .S7_S_Data_Byte_Cnt     (S7_S_Data_Byte_Cnt),
           .S0_S_Position_Byte_Cnt (S0_S_Position_Byte_Cnt),
           .S1_S_Position_Byte_Cnt (S1_S_Position_Byte_Cnt),
           .S2_S_Position_Byte_Cnt (S2_S_Position_Byte_Cnt),
           .S3_S_Position_Byte_Cnt (S3_S_Position_Byte_Cnt),
           .S4_S_Position_Byte_Cnt (S4_S_Position_Byte_Cnt),
           .S5_S_Position_Byte_Cnt (S5_S_Position_Byte_Cnt),
           .S6_S_Position_Byte_Cnt (S6_S_Position_Byte_Cnt),
           .S7_S_Position_Byte_Cnt (S7_S_Position_Byte_Cnt),
           .S0_S_Null_Byte_Cnt     (S0_S_Null_Byte_Cnt),
           .S1_S_Null_Byte_Cnt     (S1_S_Null_Byte_Cnt),
           .S2_S_Null_Byte_Cnt     (S2_S_Null_Byte_Cnt),
           .S3_S_Null_Byte_Cnt     (S3_S_Null_Byte_Cnt),
           .S4_S_Null_Byte_Cnt     (S4_S_Null_Byte_Cnt),
           .S5_S_Null_Byte_Cnt     (S5_S_Null_Byte_Cnt),
           .S6_S_Null_Byte_Cnt     (S6_S_Null_Byte_Cnt),
           .S7_S_Null_Byte_Cnt     (S7_S_Null_Byte_Cnt),
           .S_Slv_Idle_Cnt_En      (S_Slv_Idle_Cnt_En),
           .S_Mst_Idle_Cnt_En      (S_Mst_Idle_Cnt_En),
           .S0_Max_Write_Latency   (S0_Max_Write_Latency),         
           .S1_Max_Write_Latency   (S1_Max_Write_Latency),         
           .S2_Max_Write_Latency   (S2_Max_Write_Latency),         
           .S3_Max_Write_Latency   (S3_Max_Write_Latency),         
           .S4_Max_Write_Latency   (S4_Max_Write_Latency),         
           .S5_Max_Write_Latency   (S5_Max_Write_Latency),         
           .S6_Max_Write_Latency   (S6_Max_Write_Latency),         
           .S7_Max_Write_Latency   (S7_Max_Write_Latency),         
           .S0_Min_Write_Latency   (S0_Min_Write_Latency),       
           .S1_Min_Write_Latency   (S1_Min_Write_Latency),       
           .S2_Min_Write_Latency   (S2_Min_Write_Latency),       
           .S3_Min_Write_Latency   (S3_Min_Write_Latency),       
           .S4_Min_Write_Latency   (S4_Min_Write_Latency),       
           .S5_Min_Write_Latency   (S5_Min_Write_Latency),       
           .S6_Min_Write_Latency   (S6_Min_Write_Latency),       
           .S7_Min_Write_Latency   (S7_Min_Write_Latency),       
           .S0_Max_Read_Latency    (S0_Max_Read_Latency),                  
           .S1_Max_Read_Latency    (S1_Max_Read_Latency),                  
           .S2_Max_Read_Latency    (S2_Max_Read_Latency),                  
           .S3_Max_Read_Latency    (S3_Max_Read_Latency),                  
           .S4_Max_Read_Latency    (S4_Max_Read_Latency),                  
           .S5_Max_Read_Latency    (S5_Max_Read_Latency),                  
           .S6_Max_Read_Latency    (S6_Max_Read_Latency),                  
           .S7_Max_Read_Latency    (S7_Max_Read_Latency),                  
           .S0_Min_Read_Latency    (S0_Min_Read_Latency), 
           .S1_Min_Read_Latency    (S1_Min_Read_Latency), 
           .S2_Min_Read_Latency    (S2_Min_Read_Latency), 
           .S3_Min_Read_Latency    (S3_Min_Read_Latency), 
           .S4_Min_Read_Latency    (S4_Min_Read_Latency), 
           .S5_Min_Read_Latency    (S5_Min_Read_Latency), 
           .S6_Min_Read_Latency    (S6_Min_Read_Latency), 
           .S7_Min_Read_Latency    (S7_Min_Read_Latency), 
           .External_Event_Cnt_En  (External_Event_Cnt_En),
           .Metrics_Cnt_En         (Metrics_Cnt_En),
           .Metrics_Cnt_Reset      (Metrics_Cnt_Reset),
           .Metric_Sel             (Metric_Sel_4),
           .Range_Reg              (Range_Reg_4),
           .Metric_Cnt             (Metric_Cnt_4),
           .Incrementer            (Incrementer_4),
           .Acc_OF                 (Acc_OF_4),
           .Incr_OF                (Incr_OF_4)
       );
    
end    
else begin : GEN_NO_METRIC_CNT_4
    assign Metric_Cnt_4  = 0;
    assign Incrementer_4 = 0;
    assign Acc_OF_4      = 1'b0;
    assign Incr_OF_4     = 1'b0;

end
endgenerate



//-- Metric Counter_5
generate
if (C_NUM_OF_COUNTERS > 5) begin : GEN_METRIC_CNT_5

    //-- Mux n Metric Counter_5
    axi_perf_mon_v5_0_12_metric_sel_n_cnt 
      #(
           .C_FAMILY             (C_FAMILY),
           .C_NUM_MONITOR_SLOTS  (C_NUM_MONITOR_SLOTS), 
           .C_ENABLE_EVENT_COUNT (C_ENABLE_EVENT_COUNT),
           .C_METRIC_COUNT_WIDTH (C_METRIC_COUNT_WIDTH),
           .C_METRIC_COUNT_SCALE (C_METRIC_COUNT_SCALE),
           .COUNTER_LOAD_VALUE   (COUNTER_LOAD_VALUE)  

       ) axi_perf_mon_v5_0_12_metric_sel_n_cnt_inst_5 
       (
           .clk                    (clk),
           .rst_n                  (rst_n),
           .Wtrans_Cnt_En          (Wtrans_Cnt_En),
           .Rtrans_Cnt_En          (Rtrans_Cnt_En),
           .S0_Write_Byte_Cnt      (S0_Write_Byte_Cnt),
           .S1_Write_Byte_Cnt      (S1_Write_Byte_Cnt),
           .S2_Write_Byte_Cnt      (S2_Write_Byte_Cnt),
           .S3_Write_Byte_Cnt      (S3_Write_Byte_Cnt),
           .S4_Write_Byte_Cnt      (S4_Write_Byte_Cnt),
           .S5_Write_Byte_Cnt      (S5_Write_Byte_Cnt),
           .S6_Write_Byte_Cnt      (S6_Write_Byte_Cnt),
           .S7_Write_Byte_Cnt      (S7_Write_Byte_Cnt),
           .S0_Slv_Wr_Idle_Cnt      (S0_Slv_Wr_Idle_Cnt),
           .S1_Slv_Wr_Idle_Cnt      (S1_Slv_Wr_Idle_Cnt),
           .S2_Slv_Wr_Idle_Cnt      (S2_Slv_Wr_Idle_Cnt),
           .S3_Slv_Wr_Idle_Cnt      (S3_Slv_Wr_Idle_Cnt),
           .S4_Slv_Wr_Idle_Cnt      (S4_Slv_Wr_Idle_Cnt),
           .S5_Slv_Wr_Idle_Cnt      (S5_Slv_Wr_Idle_Cnt),
           .S6_Slv_Wr_Idle_Cnt      (S6_Slv_Wr_Idle_Cnt),
           .S7_Slv_Wr_Idle_Cnt      (S7_Slv_Wr_Idle_Cnt),
       .S0_Write_Beat_Cnt       (S0_Write_Beat_Cnt),
       .S1_Write_Beat_Cnt       (S1_Write_Beat_Cnt),
       .S2_Write_Beat_Cnt       (S2_Write_Beat_Cnt),
       .S3_Write_Beat_Cnt       (S3_Write_Beat_Cnt),
       .S4_Write_Beat_Cnt       (S4_Write_Beat_Cnt),
       .S5_Write_Beat_Cnt       (S5_Write_Beat_Cnt),
       .S6_Write_Beat_Cnt       (S6_Write_Beat_Cnt),
       .S7_Write_Beat_Cnt       (S7_Write_Beat_Cnt),
           .S0_Read_Byte_Cnt       (S0_Read_Byte_Cnt),
     .S0_Read_Byte_Cnt_En       (S0_Read_Byte_Cnt_En),
           .S1_Read_Byte_Cnt       (S1_Read_Byte_Cnt),
           .S1_Read_Byte_Cnt_En       (S1_Read_Byte_Cnt_En),
           .S2_Read_Byte_Cnt       (S2_Read_Byte_Cnt),
           .S2_Read_Byte_Cnt_En       (S2_Read_Byte_Cnt_En),
           .S3_Read_Byte_Cnt       (S3_Read_Byte_Cnt),
           .S3_Read_Byte_Cnt_En       (S3_Read_Byte_Cnt_En),
           .S4_Read_Byte_Cnt       (S4_Read_Byte_Cnt),
           .S4_Read_Byte_Cnt_En       (S4_Read_Byte_Cnt_En),
           .S5_Read_Byte_Cnt       (S5_Read_Byte_Cnt),
           .S5_Read_Byte_Cnt_En       (S5_Read_Byte_Cnt_En),
           .S6_Read_Byte_Cnt       (S6_Read_Byte_Cnt),
           .S6_Read_Byte_Cnt_En       (S6_Read_Byte_Cnt_En),
           .S7_Read_Byte_Cnt       (S7_Read_Byte_Cnt),
           .S7_Read_Byte_Cnt_En       (S7_Read_Byte_Cnt_En),
           .Write_Beat_Cnt_En      (Write_Beat_Cnt_En),
           .Read_Beat_Cnt_En       (Read_Beat_Cnt_En),
           .S0_Read_Latency        (S0_Read_Latency),
           .S1_Read_Latency        (S1_Read_Latency),
           .S2_Read_Latency        (S2_Read_Latency),
           .S3_Read_Latency        (S3_Read_Latency),
           .S4_Read_Latency        (S4_Read_Latency),
           .S5_Read_Latency        (S5_Read_Latency),
           .S6_Read_Latency        (S6_Read_Latency),
           .S7_Read_Latency        (S7_Read_Latency),
           .S0_Write_Latency       (S0_Write_Latency),
           .S1_Write_Latency       (S1_Write_Latency),
           .S2_Write_Latency       (S2_Write_Latency),
           .S3_Write_Latency       (S3_Write_Latency),
           .S4_Write_Latency       (S4_Write_Latency),
           .S5_Write_Latency       (S5_Write_Latency),
           .S6_Write_Latency       (S6_Write_Latency),
           .S7_Write_Latency       (S7_Write_Latency),
           .Read_Latency_En        (Read_Latency_En),    
           .Write_Latency_En       (Write_Latency_En),   
           .Slv_Wr_Idle_Cnt_En     (Slv_Wr_Idle_Cnt_En), 
           .Mst_Rd_Idle_Cnt_En     (Mst_Rd_Idle_Cnt_En), 
           .Num_BValids_En         (Num_BValids_En),     
           .Num_WLasts_En          (Num_WLasts_En),      
           .Num_RLasts_En          (Num_RLasts_En),      
           .S_Transfer_Cnt_En      (S_Transfer_Cnt_En),
           .S_Packet_Cnt_En        (S_Packet_Cnt_En),  
           .S0_S_Data_Byte_Cnt     (S0_S_Data_Byte_Cnt),
           .S1_S_Data_Byte_Cnt     (S1_S_Data_Byte_Cnt),
           .S2_S_Data_Byte_Cnt     (S2_S_Data_Byte_Cnt),
           .S3_S_Data_Byte_Cnt     (S3_S_Data_Byte_Cnt),
           .S4_S_Data_Byte_Cnt     (S4_S_Data_Byte_Cnt),
           .S5_S_Data_Byte_Cnt     (S5_S_Data_Byte_Cnt),
           .S6_S_Data_Byte_Cnt     (S6_S_Data_Byte_Cnt),
           .S7_S_Data_Byte_Cnt     (S7_S_Data_Byte_Cnt),
           .S0_S_Position_Byte_Cnt (S0_S_Position_Byte_Cnt),
           .S1_S_Position_Byte_Cnt (S1_S_Position_Byte_Cnt),
           .S2_S_Position_Byte_Cnt (S2_S_Position_Byte_Cnt),
           .S3_S_Position_Byte_Cnt (S3_S_Position_Byte_Cnt),
           .S4_S_Position_Byte_Cnt (S4_S_Position_Byte_Cnt),
           .S5_S_Position_Byte_Cnt (S5_S_Position_Byte_Cnt),
           .S6_S_Position_Byte_Cnt (S6_S_Position_Byte_Cnt),
           .S7_S_Position_Byte_Cnt (S7_S_Position_Byte_Cnt),
           .S0_S_Null_Byte_Cnt     (S0_S_Null_Byte_Cnt),
           .S1_S_Null_Byte_Cnt     (S1_S_Null_Byte_Cnt),
           .S2_S_Null_Byte_Cnt     (S2_S_Null_Byte_Cnt),
           .S3_S_Null_Byte_Cnt     (S3_S_Null_Byte_Cnt),
           .S4_S_Null_Byte_Cnt     (S4_S_Null_Byte_Cnt),
           .S5_S_Null_Byte_Cnt     (S5_S_Null_Byte_Cnt),
           .S6_S_Null_Byte_Cnt     (S6_S_Null_Byte_Cnt),
           .S7_S_Null_Byte_Cnt     (S7_S_Null_Byte_Cnt),
           .S_Slv_Idle_Cnt_En      (S_Slv_Idle_Cnt_En),
           .S_Mst_Idle_Cnt_En      (S_Mst_Idle_Cnt_En),
           .S0_Max_Write_Latency   (S0_Max_Write_Latency),         
           .S1_Max_Write_Latency   (S1_Max_Write_Latency),         
           .S2_Max_Write_Latency   (S2_Max_Write_Latency),         
           .S3_Max_Write_Latency   (S3_Max_Write_Latency),         
           .S4_Max_Write_Latency   (S4_Max_Write_Latency),         
           .S5_Max_Write_Latency   (S5_Max_Write_Latency),         
           .S6_Max_Write_Latency   (S6_Max_Write_Latency),         
           .S7_Max_Write_Latency   (S7_Max_Write_Latency),         
           .S0_Min_Write_Latency   (S0_Min_Write_Latency),       
           .S1_Min_Write_Latency   (S1_Min_Write_Latency),       
           .S2_Min_Write_Latency   (S2_Min_Write_Latency),       
           .S3_Min_Write_Latency   (S3_Min_Write_Latency),       
           .S4_Min_Write_Latency   (S4_Min_Write_Latency),       
           .S5_Min_Write_Latency   (S5_Min_Write_Latency),       
           .S6_Min_Write_Latency   (S6_Min_Write_Latency),       
           .S7_Min_Write_Latency   (S7_Min_Write_Latency),       
           .S0_Max_Read_Latency    (S0_Max_Read_Latency),                  
           .S1_Max_Read_Latency    (S1_Max_Read_Latency),                  
           .S2_Max_Read_Latency    (S2_Max_Read_Latency),                  
           .S3_Max_Read_Latency    (S3_Max_Read_Latency),                  
           .S4_Max_Read_Latency    (S4_Max_Read_Latency),                  
           .S5_Max_Read_Latency    (S5_Max_Read_Latency),                  
           .S6_Max_Read_Latency    (S6_Max_Read_Latency),                  
           .S7_Max_Read_Latency    (S7_Max_Read_Latency),                  
           .S0_Min_Read_Latency    (S0_Min_Read_Latency), 
           .S1_Min_Read_Latency    (S1_Min_Read_Latency), 
           .S2_Min_Read_Latency    (S2_Min_Read_Latency), 
           .S3_Min_Read_Latency    (S3_Min_Read_Latency), 
           .S4_Min_Read_Latency    (S4_Min_Read_Latency), 
           .S5_Min_Read_Latency    (S5_Min_Read_Latency), 
           .S6_Min_Read_Latency    (S6_Min_Read_Latency), 
           .S7_Min_Read_Latency    (S7_Min_Read_Latency), 
           .External_Event_Cnt_En  (External_Event_Cnt_En),
           .Metrics_Cnt_En         (Metrics_Cnt_En),
           .Metrics_Cnt_Reset      (Metrics_Cnt_Reset),
           .Metric_Sel             (Metric_Sel_5),
           .Range_Reg              (Range_Reg_5),
           .Metric_Cnt             (Metric_Cnt_5),
           .Incrementer            (Incrementer_5),
           .Acc_OF                 (Acc_OF_5),
           .Incr_OF                (Incr_OF_5)
       );
    
end    
else begin : GEN_NO_METRIC_CNT_5
    assign Metric_Cnt_5  = 0;
    assign Incrementer_5 = 0;
    assign Acc_OF_5      = 1'b0;
    assign Incr_OF_5     = 1'b0;

end
endgenerate




//-- Metric Counter_6
generate
if (C_NUM_OF_COUNTERS > 6) begin : GEN_METRIC_CNT_6

    //-- Mux n Metric Counter_6
    axi_perf_mon_v5_0_12_metric_sel_n_cnt 
      #(
           .C_FAMILY             (C_FAMILY),
           .C_NUM_MONITOR_SLOTS  (C_NUM_MONITOR_SLOTS), 
           .C_ENABLE_EVENT_COUNT (C_ENABLE_EVENT_COUNT),
           .C_METRIC_COUNT_WIDTH (C_METRIC_COUNT_WIDTH),
           .C_METRIC_COUNT_SCALE (C_METRIC_COUNT_SCALE),
           .COUNTER_LOAD_VALUE   (COUNTER_LOAD_VALUE)  

       ) axi_perf_mon_v5_0_12_metric_sel_n_cnt_inst_6 
       (
           .clk                    (clk),
           .rst_n                  (rst_n),
           .Wtrans_Cnt_En          (Wtrans_Cnt_En),
           .Rtrans_Cnt_En          (Rtrans_Cnt_En),
           .S0_Write_Byte_Cnt      (S0_Write_Byte_Cnt),
           .S1_Write_Byte_Cnt      (S1_Write_Byte_Cnt),
           .S2_Write_Byte_Cnt      (S2_Write_Byte_Cnt),
           .S3_Write_Byte_Cnt      (S3_Write_Byte_Cnt),
           .S4_Write_Byte_Cnt      (S4_Write_Byte_Cnt),
           .S5_Write_Byte_Cnt      (S5_Write_Byte_Cnt),
           .S6_Write_Byte_Cnt      (S6_Write_Byte_Cnt),
           .S7_Write_Byte_Cnt      (S7_Write_Byte_Cnt),
           .S0_Slv_Wr_Idle_Cnt      (S0_Slv_Wr_Idle_Cnt),
           .S1_Slv_Wr_Idle_Cnt      (S1_Slv_Wr_Idle_Cnt),
           .S2_Slv_Wr_Idle_Cnt      (S2_Slv_Wr_Idle_Cnt),
           .S3_Slv_Wr_Idle_Cnt      (S3_Slv_Wr_Idle_Cnt),
           .S4_Slv_Wr_Idle_Cnt      (S4_Slv_Wr_Idle_Cnt),
           .S5_Slv_Wr_Idle_Cnt      (S5_Slv_Wr_Idle_Cnt),
           .S6_Slv_Wr_Idle_Cnt      (S6_Slv_Wr_Idle_Cnt),
           .S7_Slv_Wr_Idle_Cnt      (S7_Slv_Wr_Idle_Cnt),
       .S0_Write_Beat_Cnt       (S0_Write_Beat_Cnt),
       .S1_Write_Beat_Cnt       (S1_Write_Beat_Cnt),
       .S2_Write_Beat_Cnt       (S2_Write_Beat_Cnt),
       .S3_Write_Beat_Cnt       (S3_Write_Beat_Cnt),
       .S4_Write_Beat_Cnt       (S4_Write_Beat_Cnt),
       .S5_Write_Beat_Cnt       (S5_Write_Beat_Cnt),
       .S6_Write_Beat_Cnt       (S6_Write_Beat_Cnt),
       .S7_Write_Beat_Cnt       (S7_Write_Beat_Cnt),
           .S0_Read_Byte_Cnt       (S0_Read_Byte_Cnt),
     .S0_Read_Byte_Cnt_En       (S0_Read_Byte_Cnt_En),
           .S1_Read_Byte_Cnt       (S1_Read_Byte_Cnt),
           .S1_Read_Byte_Cnt_En       (S1_Read_Byte_Cnt_En),
           .S2_Read_Byte_Cnt       (S2_Read_Byte_Cnt),
           .S2_Read_Byte_Cnt_En       (S2_Read_Byte_Cnt_En),
           .S3_Read_Byte_Cnt       (S3_Read_Byte_Cnt),
           .S3_Read_Byte_Cnt_En       (S3_Read_Byte_Cnt_En),
           .S4_Read_Byte_Cnt       (S4_Read_Byte_Cnt),
           .S4_Read_Byte_Cnt_En       (S4_Read_Byte_Cnt_En),
           .S5_Read_Byte_Cnt       (S5_Read_Byte_Cnt),
           .S5_Read_Byte_Cnt_En       (S5_Read_Byte_Cnt_En),
           .S6_Read_Byte_Cnt       (S6_Read_Byte_Cnt),
           .S6_Read_Byte_Cnt_En       (S6_Read_Byte_Cnt_En),
           .S7_Read_Byte_Cnt       (S7_Read_Byte_Cnt),
           .S7_Read_Byte_Cnt_En       (S7_Read_Byte_Cnt_En),
           .Write_Beat_Cnt_En      (Write_Beat_Cnt_En),
           .Read_Beat_Cnt_En       (Read_Beat_Cnt_En),
           .S0_Read_Latency        (S0_Read_Latency),
           .S1_Read_Latency        (S1_Read_Latency),
           .S2_Read_Latency        (S2_Read_Latency),
           .S3_Read_Latency        (S3_Read_Latency),
           .S4_Read_Latency        (S4_Read_Latency),
           .S5_Read_Latency        (S5_Read_Latency),
           .S6_Read_Latency        (S6_Read_Latency),
           .S7_Read_Latency        (S7_Read_Latency),
           .S0_Write_Latency       (S0_Write_Latency),
           .S1_Write_Latency       (S1_Write_Latency),
           .S2_Write_Latency       (S2_Write_Latency),
           .S3_Write_Latency       (S3_Write_Latency),
           .S4_Write_Latency       (S4_Write_Latency),
           .S5_Write_Latency       (S5_Write_Latency),
           .S6_Write_Latency       (S6_Write_Latency),
           .S7_Write_Latency       (S7_Write_Latency),
           .Read_Latency_En        (Read_Latency_En),    
           .Write_Latency_En       (Write_Latency_En),   
           .Slv_Wr_Idle_Cnt_En     (Slv_Wr_Idle_Cnt_En), 
           .Mst_Rd_Idle_Cnt_En     (Mst_Rd_Idle_Cnt_En), 
           .Num_BValids_En         (Num_BValids_En),     
           .Num_WLasts_En          (Num_WLasts_En),      
           .Num_RLasts_En          (Num_RLasts_En),      
           .S_Transfer_Cnt_En      (S_Transfer_Cnt_En),
           .S_Packet_Cnt_En        (S_Packet_Cnt_En),  
           .S0_S_Data_Byte_Cnt     (S0_S_Data_Byte_Cnt),
           .S1_S_Data_Byte_Cnt     (S1_S_Data_Byte_Cnt),
           .S2_S_Data_Byte_Cnt     (S2_S_Data_Byte_Cnt),
           .S3_S_Data_Byte_Cnt     (S3_S_Data_Byte_Cnt),
           .S4_S_Data_Byte_Cnt     (S4_S_Data_Byte_Cnt),
           .S5_S_Data_Byte_Cnt     (S5_S_Data_Byte_Cnt),
           .S6_S_Data_Byte_Cnt     (S6_S_Data_Byte_Cnt),
           .S7_S_Data_Byte_Cnt     (S7_S_Data_Byte_Cnt),
           .S0_S_Position_Byte_Cnt (S0_S_Position_Byte_Cnt),
           .S1_S_Position_Byte_Cnt (S1_S_Position_Byte_Cnt),
           .S2_S_Position_Byte_Cnt (S2_S_Position_Byte_Cnt),
           .S3_S_Position_Byte_Cnt (S3_S_Position_Byte_Cnt),
           .S4_S_Position_Byte_Cnt (S4_S_Position_Byte_Cnt),
           .S5_S_Position_Byte_Cnt (S5_S_Position_Byte_Cnt),
           .S6_S_Position_Byte_Cnt (S6_S_Position_Byte_Cnt),
           .S7_S_Position_Byte_Cnt (S7_S_Position_Byte_Cnt),
           .S0_S_Null_Byte_Cnt     (S0_S_Null_Byte_Cnt),
           .S1_S_Null_Byte_Cnt     (S1_S_Null_Byte_Cnt),
           .S2_S_Null_Byte_Cnt     (S2_S_Null_Byte_Cnt),
           .S3_S_Null_Byte_Cnt     (S3_S_Null_Byte_Cnt),
           .S4_S_Null_Byte_Cnt     (S4_S_Null_Byte_Cnt),
           .S5_S_Null_Byte_Cnt     (S5_S_Null_Byte_Cnt),
           .S6_S_Null_Byte_Cnt     (S6_S_Null_Byte_Cnt),
           .S7_S_Null_Byte_Cnt     (S7_S_Null_Byte_Cnt),
           .S_Slv_Idle_Cnt_En      (S_Slv_Idle_Cnt_En),
           .S_Mst_Idle_Cnt_En      (S_Mst_Idle_Cnt_En),
           .S0_Max_Write_Latency   (S0_Max_Write_Latency),         
           .S1_Max_Write_Latency   (S1_Max_Write_Latency),         
           .S2_Max_Write_Latency   (S2_Max_Write_Latency),         
           .S3_Max_Write_Latency   (S3_Max_Write_Latency),         
           .S4_Max_Write_Latency   (S4_Max_Write_Latency),         
           .S5_Max_Write_Latency   (S5_Max_Write_Latency),         
           .S6_Max_Write_Latency   (S6_Max_Write_Latency),         
           .S7_Max_Write_Latency   (S7_Max_Write_Latency),         
           .S0_Min_Write_Latency   (S0_Min_Write_Latency),       
           .S1_Min_Write_Latency   (S1_Min_Write_Latency),       
           .S2_Min_Write_Latency   (S2_Min_Write_Latency),       
           .S3_Min_Write_Latency   (S3_Min_Write_Latency),       
           .S4_Min_Write_Latency   (S4_Min_Write_Latency),       
           .S5_Min_Write_Latency   (S5_Min_Write_Latency),       
           .S6_Min_Write_Latency   (S6_Min_Write_Latency),       
           .S7_Min_Write_Latency   (S7_Min_Write_Latency),       
           .S0_Max_Read_Latency    (S0_Max_Read_Latency),                  
           .S1_Max_Read_Latency    (S1_Max_Read_Latency),                  
           .S2_Max_Read_Latency    (S2_Max_Read_Latency),                  
           .S3_Max_Read_Latency    (S3_Max_Read_Latency),                  
           .S4_Max_Read_Latency    (S4_Max_Read_Latency),                  
           .S5_Max_Read_Latency    (S5_Max_Read_Latency),                  
           .S6_Max_Read_Latency    (S6_Max_Read_Latency),                  
           .S7_Max_Read_Latency    (S7_Max_Read_Latency),                  
           .S0_Min_Read_Latency    (S0_Min_Read_Latency), 
           .S1_Min_Read_Latency    (S1_Min_Read_Latency), 
           .S2_Min_Read_Latency    (S2_Min_Read_Latency), 
           .S3_Min_Read_Latency    (S3_Min_Read_Latency), 
           .S4_Min_Read_Latency    (S4_Min_Read_Latency), 
           .S5_Min_Read_Latency    (S5_Min_Read_Latency), 
           .S6_Min_Read_Latency    (S6_Min_Read_Latency), 
           .S7_Min_Read_Latency    (S7_Min_Read_Latency), 
           .External_Event_Cnt_En  (External_Event_Cnt_En),
           .Metrics_Cnt_En         (Metrics_Cnt_En),
           .Metrics_Cnt_Reset      (Metrics_Cnt_Reset),
           .Metric_Sel             (Metric_Sel_6),
           .Range_Reg              (Range_Reg_6),
           .Metric_Cnt             (Metric_Cnt_6),
           .Incrementer            (Incrementer_6),
           .Acc_OF                 (Acc_OF_6),
           .Incr_OF                (Incr_OF_6)
       );
    
end    
else begin : GEN_NO_METRIC_CNT_6
    assign Metric_Cnt_6  = 0;
    assign Incrementer_6 = 0;
    assign Acc_OF_6      = 1'b0;
    assign Incr_OF_6     = 1'b0;

end
endgenerate




//-- Metric Counter_7
generate
if (C_NUM_OF_COUNTERS > 7) begin : GEN_METRIC_CNT_7

    //-- Mux n Metric Counter_7
    axi_perf_mon_v5_0_12_metric_sel_n_cnt 
      #(
           .C_FAMILY             (C_FAMILY),
           .C_NUM_MONITOR_SLOTS  (C_NUM_MONITOR_SLOTS), 
           .C_ENABLE_EVENT_COUNT (C_ENABLE_EVENT_COUNT),
           .C_METRIC_COUNT_WIDTH (C_METRIC_COUNT_WIDTH),
           .C_METRIC_COUNT_SCALE (C_METRIC_COUNT_SCALE),
           .COUNTER_LOAD_VALUE   (COUNTER_LOAD_VALUE)  

       ) axi_perf_mon_v5_0_12_metric_sel_n_cnt_inst_7 
       (
           .clk                    (clk),
           .rst_n                  (rst_n),
           .Wtrans_Cnt_En          (Wtrans_Cnt_En),
           .Rtrans_Cnt_En          (Rtrans_Cnt_En),
           .S0_Write_Byte_Cnt      (S0_Write_Byte_Cnt),
           .S1_Write_Byte_Cnt      (S1_Write_Byte_Cnt),
           .S2_Write_Byte_Cnt      (S2_Write_Byte_Cnt),
           .S3_Write_Byte_Cnt      (S3_Write_Byte_Cnt),
           .S4_Write_Byte_Cnt      (S4_Write_Byte_Cnt),
           .S5_Write_Byte_Cnt      (S5_Write_Byte_Cnt),
           .S6_Write_Byte_Cnt      (S6_Write_Byte_Cnt),
           .S7_Write_Byte_Cnt      (S7_Write_Byte_Cnt),
           .S0_Slv_Wr_Idle_Cnt      (S0_Slv_Wr_Idle_Cnt),
           .S1_Slv_Wr_Idle_Cnt      (S1_Slv_Wr_Idle_Cnt),
           .S2_Slv_Wr_Idle_Cnt      (S2_Slv_Wr_Idle_Cnt),
           .S3_Slv_Wr_Idle_Cnt      (S3_Slv_Wr_Idle_Cnt),
           .S4_Slv_Wr_Idle_Cnt      (S4_Slv_Wr_Idle_Cnt),
           .S5_Slv_Wr_Idle_Cnt      (S5_Slv_Wr_Idle_Cnt),
           .S6_Slv_Wr_Idle_Cnt      (S6_Slv_Wr_Idle_Cnt),
           .S7_Slv_Wr_Idle_Cnt      (S7_Slv_Wr_Idle_Cnt),
       .S0_Write_Beat_Cnt       (S0_Write_Beat_Cnt),
       .S1_Write_Beat_Cnt       (S1_Write_Beat_Cnt),
       .S2_Write_Beat_Cnt       (S2_Write_Beat_Cnt),
       .S3_Write_Beat_Cnt       (S3_Write_Beat_Cnt),
       .S4_Write_Beat_Cnt       (S4_Write_Beat_Cnt),
       .S5_Write_Beat_Cnt       (S5_Write_Beat_Cnt),
       .S6_Write_Beat_Cnt       (S6_Write_Beat_Cnt),
       .S7_Write_Beat_Cnt       (S7_Write_Beat_Cnt),
           .S0_Read_Byte_Cnt       (S0_Read_Byte_Cnt),
     .S0_Read_Byte_Cnt_En       (S0_Read_Byte_Cnt_En),
           .S1_Read_Byte_Cnt       (S1_Read_Byte_Cnt),
           .S1_Read_Byte_Cnt_En       (S1_Read_Byte_Cnt_En),
           .S2_Read_Byte_Cnt       (S2_Read_Byte_Cnt),
           .S2_Read_Byte_Cnt_En       (S2_Read_Byte_Cnt_En),
           .S3_Read_Byte_Cnt       (S3_Read_Byte_Cnt),
           .S3_Read_Byte_Cnt_En       (S3_Read_Byte_Cnt_En),
           .S4_Read_Byte_Cnt       (S4_Read_Byte_Cnt),
           .S4_Read_Byte_Cnt_En       (S4_Read_Byte_Cnt_En),
           .S5_Read_Byte_Cnt       (S5_Read_Byte_Cnt),
           .S5_Read_Byte_Cnt_En       (S5_Read_Byte_Cnt_En),
           .S6_Read_Byte_Cnt       (S6_Read_Byte_Cnt),
           .S6_Read_Byte_Cnt_En       (S6_Read_Byte_Cnt_En),
           .S7_Read_Byte_Cnt       (S7_Read_Byte_Cnt),
           .S7_Read_Byte_Cnt_En       (S7_Read_Byte_Cnt_En),
           .Write_Beat_Cnt_En      (Write_Beat_Cnt_En),
           .Read_Beat_Cnt_En       (Read_Beat_Cnt_En),
           .S0_Read_Latency        (S0_Read_Latency),
           .S1_Read_Latency        (S1_Read_Latency),
           .S2_Read_Latency        (S2_Read_Latency),
           .S3_Read_Latency        (S3_Read_Latency),
           .S4_Read_Latency        (S4_Read_Latency),
           .S5_Read_Latency        (S5_Read_Latency),
           .S6_Read_Latency        (S6_Read_Latency),
           .S7_Read_Latency        (S7_Read_Latency),
           .S0_Write_Latency       (S0_Write_Latency),
           .S1_Write_Latency       (S1_Write_Latency),
           .S2_Write_Latency       (S2_Write_Latency),
           .S3_Write_Latency       (S3_Write_Latency),
           .S4_Write_Latency       (S4_Write_Latency),
           .S5_Write_Latency       (S5_Write_Latency),
           .S6_Write_Latency       (S6_Write_Latency),
           .S7_Write_Latency       (S7_Write_Latency),
           .Read_Latency_En        (Read_Latency_En),    
           .Write_Latency_En       (Write_Latency_En),   
           .Slv_Wr_Idle_Cnt_En     (Slv_Wr_Idle_Cnt_En), 
           .Mst_Rd_Idle_Cnt_En     (Mst_Rd_Idle_Cnt_En), 
           .Num_BValids_En         (Num_BValids_En),     
           .Num_WLasts_En          (Num_WLasts_En),      
           .Num_RLasts_En          (Num_RLasts_En),      
           .S_Transfer_Cnt_En      (S_Transfer_Cnt_En),
           .S_Packet_Cnt_En        (S_Packet_Cnt_En),  
           .S0_S_Data_Byte_Cnt     (S0_S_Data_Byte_Cnt),
           .S1_S_Data_Byte_Cnt     (S1_S_Data_Byte_Cnt),
           .S2_S_Data_Byte_Cnt     (S2_S_Data_Byte_Cnt),
           .S3_S_Data_Byte_Cnt     (S3_S_Data_Byte_Cnt),
           .S4_S_Data_Byte_Cnt     (S4_S_Data_Byte_Cnt),
           .S5_S_Data_Byte_Cnt     (S5_S_Data_Byte_Cnt),
           .S6_S_Data_Byte_Cnt     (S6_S_Data_Byte_Cnt),
           .S7_S_Data_Byte_Cnt     (S7_S_Data_Byte_Cnt),
           .S0_S_Position_Byte_Cnt (S0_S_Position_Byte_Cnt),
           .S1_S_Position_Byte_Cnt (S1_S_Position_Byte_Cnt),
           .S2_S_Position_Byte_Cnt (S2_S_Position_Byte_Cnt),
           .S3_S_Position_Byte_Cnt (S3_S_Position_Byte_Cnt),
           .S4_S_Position_Byte_Cnt (S4_S_Position_Byte_Cnt),
           .S5_S_Position_Byte_Cnt (S5_S_Position_Byte_Cnt),
           .S6_S_Position_Byte_Cnt (S6_S_Position_Byte_Cnt),
           .S7_S_Position_Byte_Cnt (S7_S_Position_Byte_Cnt),
           .S0_S_Null_Byte_Cnt     (S0_S_Null_Byte_Cnt),
           .S1_S_Null_Byte_Cnt     (S1_S_Null_Byte_Cnt),
           .S2_S_Null_Byte_Cnt     (S2_S_Null_Byte_Cnt),
           .S3_S_Null_Byte_Cnt     (S3_S_Null_Byte_Cnt),
           .S4_S_Null_Byte_Cnt     (S4_S_Null_Byte_Cnt),
           .S5_S_Null_Byte_Cnt     (S5_S_Null_Byte_Cnt),
           .S6_S_Null_Byte_Cnt     (S6_S_Null_Byte_Cnt),
           .S7_S_Null_Byte_Cnt     (S7_S_Null_Byte_Cnt),
           .S_Slv_Idle_Cnt_En      (S_Slv_Idle_Cnt_En),
           .S_Mst_Idle_Cnt_En      (S_Mst_Idle_Cnt_En),
           .S0_Max_Write_Latency   (S0_Max_Write_Latency),         
           .S1_Max_Write_Latency   (S1_Max_Write_Latency),         
           .S2_Max_Write_Latency   (S2_Max_Write_Latency),         
           .S3_Max_Write_Latency   (S3_Max_Write_Latency),         
           .S4_Max_Write_Latency   (S4_Max_Write_Latency),         
           .S5_Max_Write_Latency   (S5_Max_Write_Latency),         
           .S6_Max_Write_Latency   (S6_Max_Write_Latency),         
           .S7_Max_Write_Latency   (S7_Max_Write_Latency),         
           .S0_Min_Write_Latency   (S0_Min_Write_Latency),       
           .S1_Min_Write_Latency   (S1_Min_Write_Latency),       
           .S2_Min_Write_Latency   (S2_Min_Write_Latency),       
           .S3_Min_Write_Latency   (S3_Min_Write_Latency),       
           .S4_Min_Write_Latency   (S4_Min_Write_Latency),       
           .S5_Min_Write_Latency   (S5_Min_Write_Latency),       
           .S6_Min_Write_Latency   (S6_Min_Write_Latency),       
           .S7_Min_Write_Latency   (S7_Min_Write_Latency),       
           .S0_Max_Read_Latency    (S0_Max_Read_Latency),                  
           .S1_Max_Read_Latency    (S1_Max_Read_Latency),                  
           .S2_Max_Read_Latency    (S2_Max_Read_Latency),                  
           .S3_Max_Read_Latency    (S3_Max_Read_Latency),                  
           .S4_Max_Read_Latency    (S4_Max_Read_Latency),                  
           .S5_Max_Read_Latency    (S5_Max_Read_Latency),                  
           .S6_Max_Read_Latency    (S6_Max_Read_Latency),                  
           .S7_Max_Read_Latency    (S7_Max_Read_Latency),                  
           .S0_Min_Read_Latency    (S0_Min_Read_Latency), 
           .S1_Min_Read_Latency    (S1_Min_Read_Latency), 
           .S2_Min_Read_Latency    (S2_Min_Read_Latency), 
           .S3_Min_Read_Latency    (S3_Min_Read_Latency), 
           .S4_Min_Read_Latency    (S4_Min_Read_Latency), 
           .S5_Min_Read_Latency    (S5_Min_Read_Latency), 
           .S6_Min_Read_Latency    (S6_Min_Read_Latency), 
           .S7_Min_Read_Latency    (S7_Min_Read_Latency), 
           .External_Event_Cnt_En  (External_Event_Cnt_En),
           .Metrics_Cnt_En         (Metrics_Cnt_En),
           .Metrics_Cnt_Reset      (Metrics_Cnt_Reset),
           .Metric_Sel             (Metric_Sel_7),
           .Range_Reg              (Range_Reg_7),
           .Metric_Cnt             (Metric_Cnt_7),
           .Incrementer            (Incrementer_7),
           .Acc_OF                 (Acc_OF_7),
           .Incr_OF                (Incr_OF_7)
       );
    
end    
else begin : GEN_NO_METRIC_CNT_7
    assign Metric_Cnt_7  = 0;
    assign Incrementer_7 = 0;
    assign Acc_OF_7      = 1'b0;
    assign Incr_OF_7     = 1'b0;

end
endgenerate



//-- Metric Counter_8
generate
if (C_NUM_OF_COUNTERS > 8) begin : GEN_METRIC_CNT_8

    //-- Mux n Metric Counter_8
    axi_perf_mon_v5_0_12_metric_sel_n_cnt 
      #(
           .C_FAMILY             (C_FAMILY),
           .C_NUM_MONITOR_SLOTS  (C_NUM_MONITOR_SLOTS), 
           .C_ENABLE_EVENT_COUNT (C_ENABLE_EVENT_COUNT),
           .C_METRIC_COUNT_WIDTH (C_METRIC_COUNT_WIDTH),
           .C_METRIC_COUNT_SCALE (C_METRIC_COUNT_SCALE),
           .COUNTER_LOAD_VALUE   (COUNTER_LOAD_VALUE)  

       ) axi_perf_mon_v5_0_12_metric_sel_n_cnt_inst_8 
       (
           .clk                    (clk),
           .rst_n                  (rst_n),
           .Wtrans_Cnt_En          (Wtrans_Cnt_En),
           .Rtrans_Cnt_En          (Rtrans_Cnt_En),
           .S0_Write_Byte_Cnt      (S0_Write_Byte_Cnt),
           .S1_Write_Byte_Cnt      (S1_Write_Byte_Cnt),
           .S2_Write_Byte_Cnt      (S2_Write_Byte_Cnt),
           .S3_Write_Byte_Cnt      (S3_Write_Byte_Cnt),
           .S4_Write_Byte_Cnt      (S4_Write_Byte_Cnt),
           .S5_Write_Byte_Cnt      (S5_Write_Byte_Cnt),
           .S6_Write_Byte_Cnt      (S6_Write_Byte_Cnt),
           .S7_Write_Byte_Cnt      (S7_Write_Byte_Cnt),
           .S0_Slv_Wr_Idle_Cnt      (S0_Slv_Wr_Idle_Cnt),
           .S1_Slv_Wr_Idle_Cnt      (S1_Slv_Wr_Idle_Cnt),
           .S2_Slv_Wr_Idle_Cnt      (S2_Slv_Wr_Idle_Cnt),
           .S3_Slv_Wr_Idle_Cnt      (S3_Slv_Wr_Idle_Cnt),
           .S4_Slv_Wr_Idle_Cnt      (S4_Slv_Wr_Idle_Cnt),
           .S5_Slv_Wr_Idle_Cnt      (S5_Slv_Wr_Idle_Cnt),
           .S6_Slv_Wr_Idle_Cnt      (S6_Slv_Wr_Idle_Cnt),
           .S7_Slv_Wr_Idle_Cnt      (S7_Slv_Wr_Idle_Cnt),
       .S0_Write_Beat_Cnt       (S0_Write_Beat_Cnt),
       .S1_Write_Beat_Cnt       (S1_Write_Beat_Cnt),
       .S2_Write_Beat_Cnt       (S2_Write_Beat_Cnt),
       .S3_Write_Beat_Cnt       (S3_Write_Beat_Cnt),
       .S4_Write_Beat_Cnt       (S4_Write_Beat_Cnt),
       .S5_Write_Beat_Cnt       (S5_Write_Beat_Cnt),
       .S6_Write_Beat_Cnt       (S6_Write_Beat_Cnt),
       .S7_Write_Beat_Cnt       (S7_Write_Beat_Cnt),
           .S0_Read_Byte_Cnt       (S0_Read_Byte_Cnt),
     .S0_Read_Byte_Cnt_En       (S0_Read_Byte_Cnt_En),
           .S1_Read_Byte_Cnt       (S1_Read_Byte_Cnt),
           .S1_Read_Byte_Cnt_En       (S1_Read_Byte_Cnt_En),
           .S2_Read_Byte_Cnt       (S2_Read_Byte_Cnt),
           .S2_Read_Byte_Cnt_En       (S2_Read_Byte_Cnt_En),
           .S3_Read_Byte_Cnt       (S3_Read_Byte_Cnt),
           .S3_Read_Byte_Cnt_En       (S3_Read_Byte_Cnt_En),
           .S4_Read_Byte_Cnt       (S4_Read_Byte_Cnt),
           .S4_Read_Byte_Cnt_En       (S4_Read_Byte_Cnt_En),
           .S5_Read_Byte_Cnt       (S5_Read_Byte_Cnt),
           .S5_Read_Byte_Cnt_En       (S5_Read_Byte_Cnt_En),
           .S6_Read_Byte_Cnt       (S6_Read_Byte_Cnt),
           .S6_Read_Byte_Cnt_En       (S6_Read_Byte_Cnt_En),
           .S7_Read_Byte_Cnt       (S7_Read_Byte_Cnt),
           .S7_Read_Byte_Cnt_En       (S7_Read_Byte_Cnt_En),
           .Write_Beat_Cnt_En      (Write_Beat_Cnt_En),
           .Read_Beat_Cnt_En       (Read_Beat_Cnt_En),
           .S0_Read_Latency        (S0_Read_Latency),
           .S1_Read_Latency        (S1_Read_Latency),
           .S2_Read_Latency        (S2_Read_Latency),
           .S3_Read_Latency        (S3_Read_Latency),
           .S4_Read_Latency        (S4_Read_Latency),
           .S5_Read_Latency        (S5_Read_Latency),
           .S6_Read_Latency        (S6_Read_Latency),
           .S7_Read_Latency        (S7_Read_Latency),
           .S0_Write_Latency       (S0_Write_Latency),
           .S1_Write_Latency       (S1_Write_Latency),
           .S2_Write_Latency       (S2_Write_Latency),
           .S3_Write_Latency       (S3_Write_Latency),
           .S4_Write_Latency       (S4_Write_Latency),
           .S5_Write_Latency       (S5_Write_Latency),
           .S6_Write_Latency       (S6_Write_Latency),
           .S7_Write_Latency       (S7_Write_Latency),
           .Read_Latency_En        (Read_Latency_En),    
           .Write_Latency_En       (Write_Latency_En),   
           .Slv_Wr_Idle_Cnt_En     (Slv_Wr_Idle_Cnt_En), 
           .Mst_Rd_Idle_Cnt_En     (Mst_Rd_Idle_Cnt_En), 
           .Num_BValids_En         (Num_BValids_En),     
           .Num_WLasts_En          (Num_WLasts_En),      
           .Num_RLasts_En          (Num_RLasts_En),      
           .S_Transfer_Cnt_En      (S_Transfer_Cnt_En),
           .S_Packet_Cnt_En        (S_Packet_Cnt_En),  
           .S0_S_Data_Byte_Cnt     (S0_S_Data_Byte_Cnt),
           .S1_S_Data_Byte_Cnt     (S1_S_Data_Byte_Cnt),
           .S2_S_Data_Byte_Cnt     (S2_S_Data_Byte_Cnt),
           .S3_S_Data_Byte_Cnt     (S3_S_Data_Byte_Cnt),
           .S4_S_Data_Byte_Cnt     (S4_S_Data_Byte_Cnt),
           .S5_S_Data_Byte_Cnt     (S5_S_Data_Byte_Cnt),
           .S6_S_Data_Byte_Cnt     (S6_S_Data_Byte_Cnt),
           .S7_S_Data_Byte_Cnt     (S7_S_Data_Byte_Cnt),
           .S0_S_Position_Byte_Cnt (S0_S_Position_Byte_Cnt),
           .S1_S_Position_Byte_Cnt (S1_S_Position_Byte_Cnt),
           .S2_S_Position_Byte_Cnt (S2_S_Position_Byte_Cnt),
           .S3_S_Position_Byte_Cnt (S3_S_Position_Byte_Cnt),
           .S4_S_Position_Byte_Cnt (S4_S_Position_Byte_Cnt),
           .S5_S_Position_Byte_Cnt (S5_S_Position_Byte_Cnt),
           .S6_S_Position_Byte_Cnt (S6_S_Position_Byte_Cnt),
           .S7_S_Position_Byte_Cnt (S7_S_Position_Byte_Cnt),
           .S0_S_Null_Byte_Cnt     (S0_S_Null_Byte_Cnt),
           .S1_S_Null_Byte_Cnt     (S1_S_Null_Byte_Cnt),
           .S2_S_Null_Byte_Cnt     (S2_S_Null_Byte_Cnt),
           .S3_S_Null_Byte_Cnt     (S3_S_Null_Byte_Cnt),
           .S4_S_Null_Byte_Cnt     (S4_S_Null_Byte_Cnt),
           .S5_S_Null_Byte_Cnt     (S5_S_Null_Byte_Cnt),
           .S6_S_Null_Byte_Cnt     (S6_S_Null_Byte_Cnt),
           .S7_S_Null_Byte_Cnt     (S7_S_Null_Byte_Cnt),
           .S_Slv_Idle_Cnt_En      (S_Slv_Idle_Cnt_En),
           .S_Mst_Idle_Cnt_En      (S_Mst_Idle_Cnt_En),
           .S0_Max_Write_Latency   (S0_Max_Write_Latency),         
           .S1_Max_Write_Latency   (S1_Max_Write_Latency),         
           .S2_Max_Write_Latency   (S2_Max_Write_Latency),         
           .S3_Max_Write_Latency   (S3_Max_Write_Latency),         
           .S4_Max_Write_Latency   (S4_Max_Write_Latency),         
           .S5_Max_Write_Latency   (S5_Max_Write_Latency),         
           .S6_Max_Write_Latency   (S6_Max_Write_Latency),         
           .S7_Max_Write_Latency   (S7_Max_Write_Latency),         
           .S0_Min_Write_Latency   (S0_Min_Write_Latency),       
           .S1_Min_Write_Latency   (S1_Min_Write_Latency),       
           .S2_Min_Write_Latency   (S2_Min_Write_Latency),       
           .S3_Min_Write_Latency   (S3_Min_Write_Latency),       
           .S4_Min_Write_Latency   (S4_Min_Write_Latency),       
           .S5_Min_Write_Latency   (S5_Min_Write_Latency),       
           .S6_Min_Write_Latency   (S6_Min_Write_Latency),       
           .S7_Min_Write_Latency   (S7_Min_Write_Latency),       
           .S0_Max_Read_Latency    (S0_Max_Read_Latency),                  
           .S1_Max_Read_Latency    (S1_Max_Read_Latency),                  
           .S2_Max_Read_Latency    (S2_Max_Read_Latency),                  
           .S3_Max_Read_Latency    (S3_Max_Read_Latency),                  
           .S4_Max_Read_Latency    (S4_Max_Read_Latency),                  
           .S5_Max_Read_Latency    (S5_Max_Read_Latency),                  
           .S6_Max_Read_Latency    (S6_Max_Read_Latency),                  
           .S7_Max_Read_Latency    (S7_Max_Read_Latency),                  
           .S0_Min_Read_Latency    (S0_Min_Read_Latency), 
           .S1_Min_Read_Latency    (S1_Min_Read_Latency), 
           .S2_Min_Read_Latency    (S2_Min_Read_Latency), 
           .S3_Min_Read_Latency    (S3_Min_Read_Latency), 
           .S4_Min_Read_Latency    (S4_Min_Read_Latency), 
           .S5_Min_Read_Latency    (S5_Min_Read_Latency), 
           .S6_Min_Read_Latency    (S6_Min_Read_Latency), 
           .S7_Min_Read_Latency    (S7_Min_Read_Latency), 
           .External_Event_Cnt_En  (External_Event_Cnt_En),
           .Metrics_Cnt_En         (Metrics_Cnt_En),
           .Metrics_Cnt_Reset      (Metrics_Cnt_Reset),
           .Metric_Sel             (Metric_Sel_8),
           .Range_Reg              (Range_Reg_8),
           .Metric_Cnt             (Metric_Cnt_8),
           .Incrementer            (Incrementer_8),
           .Acc_OF                 (Acc_OF_8),
           .Incr_OF                (Incr_OF_8)
       );
    
end    
else begin : GEN_NO_METRIC_CNT_8
    assign Metric_Cnt_8  = 0;
    assign Incrementer_8 = 0;
    assign Acc_OF_8      = 1'b0;
    assign Incr_OF_8     = 1'b0;

end
endgenerate




//-- Metric Counter_9
generate
if (C_NUM_OF_COUNTERS > 9) begin : GEN_METRIC_CNT_9

    //-- Mux n Metric Counter_9
    axi_perf_mon_v5_0_12_metric_sel_n_cnt 
      #(
           .C_FAMILY             (C_FAMILY),
           .C_NUM_MONITOR_SLOTS  (C_NUM_MONITOR_SLOTS), 
           .C_ENABLE_EVENT_COUNT (C_ENABLE_EVENT_COUNT),
           .C_METRIC_COUNT_WIDTH (C_METRIC_COUNT_WIDTH),
           .C_METRIC_COUNT_SCALE (C_METRIC_COUNT_SCALE),
           .COUNTER_LOAD_VALUE   (COUNTER_LOAD_VALUE)  

       ) axi_perf_mon_v5_0_12_metric_sel_n_cnt_inst_9 
       (
           .clk                    (clk),
           .rst_n                  (rst_n),
           .Wtrans_Cnt_En          (Wtrans_Cnt_En),
           .Rtrans_Cnt_En          (Rtrans_Cnt_En),
           .S0_Write_Byte_Cnt      (S0_Write_Byte_Cnt),
           .S1_Write_Byte_Cnt      (S1_Write_Byte_Cnt),
           .S2_Write_Byte_Cnt      (S2_Write_Byte_Cnt),
           .S3_Write_Byte_Cnt      (S3_Write_Byte_Cnt),
           .S4_Write_Byte_Cnt      (S4_Write_Byte_Cnt),
           .S5_Write_Byte_Cnt      (S5_Write_Byte_Cnt),
           .S6_Write_Byte_Cnt      (S6_Write_Byte_Cnt),
           .S7_Write_Byte_Cnt      (S7_Write_Byte_Cnt),
           .S0_Slv_Wr_Idle_Cnt      (S0_Slv_Wr_Idle_Cnt),
           .S1_Slv_Wr_Idle_Cnt      (S1_Slv_Wr_Idle_Cnt),
           .S2_Slv_Wr_Idle_Cnt      (S2_Slv_Wr_Idle_Cnt),
           .S3_Slv_Wr_Idle_Cnt      (S3_Slv_Wr_Idle_Cnt),
           .S4_Slv_Wr_Idle_Cnt      (S4_Slv_Wr_Idle_Cnt),
           .S5_Slv_Wr_Idle_Cnt      (S5_Slv_Wr_Idle_Cnt),
           .S6_Slv_Wr_Idle_Cnt      (S6_Slv_Wr_Idle_Cnt),
           .S7_Slv_Wr_Idle_Cnt      (S7_Slv_Wr_Idle_Cnt),
       .S0_Write_Beat_Cnt       (S0_Write_Beat_Cnt),
       .S1_Write_Beat_Cnt       (S1_Write_Beat_Cnt),
       .S2_Write_Beat_Cnt       (S2_Write_Beat_Cnt),
       .S3_Write_Beat_Cnt       (S3_Write_Beat_Cnt),
       .S4_Write_Beat_Cnt       (S4_Write_Beat_Cnt),
       .S5_Write_Beat_Cnt       (S5_Write_Beat_Cnt),
       .S6_Write_Beat_Cnt       (S6_Write_Beat_Cnt),
       .S7_Write_Beat_Cnt       (S7_Write_Beat_Cnt),
           .S0_Read_Byte_Cnt       (S0_Read_Byte_Cnt),
           .S0_Read_Byte_Cnt_En       (S0_Read_Byte_Cnt_En),
           .S1_Read_Byte_Cnt       (S1_Read_Byte_Cnt),
           .S1_Read_Byte_Cnt_En       (S1_Read_Byte_Cnt_En),
           .S2_Read_Byte_Cnt       (S2_Read_Byte_Cnt),
           .S2_Read_Byte_Cnt_En       (S2_Read_Byte_Cnt_En),
           .S3_Read_Byte_Cnt       (S3_Read_Byte_Cnt),
           .S3_Read_Byte_Cnt_En       (S3_Read_Byte_Cnt_En),
           .S4_Read_Byte_Cnt       (S4_Read_Byte_Cnt),
           .S4_Read_Byte_Cnt_En       (S4_Read_Byte_Cnt_En),
           .S5_Read_Byte_Cnt       (S5_Read_Byte_Cnt),
           .S5_Read_Byte_Cnt_En       (S5_Read_Byte_Cnt_En),
           .S6_Read_Byte_Cnt       (S6_Read_Byte_Cnt),
           .S6_Read_Byte_Cnt_En       (S6_Read_Byte_Cnt_En),
           .S7_Read_Byte_Cnt       (S7_Read_Byte_Cnt),
           .S7_Read_Byte_Cnt_En       (S7_Read_Byte_Cnt_En),
           .Write_Beat_Cnt_En      (Write_Beat_Cnt_En),
           .Read_Beat_Cnt_En       (Read_Beat_Cnt_En),
           .S0_Read_Latency        (S0_Read_Latency),
           .S1_Read_Latency        (S1_Read_Latency),
           .S2_Read_Latency        (S2_Read_Latency),
           .S3_Read_Latency        (S3_Read_Latency),
           .S4_Read_Latency        (S4_Read_Latency),
           .S5_Read_Latency        (S5_Read_Latency),
           .S6_Read_Latency        (S6_Read_Latency),
           .S7_Read_Latency        (S7_Read_Latency),
           .S0_Write_Latency       (S0_Write_Latency),
           .S1_Write_Latency       (S1_Write_Latency),
           .S2_Write_Latency       (S2_Write_Latency),
           .S3_Write_Latency       (S3_Write_Latency),
           .S4_Write_Latency       (S4_Write_Latency),
           .S5_Write_Latency       (S5_Write_Latency),
           .S6_Write_Latency       (S6_Write_Latency),
           .S7_Write_Latency       (S7_Write_Latency),
           .Read_Latency_En        (Read_Latency_En),    
           .Write_Latency_En       (Write_Latency_En),   
           .Slv_Wr_Idle_Cnt_En     (Slv_Wr_Idle_Cnt_En), 
           .Mst_Rd_Idle_Cnt_En     (Mst_Rd_Idle_Cnt_En), 
           .Num_BValids_En         (Num_BValids_En),     
           .Num_WLasts_En          (Num_WLasts_En),      
           .Num_RLasts_En          (Num_RLasts_En),      
           .S_Transfer_Cnt_En      (S_Transfer_Cnt_En),
           .S_Packet_Cnt_En        (S_Packet_Cnt_En),  
           .S0_S_Data_Byte_Cnt     (S0_S_Data_Byte_Cnt),
           .S1_S_Data_Byte_Cnt     (S1_S_Data_Byte_Cnt),
           .S2_S_Data_Byte_Cnt     (S2_S_Data_Byte_Cnt),
           .S3_S_Data_Byte_Cnt     (S3_S_Data_Byte_Cnt),
           .S4_S_Data_Byte_Cnt     (S4_S_Data_Byte_Cnt),
           .S5_S_Data_Byte_Cnt     (S5_S_Data_Byte_Cnt),
           .S6_S_Data_Byte_Cnt     (S6_S_Data_Byte_Cnt),
           .S7_S_Data_Byte_Cnt     (S7_S_Data_Byte_Cnt),
           .S0_S_Position_Byte_Cnt (S0_S_Position_Byte_Cnt),
           .S1_S_Position_Byte_Cnt (S1_S_Position_Byte_Cnt),
           .S2_S_Position_Byte_Cnt (S2_S_Position_Byte_Cnt),
           .S3_S_Position_Byte_Cnt (S3_S_Position_Byte_Cnt),
           .S4_S_Position_Byte_Cnt (S4_S_Position_Byte_Cnt),
           .S5_S_Position_Byte_Cnt (S5_S_Position_Byte_Cnt),
           .S6_S_Position_Byte_Cnt (S6_S_Position_Byte_Cnt),
           .S7_S_Position_Byte_Cnt (S7_S_Position_Byte_Cnt),
           .S0_S_Null_Byte_Cnt     (S0_S_Null_Byte_Cnt),
           .S1_S_Null_Byte_Cnt     (S1_S_Null_Byte_Cnt),
           .S2_S_Null_Byte_Cnt     (S2_S_Null_Byte_Cnt),
           .S3_S_Null_Byte_Cnt     (S3_S_Null_Byte_Cnt),
           .S4_S_Null_Byte_Cnt     (S4_S_Null_Byte_Cnt),
           .S5_S_Null_Byte_Cnt     (S5_S_Null_Byte_Cnt),
           .S6_S_Null_Byte_Cnt     (S6_S_Null_Byte_Cnt),
           .S7_S_Null_Byte_Cnt     (S7_S_Null_Byte_Cnt),
           .S_Slv_Idle_Cnt_En      (S_Slv_Idle_Cnt_En),
           .S_Mst_Idle_Cnt_En      (S_Mst_Idle_Cnt_En),
           .S0_Max_Write_Latency   (S0_Max_Write_Latency),         
           .S1_Max_Write_Latency   (S1_Max_Write_Latency),         
           .S2_Max_Write_Latency   (S2_Max_Write_Latency),         
           .S3_Max_Write_Latency   (S3_Max_Write_Latency),         
           .S4_Max_Write_Latency   (S4_Max_Write_Latency),         
           .S5_Max_Write_Latency   (S5_Max_Write_Latency),         
           .S6_Max_Write_Latency   (S6_Max_Write_Latency),         
           .S7_Max_Write_Latency   (S7_Max_Write_Latency),         
           .S0_Min_Write_Latency   (S0_Min_Write_Latency),       
           .S1_Min_Write_Latency   (S1_Min_Write_Latency),       
           .S2_Min_Write_Latency   (S2_Min_Write_Latency),       
           .S3_Min_Write_Latency   (S3_Min_Write_Latency),       
           .S4_Min_Write_Latency   (S4_Min_Write_Latency),       
           .S5_Min_Write_Latency   (S5_Min_Write_Latency),       
           .S6_Min_Write_Latency   (S6_Min_Write_Latency),       
           .S7_Min_Write_Latency   (S7_Min_Write_Latency),       
           .S0_Max_Read_Latency    (S0_Max_Read_Latency),                  
           .S1_Max_Read_Latency    (S1_Max_Read_Latency),                  
           .S2_Max_Read_Latency    (S2_Max_Read_Latency),                  
           .S3_Max_Read_Latency    (S3_Max_Read_Latency),                  
           .S4_Max_Read_Latency    (S4_Max_Read_Latency),                  
           .S5_Max_Read_Latency    (S5_Max_Read_Latency),                  
           .S6_Max_Read_Latency    (S6_Max_Read_Latency),                  
           .S7_Max_Read_Latency    (S7_Max_Read_Latency),                  
           .S0_Min_Read_Latency    (S0_Min_Read_Latency), 
           .S1_Min_Read_Latency    (S1_Min_Read_Latency), 
           .S2_Min_Read_Latency    (S2_Min_Read_Latency), 
           .S3_Min_Read_Latency    (S3_Min_Read_Latency), 
           .S4_Min_Read_Latency    (S4_Min_Read_Latency), 
           .S5_Min_Read_Latency    (S5_Min_Read_Latency), 
           .S6_Min_Read_Latency    (S6_Min_Read_Latency), 
           .S7_Min_Read_Latency    (S7_Min_Read_Latency), 
           .External_Event_Cnt_En  (External_Event_Cnt_En),
           .Metrics_Cnt_En         (Metrics_Cnt_En),
           .Metrics_Cnt_Reset      (Metrics_Cnt_Reset),
           .Metric_Sel             (Metric_Sel_9),
           .Range_Reg              (Range_Reg_9),
           .Metric_Cnt             (Metric_Cnt_9),
           .Incrementer            (Incrementer_9),
           .Acc_OF                 (Acc_OF_9),
           .Incr_OF                (Incr_OF_9)
       );
    
end    
else begin : GEN_NO_METRIC_CNT_9
    assign Metric_Cnt_9  = 0;
    assign Incrementer_9 = 0;
    assign Acc_OF_9      = 1'b0;
    assign Incr_OF_9     = 1'b0;

end
endgenerate


endmodule       


//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename     : axi_perf_mon_v5_0_12_metric_sel_n_cnt.v
// Version      : v5.0
// Description  : This module calls the accumulator and incrementor module
//                and passes the metrics to be accumulated based on
//                metric selection registers 
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
//
//  axi_perf_mon.v
//        \-- axi_perf_mon_v5_0_12_metric_counters.v
//           \-- axi_perf_mon_v5_0_12_metric_sel_n_cnt.v 
//
//-----------------------------------------------------------------------------
// Author :    Kalpanath
// History:    
// Kalpanath 07/25/2012      First Version
// ~~~~~~
// NLR       10/10/2012      Added support uptill 8 monitor slots at a time
// ~~~~~~
//-----------------------------------------------------------------------------
`timescale 1ns/1ps
module axi_perf_mon_v5_0_12_metric_sel_n_cnt 
#(
   parameter                       C_FAMILY             = "virtex7",
   parameter                       C_NUM_MONITOR_SLOTS  = 8,
   parameter                       C_ENABLE_EVENT_COUNT = 1,  //-- enables/disables perf mon counting logic
   parameter                       C_METRIC_COUNT_WIDTH = 32,  //-- enables/disables perf mon counting logic
   parameter                       C_METRIC_COUNT_SCALE = 1,
   parameter                       COUNTER_LOAD_VALUE   = 32'h00000000
)
(
   input                            clk,
   input                            rst_n,

    //-- AXI4 metrics
   
   input [C_NUM_MONITOR_SLOTS-1:0]  Wtrans_Cnt_En,
   input [C_NUM_MONITOR_SLOTS-1:0]  Rtrans_Cnt_En,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Read_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Read_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Read_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Read_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Read_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Read_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Read_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Read_Byte_Cnt,
   input                            S0_Read_Byte_Cnt_En,
   input                            S1_Read_Byte_Cnt_En,
   input                            S2_Read_Byte_Cnt_En,
   input                            S3_Read_Byte_Cnt_En,
   input                            S4_Read_Byte_Cnt_En,
   input                            S5_Read_Byte_Cnt_En,
   input                            S6_Read_Byte_Cnt_En,
   input                            S7_Read_Byte_Cnt_En,
   input [C_NUM_MONITOR_SLOTS-1:0]  Write_Beat_Cnt_En,
   input [C_NUM_MONITOR_SLOTS-1:0]  Read_Beat_Cnt_En,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Write_Beat_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Write_Beat_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Write_Beat_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Write_Beat_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Write_Beat_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Write_Beat_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Write_Beat_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Write_Beat_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Slv_Wr_Idle_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Slv_Wr_Idle_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Slv_Wr_Idle_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Slv_Wr_Idle_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Slv_Wr_Idle_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Slv_Wr_Idle_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Slv_Wr_Idle_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Slv_Wr_Idle_Cnt,
   input [C_NUM_MONITOR_SLOTS-1:0]  Read_Latency_En,        
   input [C_NUM_MONITOR_SLOTS-1:0]  Write_Latency_En,        
   input [C_NUM_MONITOR_SLOTS-1:0]  Slv_Wr_Idle_Cnt_En,        
   input [C_NUM_MONITOR_SLOTS-1:0]  Mst_Rd_Idle_Cnt_En,        
   input [C_NUM_MONITOR_SLOTS-1:0]  Num_BValids_En,       
   input [C_NUM_MONITOR_SLOTS-1:0]  Num_WLasts_En,             
   input [C_NUM_MONITOR_SLOTS-1:0]  Num_RLasts_En,      

   //-- AXI Streaming metrics
   input [C_NUM_MONITOR_SLOTS-1:0]  S_Transfer_Cnt_En,
   input [C_NUM_MONITOR_SLOTS-1:0]  S_Packet_Cnt_En,  
   input [C_METRIC_COUNT_WIDTH-1:0] S0_S_Data_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_S_Data_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_S_Data_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_S_Data_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_S_Data_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_S_Data_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_S_Data_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_S_Data_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_S_Position_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_S_Position_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_S_Position_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_S_Position_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_S_Position_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_S_Position_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_S_Position_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_S_Position_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_S_Null_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_S_Null_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_S_Null_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_S_Null_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_S_Null_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_S_Null_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_S_Null_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_S_Null_Byte_Cnt,
   input [C_NUM_MONITOR_SLOTS-1:0]  S_Slv_Idle_Cnt_En,
   input [C_NUM_MONITOR_SLOTS-1:0]  S_Mst_Idle_Cnt_En,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Max_Write_Latency,                 
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Max_Write_Latency,                 
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Max_Write_Latency,         
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Max_Write_Latency,         
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Max_Write_Latency,         
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Max_Write_Latency,         
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Max_Write_Latency,         
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Max_Write_Latency,         
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Min_Write_Latency,       
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Min_Write_Latency,       
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Min_Write_Latency,       
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Min_Write_Latency,       
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Min_Write_Latency,       
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Min_Write_Latency,       
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Min_Write_Latency,       
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Min_Write_Latency,       
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Max_Read_Latency,     
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Max_Read_Latency,                 
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Max_Read_Latency,                 
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Max_Read_Latency,                 
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Max_Read_Latency,                 
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Max_Read_Latency,                 
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Max_Read_Latency,                 
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Max_Read_Latency,                 
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Min_Read_Latency,            
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Min_Read_Latency,            
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Min_Read_Latency,            
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Min_Read_Latency,            
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Min_Read_Latency,            
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Min_Read_Latency,            
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Min_Read_Latency,            
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Min_Read_Latency, 

   //-- External Events
   input [C_NUM_MONITOR_SLOTS-1:0]  External_Event_Cnt_En,

   //-- Cnt Enable and Reset
   input                            Metrics_Cnt_En,
   input                            Metrics_Cnt_Reset,

   //-- Metric Selector
   input  [7:0]                     Metric_Sel,    

   // Range Register - in core clk domain
   input  [31:0]                    Range_Reg,    

   // Metric Counters - in core clk domain
   output [31:0]                    Metric_Cnt,    

   // Incrementers in core clk domain
   output [31:0]                    Incrementer,

   // OverFlows
   output                           Acc_OF,    
   output                           Incr_OF    


);




//-------------------------------------------------------------------
// Parameter Declaration
//-------------------------------------------------------------------
localparam RST_ACTIVE = 1'b0;


//-------------------------------------------------------------------
// Signal Declaration
//-------------------------------------------------------------------
reg [31:0]                    Add_in;    
reg                           Add_in_Valid;    
reg accumulate;

reg [31:0]                    incrementer_input_reg_val;    

wire  [C_METRIC_COUNT_WIDTH-1:0] Write_Byte_Cnt [7:0];
wire  [C_METRIC_COUNT_WIDTH-1:0] Read_Byte_Cnt [7:0];
wire  Read_Byte_Cnt_En [7:0];
wire  [C_METRIC_COUNT_WIDTH-1:0] Read_Latency  [7:0];
wire  [C_METRIC_COUNT_WIDTH-1:0] Write_Latency [7:0];
wire  [C_METRIC_COUNT_WIDTH-1:0] Write_Beat_Cnt [7:0];
wire  [C_METRIC_COUNT_WIDTH-1:0] Slv_Wr_Idle_Cnt [7:0];
wire  [C_METRIC_COUNT_WIDTH-1:0] S_Data_Byte_Cnt [7:0];
wire  [C_METRIC_COUNT_WIDTH-1:0] S_Position_Byte_Cnt [7:0];
wire  [C_METRIC_COUNT_WIDTH-1:0] S_Null_Byte_Cnt [7:0];
wire  [C_METRIC_COUNT_WIDTH-1:0] Min_Write_Latency [7:0];
wire  [C_METRIC_COUNT_WIDTH-1:0] Max_Write_Latency [7:0];
wire  [C_METRIC_COUNT_WIDTH-1:0] Min_Read_Latency  [7:0];
wire  [C_METRIC_COUNT_WIDTH-1:0] Max_Read_Latency  [7:0];


//---------------------------------------------------------------------
// Wire assignments
//---------------------------------------------------------------------

assign Write_Byte_Cnt[0] = S0_Write_Byte_Cnt;
assign Write_Byte_Cnt[1] = S1_Write_Byte_Cnt;
assign Write_Byte_Cnt[2] = S2_Write_Byte_Cnt;
assign Write_Byte_Cnt[3] = S3_Write_Byte_Cnt;
assign Write_Byte_Cnt[4] = S4_Write_Byte_Cnt;
assign Write_Byte_Cnt[5] = S5_Write_Byte_Cnt;
assign Write_Byte_Cnt[6] = S6_Write_Byte_Cnt;
assign Write_Byte_Cnt[7] = S7_Write_Byte_Cnt;

assign Read_Byte_Cnt[0] = S0_Read_Byte_Cnt;
assign Read_Byte_Cnt_En[0] = S0_Read_Byte_Cnt_En;
assign Read_Byte_Cnt[1] = S1_Read_Byte_Cnt;
assign Read_Byte_Cnt_En[1] = S1_Read_Byte_Cnt_En;
assign Read_Byte_Cnt[2] = S2_Read_Byte_Cnt;
assign Read_Byte_Cnt_En[2] = S2_Read_Byte_Cnt_En;
assign Read_Byte_Cnt[3] = S3_Read_Byte_Cnt;
assign Read_Byte_Cnt_En[3] = S3_Read_Byte_Cnt_En;
assign Read_Byte_Cnt[4] = S4_Read_Byte_Cnt;
assign Read_Byte_Cnt_En[4] = S4_Read_Byte_Cnt_En;
assign Read_Byte_Cnt[5] = S5_Read_Byte_Cnt;
assign Read_Byte_Cnt_En[5] = S5_Read_Byte_Cnt_En;
assign Read_Byte_Cnt[6] = S6_Read_Byte_Cnt;
assign Read_Byte_Cnt_En[6] = S6_Read_Byte_Cnt_En;
assign Read_Byte_Cnt[7] = S7_Read_Byte_Cnt;
assign Read_Byte_Cnt_En[7] = S7_Read_Byte_Cnt_En;

assign Read_Latency[0] = S0_Read_Latency;
assign Read_Latency[1] = S1_Read_Latency;
assign Read_Latency[2] = S2_Read_Latency;
assign Read_Latency[3] = S3_Read_Latency;
assign Read_Latency[4] = S4_Read_Latency;
assign Read_Latency[5] = S5_Read_Latency;
assign Read_Latency[6] = S6_Read_Latency;
assign Read_Latency[7] = S7_Read_Latency;

assign Write_Latency[0] = S0_Write_Latency;
assign Write_Latency[1] = S1_Write_Latency;
assign Write_Latency[2] = S2_Write_Latency;
assign Write_Latency[3] = S3_Write_Latency;
assign Write_Latency[4] = S4_Write_Latency;
assign Write_Latency[5] = S5_Write_Latency;
assign Write_Latency[6] = S6_Write_Latency;
assign Write_Latency[7] = S7_Write_Latency;

assign Write_Beat_Cnt[0] = S0_Write_Beat_Cnt;
assign Write_Beat_Cnt[1] = S1_Write_Beat_Cnt;
assign Write_Beat_Cnt[2] = S2_Write_Beat_Cnt;
assign Write_Beat_Cnt[3] = S3_Write_Beat_Cnt;
assign Write_Beat_Cnt[4] = S4_Write_Beat_Cnt;
assign Write_Beat_Cnt[5] = S5_Write_Beat_Cnt;
assign Write_Beat_Cnt[6] = S6_Write_Beat_Cnt;
assign Write_Beat_Cnt[7] = S7_Write_Beat_Cnt;

assign Slv_Wr_Idle_Cnt[0] = S0_Slv_Wr_Idle_Cnt;
assign Slv_Wr_Idle_Cnt[1] = S1_Slv_Wr_Idle_Cnt;
assign Slv_Wr_Idle_Cnt[2] = S2_Slv_Wr_Idle_Cnt;
assign Slv_Wr_Idle_Cnt[3] = S3_Slv_Wr_Idle_Cnt;
assign Slv_Wr_Idle_Cnt[4] = S4_Slv_Wr_Idle_Cnt;
assign Slv_Wr_Idle_Cnt[5] = S5_Slv_Wr_Idle_Cnt;
assign Slv_Wr_Idle_Cnt[6] = S6_Slv_Wr_Idle_Cnt;
assign Slv_Wr_Idle_Cnt[7] = S7_Slv_Wr_Idle_Cnt;


assign S_Data_Byte_Cnt[0] = S0_S_Data_Byte_Cnt;
assign S_Data_Byte_Cnt[1] = S1_S_Data_Byte_Cnt;
assign S_Data_Byte_Cnt[2] = S2_S_Data_Byte_Cnt;
assign S_Data_Byte_Cnt[3] = S3_S_Data_Byte_Cnt;
assign S_Data_Byte_Cnt[4] = S4_S_Data_Byte_Cnt;
assign S_Data_Byte_Cnt[5] = S5_S_Data_Byte_Cnt;
assign S_Data_Byte_Cnt[6] = S6_S_Data_Byte_Cnt;
assign S_Data_Byte_Cnt[7] = S7_S_Data_Byte_Cnt;

assign S_Position_Byte_Cnt[0] = S0_S_Position_Byte_Cnt;
assign S_Position_Byte_Cnt[1] = S1_S_Position_Byte_Cnt;
assign S_Position_Byte_Cnt[2] = S2_S_Position_Byte_Cnt;
assign S_Position_Byte_Cnt[3] = S3_S_Position_Byte_Cnt;
assign S_Position_Byte_Cnt[4] = S4_S_Position_Byte_Cnt;
assign S_Position_Byte_Cnt[5] = S5_S_Position_Byte_Cnt;
assign S_Position_Byte_Cnt[6] = S6_S_Position_Byte_Cnt;
assign S_Position_Byte_Cnt[7] = S7_S_Position_Byte_Cnt;

assign S_Null_Byte_Cnt[0] = S0_S_Null_Byte_Cnt;
assign S_Null_Byte_Cnt[1] = S1_S_Null_Byte_Cnt;
assign S_Null_Byte_Cnt[2] = S2_S_Null_Byte_Cnt;
assign S_Null_Byte_Cnt[3] = S3_S_Null_Byte_Cnt;
assign S_Null_Byte_Cnt[4] = S4_S_Null_Byte_Cnt;
assign S_Null_Byte_Cnt[5] = S5_S_Null_Byte_Cnt;
assign S_Null_Byte_Cnt[6] = S6_S_Null_Byte_Cnt;
assign S_Null_Byte_Cnt[7] = S7_S_Null_Byte_Cnt;

assign Min_Write_Latency[0] = S0_Min_Write_Latency;
assign Min_Write_Latency[1] = S1_Min_Write_Latency;
assign Min_Write_Latency[2] = S2_Min_Write_Latency;
assign Min_Write_Latency[3] = S3_Min_Write_Latency;
assign Min_Write_Latency[4] = S4_Min_Write_Latency;
assign Min_Write_Latency[5] = S5_Min_Write_Latency;
assign Min_Write_Latency[6] = S6_Min_Write_Latency;
assign Min_Write_Latency[7] = S7_Min_Write_Latency;

assign Max_Write_Latency[0] = S0_Max_Write_Latency;
assign Max_Write_Latency[1] = S1_Max_Write_Latency;
assign Max_Write_Latency[2] = S2_Max_Write_Latency;
assign Max_Write_Latency[3] = S3_Max_Write_Latency;
assign Max_Write_Latency[4] = S4_Max_Write_Latency;
assign Max_Write_Latency[5] = S5_Max_Write_Latency;
assign Max_Write_Latency[6] = S6_Max_Write_Latency;
assign Max_Write_Latency[7] = S7_Max_Write_Latency;

assign Min_Read_Latency[0] = S0_Min_Read_Latency;
assign Min_Read_Latency[1] = S1_Min_Read_Latency;
assign Min_Read_Latency[2] = S2_Min_Read_Latency;
assign Min_Read_Latency[3] = S3_Min_Read_Latency;
assign Min_Read_Latency[4] = S4_Min_Read_Latency;
assign Min_Read_Latency[5] = S5_Min_Read_Latency;
assign Min_Read_Latency[6] = S6_Min_Read_Latency;
assign Min_Read_Latency[7] = S7_Min_Read_Latency;

assign Max_Read_Latency[0] = S0_Max_Read_Latency;
assign Max_Read_Latency[1] = S1_Max_Read_Latency;
assign Max_Read_Latency[2] = S2_Max_Read_Latency;
assign Max_Read_Latency[3] = S3_Max_Read_Latency;
assign Max_Read_Latency[4] = S4_Max_Read_Latency;
assign Max_Read_Latency[5] = S5_Max_Read_Latency;
assign Max_Read_Latency[6] = S6_Max_Read_Latency;
assign Max_Read_Latency[7] = S7_Max_Read_Latency;

//-------------------------------------------------------------------
// Begin architecture
//-------------------------------------------------------------------


generate
if (C_ENABLE_EVENT_COUNT == 1) begin : GEN_MUX_N_CNT
    always @(posedge clk) begin 
       if (rst_n == RST_ACTIVE) begin
           Add_in       <= 0;
           Add_in_Valid <= 1'b0;
           accumulate   <= 1'b0;
       end
       else begin
           accumulate   <= 1'b1;
           case (Metric_Sel[4:0])
               5'd0: begin
                   incrementer_input_reg_val <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= { {31{1'b0}}, 1'b1 };
                   Add_in_Valid <= Wtrans_Cnt_En[Metric_Sel[7:5]];
               end
               5'd1: begin
                   incrementer_input_reg_val <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= { {31{1'b0}}, 1'b1 };
                   Add_in_Valid <= Rtrans_Cnt_En[Metric_Sel[7:5]];
               end
               5'd2: begin
                   incrementer_input_reg_val <= Write_Beat_Cnt[Metric_Sel[7:5]];
                   Add_in       <= Write_Byte_Cnt[Metric_Sel[7:5]];
                   Add_in_Valid <= Write_Beat_Cnt_En[Metric_Sel[7:5]];
               end
               5'd3: begin
                   incrementer_input_reg_val <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= Read_Byte_Cnt[Metric_Sel[7:5]];
                   Add_in_Valid <= Read_Byte_Cnt_En[Metric_Sel[7:5]];
               end
               5'd4: begin
                   //Add_in       <= { {31{1'b0}}, 1'b1 };
                   incrementer_input_reg_val <= Write_Beat_Cnt[Metric_Sel[7:5]];
                   Add_in       <= Write_Beat_Cnt[Metric_Sel[7:5]];
                   Add_in_Valid <= Write_Beat_Cnt_En[Metric_Sel[7:5]];
               end
               5'd5: begin
                   incrementer_input_reg_val <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= Read_Latency[Metric_Sel[7:5]];
                   Add_in_Valid <= Read_Latency_En[Metric_Sel[7:5]];
               end
               5'd6: begin
                   incrementer_input_reg_val <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= Write_Latency[Metric_Sel[7:5]];
                   Add_in_Valid <= Write_Latency_En[Metric_Sel[7:5]];
               end
               5'd7: begin
                   incrementer_input_reg_val <= Slv_Wr_Idle_Cnt[Metric_Sel[7:5]];
                   //Add_in       <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= Slv_Wr_Idle_Cnt[Metric_Sel[7:5]];
                   Add_in_Valid <= Slv_Wr_Idle_Cnt_En[Metric_Sel[7:5]];
               end
               5'd8: begin
                   incrementer_input_reg_val <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= { {31{1'b0}}, 1'b1 };
                   Add_in_Valid <= Mst_Rd_Idle_Cnt_En[Metric_Sel[7:5]];
               end
               5'd9: begin
                   incrementer_input_reg_val <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= { {31{1'b0}}, 1'b1 };
                   Add_in_Valid <= Num_BValids_En[Metric_Sel[7:5]];
               end
               5'd10: begin
                   incrementer_input_reg_val <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= { {31{1'b0}}, 1'b1 };
                   Add_in_Valid <= Num_WLasts_En[Metric_Sel[7:5]];
               end
               5'd11: begin
                   incrementer_input_reg_val <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= { {31{1'b0}}, 1'b1 };
                   Add_in_Valid <= Num_RLasts_En[Metric_Sel[7:5]];
               end
               5'd12: begin
                   incrementer_input_reg_val <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= Min_Write_Latency[Metric_Sel[7:5]];
                   Add_in_Valid <= 1'b1;
                   accumulate   <= 1'b0;
               end
               5'd13: begin
                   incrementer_input_reg_val <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= Max_Write_Latency[Metric_Sel[7:5]];
                   Add_in_Valid <= 1'b1;
                   accumulate   <= 1'b0;
               end
               5'd14: begin
                   incrementer_input_reg_val <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= Min_Read_Latency[Metric_Sel[7:5]];
                   Add_in_Valid <= 1'b1;
                   accumulate   <= 1'b0;
               end
               5'd15: begin
                   incrementer_input_reg_val <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= Max_Read_Latency[Metric_Sel[7:5]];
                   Add_in_Valid <= 1'b1;
                   accumulate   <= 1'b0;
               end
               5'd16: begin
                   incrementer_input_reg_val <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= { {31{1'b0}}, 1'b1 };
                   Add_in_Valid <= S_Transfer_Cnt_En[Metric_Sel[7:5]];
               end
               5'd17: begin
                   incrementer_input_reg_val <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= { {31{1'b0}}, 1'b1 };
                   Add_in_Valid <= S_Packet_Cnt_En[Metric_Sel[7:5]];
               end
               5'd18: begin
                   incrementer_input_reg_val <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= S_Data_Byte_Cnt[Metric_Sel[7:5]];
                   Add_in_Valid <= S_Transfer_Cnt_En[Metric_Sel[7:5]];
               end
               5'd19: begin
                   incrementer_input_reg_val <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= S_Position_Byte_Cnt[Metric_Sel[7:5]];
                   Add_in_Valid <= S_Transfer_Cnt_En[Metric_Sel[7:5]];
               end
               5'd20: begin
                   incrementer_input_reg_val <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= S_Null_Byte_Cnt[Metric_Sel[7:5]];
                   Add_in_Valid <= S_Transfer_Cnt_En[Metric_Sel[7:5]];
               end
               5'd21: begin
                   incrementer_input_reg_val <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= { {31{1'b0}}, 1'b1 };
                   Add_in_Valid <= S_Slv_Idle_Cnt_En[Metric_Sel[7:5]];
               end
               5'd22: begin
                   incrementer_input_reg_val <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= { {31{1'b0}}, 1'b1 };
                   Add_in_Valid <= S_Mst_Idle_Cnt_En[Metric_Sel[7:5]];
               end
               5'd30: begin
                   incrementer_input_reg_val <= { {31{1'b0}}, 1'b1 };
                   Add_in       <= { {31{1'b0}}, 1'b1 };
                   Add_in_Valid <= External_Event_Cnt_En[Metric_Sel[7:5]];
               end
               default: begin
                   incrementer_input_reg_val <= {32{1'b0}};
                   Add_in       <= {32{1'b0}};
                   Add_in_Valid <= 1'b0;
               end
           endcase
       end
    end 

    //-- Accumulator and Incrementer Instantiation
    axi_perf_mon_v5_0_12_acc_n_incr 
      #(
           .C_FAMILY             (C_FAMILY            ),
           .DWIDTH               (C_METRIC_COUNT_WIDTH),
           .C_SCALE              (C_METRIC_COUNT_SCALE),
	   .COUNTER_LOAD_VALUE   (COUNTER_LOAD_VALUE  )
       ) acc_n_incr_inst 
       (
           .clk                  (clk),
           .rst_n                (rst_n),
           .Enable               (Metrics_Cnt_En),
           .Reset                (Metrics_Cnt_Reset),
           .Range_Reg            (Range_Reg),
           .Add_in               (Add_in),
           .Add_in_Valid         (Add_in_Valid),
           .Accumulate           (accumulate),
           .Accumulator          (Metric_Cnt),
           .incrementer_input_reg_val (incrementer_input_reg_val),
           .Incrementer          (Incrementer),
           .Acc_OF               (Acc_OF),
           .Incr_OF              (Incr_OF)
       );
    
end    
else begin : GEN_NO_MUX_N_CNT
     assign Metric_Cnt  = 0;
     assign Incrementer = 0;
     assign Acc_OF      = 1'b0;
     assign Incr_OF     = 1'b0;
end
endgenerate




endmodule       


//-------------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename     : axi_perf_mon_v5_0_12_mon_fifo.v
// Version      : v5.0
// Description  : This is the top level wrapper file for the monitor-Slots of AXI
//                interface. It has the AXI slots input and sends out the
//                synchronized outputs through Asynchronous FIFO
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
// --  axi_perf_mon.v
//      \-- axi_perf_mon_v5_0_12_mon_fifo.v
//
//-----------------------------------------------------------------------------
// Author :   NLR 
// History:    
// NLR       07/25/2012      First Version
// ^^^^^^
//-----------------------------------------------------------------------------
`timescale 1ns/1ps
(* DowngradeIPIdentifiedWarnings="yes" *)

module axi_perf_mon_v5_0_12_mon_fifo 
  # (
    parameter C_FAMILY                        = "virtex7",
    parameter C_REG_ALL_MONITOR_SIGNALS       = 0,
    parameter C_MON_FIFO_DATA_WIDTH           = 64,
    parameter C_FIFO_ENABLE                   = 1
    )
    (
    input                                  Mon_clk,
    input                                  Mon_rst_n,
    //input                                  mon_en,
    input [C_MON_FIFO_DATA_WIDTH-1:0]      Data_In,
    input                                  CORE_ACLK,
    input                                  CORE_ARESETN,
    output [C_MON_FIFO_DATA_WIDTH-1:0]     Sync_Data_Out,
    output                                 Sync_Data_Valid
    );

    
   /*--------------------wire/connection declarations------------------*/
   
   localparam RST_ACTIVE = 1'b0; 

   /*--------------------wire/connection declarations------------------*/
 
   wire                                 fifo_rst    ;
   wire                                 fifo_wr_en  ;
   wire                                 fifo_rd_en  ;
   wire                                 fifo_full   ;
   wire                                 fifo_empty  ;
   wire [C_MON_FIFO_DATA_WIDTH-1:0]     Fifo_Data_In;
   wire [C_MON_FIFO_DATA_WIDTH-1:0]     Fifo_Data_Out;
   reg  [C_MON_FIFO_DATA_WIDTH-1:0]     Reg_Data_In ;
                             
   /*-------------Active high reset generation--------------------------*/

   assign fifo_rst = (~(Mon_rst_n) | ~(CORE_ARESETN)) ; //Active high reset to fifo


   /*--------------- Fifo write enable and read enable generation------*/

    assign fifo_wr_en = ~(fifo_full);// & mon_en;
    assign fifo_rd_en = ~(fifo_empty);

   /*----------------- Registering Data input based on Parameter------*/
    
    
     always @(posedge Mon_clk) begin
       if (Mon_rst_n == RST_ACTIVE) begin
         Reg_Data_In <= 0 ;
       end
       else begin
         Reg_Data_In <= Data_In;
       end
     end
 
     assign Fifo_Data_In = C_REG_ALL_MONITOR_SIGNALS?Reg_Data_In:Data_In;

   /*----------------- Submodule instantiations------------------------*/

   // async fifo module

  generate
  if(C_FIFO_ENABLE == 1) begin:USE_MON_FIFO

    reg  [C_MON_FIFO_DATA_WIDTH-1:0] Fifo_Data_Out_Reg;
    reg                              fifo_rd_en_reg;

    axi_perf_mon_v5_0_12_async_fifo
    # (
          .C_FAMILY             (C_FAMILY             ),
          .C_FIFO_DEPTH         (32                   ),
          .C_DATA_CNT_WIDTH     (5                    ),
          .C_DATA_WIDTH         (C_MON_FIFO_DATA_WIDTH),
          .C_FULL_FLAGS_RST     (1                    ),//On reset fifo_full value
          .C_USE_BLOCKMEM       (2                    ),//Distributed RAM
          .C_COMMON_CLOCK       (0                    ),//Different clocks then this fifo is required  
          .C_IMPLEMENTATION_TYPE(2                    ),//Different clock BRAM/Distributed 
          .C_USE_FWFT           (1                    )
  
      ) async_fifo_inst
      (
          .Din               (Fifo_Data_In            ),
          .Wr_en             (fifo_wr_en              ),
          .Wr_clk            (Mon_clk                 ),
          .Rd_en             (fifo_rd_en              ),
          .Rd_clk            (CORE_ACLK               ),
          .fifo_rst          (fifo_rst                ), //active high
          .Dout              (Fifo_Data_Out           ),
          .Full              (fifo_full               ),
          .wr_rst_busy       (                        ),
          .Empty             (fifo_empty              ),
          .rd_data_count     (),
          .wr_data_count     (),
          .almost_empty      (                        ), 
          .almost_full       (                        ) 
      );

      // Registering Fifo data out and valid signals
      always @(posedge CORE_ACLK) begin
       if (CORE_ARESETN == RST_ACTIVE) begin
         Fifo_Data_Out_Reg <= 0 ;
         fifo_rd_en_reg    <= 0; 
       end
       else begin
         Fifo_Data_Out_Reg <= Fifo_Data_Out;
         fifo_rd_en_reg    <= fifo_rd_en; 
       end
     end

     assign Sync_Data_Out   = Fifo_Data_Out_Reg;
     assign Sync_Data_Valid = fifo_rd_en_reg;


  end 
  else begin : NO_MON_FIFO            // Default value assignment
     assign fifo_empty      = 1'b0;
     assign fifo_full       = 1'b0;
     assign Sync_Data_Out   = Fifo_Data_In;
     assign Sync_Data_Valid = 1'b1;

  end

  endgenerate 

  
endmodule


//-------------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename   :     axi_perf_mon_v5_0_12_ext_calc.v 
// Version    :     v5.0
// Description:     External event calculator module generates external event 
//                  metric count enables which will be used in metric counter
// Verilog-Standard:  Verilog 2001 
//-----------------------------------------------------------------------------
// Structure:
//  axi_perf_mon.v
//      \-- axi_perf_mon_v5_0_12_ext_calc.v
//-----------------------------------------------------------------------------
// Author :  NLR  
// History: 
// NLR       1/10/2012      First Version
// ^^^^^^
//-----------------------------------------------------------------------------
`timescale 1ns/1ps

module axi_perf_mon_v5_0_12_ext_calc 
   (
    //AXI Signals
    input                                 clk,        
    input                                 rst_n,     
    // External Events
    input                                 Ext_Event,
    input                                 Ext_Event_Start,
    input                                 Ext_Event_Stop,
    input                                 Ext_Event_Valid,
    // Register inputs
    input                                 Metrics_Cnt_En,
    input                                 Metrics_Cnt_Reset,
    //External Event outputs
    output reg                            External_Event_Cnt_En
    );

    //Parameter Declarations
    parameter RST_ACTIVE              = 0; 

    //Register declarations
    reg Ext_Event_going_on;
    reg Ext_Event_d1;
    reg Ext_Event_Valid_d1;

    //wire declaration
    wire rst_int_n1 = rst_n &  ~(Metrics_Cnt_Reset);
    reg rst_int_n;
    always @(posedge clk) begin
      rst_int_n <= rst_int_n1;
    end

  // External event enable generation logic
  // Event going on signal generation based on start and stop signals

    always @(posedge clk) begin 
       if (rst_int_n == RST_ACTIVE) begin
           Ext_Event_going_on <= 1'b0;
       end
       else begin
           if (Ext_Event_Stop == 1'b1 && Ext_Event_Valid == 1'b1) begin
               Ext_Event_going_on <= 1'b0;
           end
           else if (Ext_Event_Start == 1'b1 && Ext_Event_Valid == 1'b1)  begin
               Ext_Event_going_on <= 1'b1;
           end
           else begin
               Ext_Event_going_on <= Ext_Event_going_on;
           end
       end
    end 

    // External event and corresponding event valid registering
    always @(posedge clk) begin 
       if(rst_int_n == RST_ACTIVE) begin
         Ext_Event_d1       <= 0;
         Ext_Event_Valid_d1 <= 0;
       end
       else begin
         Ext_Event_d1       <= Ext_Event;
         Ext_Event_Valid_d1 <= Ext_Event_Valid;
       end
    end
 
    // Event count enable generation 
    always @(posedge clk) begin 
       if(rst_int_n == RST_ACTIVE) begin
         External_Event_Cnt_En <= 1'b0;
       end
       else begin
         External_Event_Cnt_En <=Ext_Event_going_on & Ext_Event_d1 & Metrics_Cnt_En & Ext_Event_Valid_d1;
       end
    end


endmodule









//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename     : axi_perf_mon_v5_0_12_register_module.v
// Version      : v5.0
// Description  : register module having all the registers of axi performance
//                monitor read and write logic. Address decoding is also
//                implemented in this module based on which the corresponding 
//                read and write enables being generated
// Verilog-Standard:verilog-2001  
//-----------------------------------------------------------------------------
// Structure:   
//
//  axi_perf_mon_v5_0_12_top.v
//      \-- axi_perf_mon_v5_0_12_register_module.v
//
//-----------------------------------------------------------------------------
// Author :    Kalpanath
// History: 
// Kalpanath 07/25/2012      First Version   
// ~~~~~~
// NLR       10/01/2013      Added new registers
// ~~~~~~
// NLR       24/03/2013      Added bram implementation for metric counters
//                           incrementors, sampled metric counters and
//                           sampled incrementors
// ~~~~~~~
// NLR       19/06/2013      Restructuring the code for coverage improvement     
// ~~~~~~~
// NLR       10/02/2013      Added new sample register and ID masking register
// ~~~~~~~                   Added logic for sample interval capture w.r.t 
//                           sample register read
//-----------------------------------------------------------------------------
`timescale 1ns/1ps
(* DowngradeIPIdentifiedWarnings="yes" *)

module axi_perf_mon_v5_0_12_register_module 
#(
   parameter                              C_FAMILY                     = "virtex7",
   // AXI port dependant parameters
   parameter                              C_S_AXI_ADDR_WIDTH           = 32,
   parameter                              C_S_AXI_DATA_WIDTH           = 32,

   parameter                              C_NUM_MONITOR_SLOTS          = 8,
   parameter                              C_NUM_OF_COUNTERS            = 10,
   parameter                              C_NUM_INTR_INPUTS            = 13,
   parameter                              C_ENABLE_EVENT_COUNT         = 1,  //-- enables/disables perf mon counting logic
   parameter                              C_ENABLE_EVENT_LOG           = 0,  //-- enables/disables perf mon log logic
   parameter                              C_METRICS_SAMPLE_COUNT_WIDTH = 32,
   parameter                              C_GLOBAL_COUNT_WIDTH         = 32,
   parameter                              C_SW_SYNC_DATA_WIDTH         = 32,  //-- Width of SW data register
   parameter                              C_AXIS_DWIDTH_ROUND_TO_32    = 64, // AXI Streaming FIFO width rounded to next 32bit
   parameter                              C_AXI4LITE_CORE_CLK_ASYNC    = 1   //-- disable synchronizers incase its 0 
)
(
   input                                             S_AXI_ACLK,
   input                                             S_AXI_ARESETN,

   // Controls to the IP/IPIF modules
   input [(C_S_AXI_ADDR_WIDTH - 1):0]                Bus2IP_Addr,  
   input [(C_S_AXI_DATA_WIDTH - 1):0]                Bus2IP_Data,    
   input [((C_S_AXI_DATA_WIDTH / 8)-1):0]            Bus2IP_BE, 
   input                                             Bus2IP_Burst,   
   input                                             Bus2IP_RdCE,   
   input                                             Bus2IP_WrCE,   
   output reg [(C_S_AXI_DATA_WIDTH - 1):0]           IP2Bus_Data, 
   output reg                                        IP2Bus_DataValid,
   output                                            IP2Bus_Error,

   input                                             CORE_ACLK,
   input                                             CORE_ARESETN,

   // Global Clock Counter - in core clk domain
   input [(C_GLOBAL_COUNT_WIDTH - 1):0]              Global_Clk_Cnt,    

   // Metric Counters - in core clk domain
   input [31:0]                                      Metric_Cnt_0,    
   input [31:0]                                      Metric_Cnt_1,    
   input [31:0]                                      Metric_Cnt_2,    
   input [31:0]                                      Metric_Cnt_3,    
   input [31:0]                                      Metric_Cnt_4,    
   input [31:0]                                      Metric_Cnt_5,    
   input [31:0]                                      Metric_Cnt_6,    
   input [31:0]                                      Metric_Cnt_7,    
   input [31:0]                                      Metric_Cnt_8,    
   input [31:0]                                      Metric_Cnt_9,    

   // Incrementers in core clk domain
   input [31:0]                                      Incrementer_0,    
   input [31:0]                                      Incrementer_1,    
   input [31:0]                                      Incrementer_2,    
   input [31:0]                                      Incrementer_3,    
   input [31:0]                                      Incrementer_4,    
   input [31:0]                                      Incrementer_5,    
   input [31:0]                                      Incrementer_6,    
   input [31:0]                                      Incrementer_7,    
   input [31:0]                                      Incrementer_8,    
   input [31:0]                                      Incrementer_9,    

   // Metric Counters - in core clk domain
   input [31:0]                                      Samp_Metric_Cnt_0,    
   input [31:0]                                      Samp_Metric_Cnt_1,    
   input [31:0]                                      Samp_Metric_Cnt_2,    
   input [31:0]                                      Samp_Metric_Cnt_3,    
   input [31:0]                                      Samp_Metric_Cnt_4,    
   input [31:0]                                      Samp_Metric_Cnt_5,    
   input [31:0]                                      Samp_Metric_Cnt_6,    
   input [31:0]                                      Samp_Metric_Cnt_7,    
   input [31:0]                                      Samp_Metric_Cnt_8,    
   input [31:0]                                      Samp_Metric_Cnt_9,    

   // Metric Counters - in core clk domain
   input [31:0]                                      Samp_Incrementer_0,    
   input [31:0]                                      Samp_Incrementer_1,    
   input [31:0]                                      Samp_Incrementer_2,    
   input [31:0]                                      Samp_Incrementer_3,    
   input [31:0]                                      Samp_Incrementer_4,    
   input [31:0]                                      Samp_Incrementer_5,    
   input [31:0]                                      Samp_Incrementer_6,    
   input [31:0]                                      Samp_Incrementer_7,    
   input [31:0]                                      Samp_Incrementer_8,    
   input [31:0]                                      Samp_Incrementer_9,    

   // Sample Interval Register - in axi clk domain
   output [(C_METRICS_SAMPLE_COUNT_WIDTH - 1):0]     Sample_Interval,    

   // Sample Interval Control Register - in axi clk domain
   output reg                                        Interval_Cnt_En,
   output reg                                        Interval_Cnt_Ld,
   output reg                                        Reset_On_Sample_Int_Lapse,

   // Interrupt Register Enables - in axi clk domain
   output reg                                        Global_Intr_En,
   output                                            Intr_Reg_IER_Wr_En,
   output                                            Intr_Reg_ISR_Wr_En,

   // Interrupt Registers - in axi clk domain
   input [(C_NUM_INTR_INPUTS - 1):0]                 Intr_Reg_IER,    
   input [(C_NUM_INTR_INPUTS - 1):0]                 Intr_Reg_ISR,    

   //rd: clk,rst will be either stream/aximm 
   input                                             eventlog_rd_clk ,
   input                                             eventlog_rd_rstn,
   input [31:0]                                      eventlog_cur_cnt,

   // Metric Selector Registers - in axi clk domain
   output     [7:0]                                  Metric_Sel_0,    
   output     [7:0]                                  Metric_Sel_1,    
   output     [7:0]                                  Metric_Sel_2,    
   output     [7:0]                                  Metric_Sel_3,    
   output     [7:0]                                  Metric_Sel_4,    
   output     [7:0]                                  Metric_Sel_5,    
   output     [7:0]                                  Metric_Sel_6,    
   output     [7:0]                                  Metric_Sel_7,    
   output     [7:0]                                  Metric_Sel_8,    
   output     [7:0]                                  Metric_Sel_9,    

   // Range Registers - in axi clk domain
   output     [31:0]                                 Range_Reg_0,    
   output     [31:0]                                 Range_Reg_1,    
   output     [31:0]                                 Range_Reg_2,    
   output     [31:0]                                 Range_Reg_3,    
   output     [31:0]                                 Range_Reg_4,    
   output     [31:0]                                 Range_Reg_5,    
   output     [31:0]                                 Range_Reg_6,    
   output     [31:0]                                 Range_Reg_7,    
   output     [31:0]                                 Range_Reg_8,    
   output     [31:0]                                 Range_Reg_9,    

   // Event Log Registers - in axi clk domain
   output     [6:0]                                  Flag_Enable_Reg,    
   output                                            SW_Data_Log_En, 
   output     [2:0]                                  Ext_Event_Flag_En,   

   output  [C_SW_SYNC_DATA_WIDTH-1:0]                SW_Data,    
   output                                            SW_Data_Wr_En,    

   // Control Register - in axi clk domain
   output reg                                        Global_Clk_Cnt_En,
   output reg                                        Global_Clk_Cnt_Reset,
   output reg                                        Streaming_FIFO_Reset,
   output reg                                        Event_Log_En,
   output reg                                        Metrics_Cnt_En,
   output reg                                        Metrics_Cnt_Reset,
   output reg                                        Use_Ext_Trigger,
   output reg                                        Use_Ext_Trigger_Log,
   // Flag enable register - in axi clk domain
   output                                            Global_Clk_Cnt_Ovf_En,
   output                                            Sample_Metric_Cnt_Ovf_En,
   // Flag enable register - in core clk domain
   output reg                                        Count_Event_Log_En,
   output     [15:0]                                 Latency_WID,
   output     [15:0]                                 Latency_RID,
   output reg                                        En_Id_Based,
   output                                            Lat_Sample_Reg,
   output     [15:0]                                 WID_Mask,
   output     [15:0]                                 RID_Mask,
   output                                            Wr_Lat_Start,
   output                                            Wr_Lat_End,
   output                                            Rd_Lat_Start,
   output                                            Rd_Lat_End
);


//-------------------------------------------------------------------
// Parameter Declaration
//-------------------------------------------------------------------
localparam RST_ACTIVE = 1'b0;
localparam TIME_DIFF_LOAD_VALUE = 32'h0001;

//-------------------------------------------------------------------
// Metric count ram declaration
//-------------------------------------------------------------------
//(* ram_style = "block" *) reg [31:0] Metric_ram_CDCR [255:0];
 reg [31:0]                       Metric_ram_CDCR [255:0];
 reg [7:0]                        Lat_Addr_9downto2_CDC;
 wire [31:0]                      Metric_ram_Out;

// Signal and Register Declaration-PR#741428
  wire [31:0] sync_eventlog_cur_cnt;


//-------------------------------------------------------------------
// Signal and Register Declaration
//-------------------------------------------------------------------
wire                                Rd_En_sync;
wire                                RValid;
wire [31:0]                         Sample_Interval_i;    
wire [31:0]                         Global_Clk_Cnt_MSB;  
wire [31:0]                         Global_Clk_Cnt_LSB;  
wire [31:0]                         Control_Reg;  

reg  [C_S_AXI_DATA_WIDTH-1:0]       IP2Bus_Data_Int;
reg  [31:0]                         Lat_Global_Clk_Cnt_MSB_CDCR;  
reg  [31:0]                         Lat_Global_Clk_Cnt_LSB_CDCR;  
reg     [7:0]                       Metric_Sel_0_CDC;    
reg     [7:0]                       Metric_Sel_1_CDC;    
reg     [7:0]                       Metric_Sel_2_CDC;    
reg     [7:0]                       Metric_Sel_3_CDC;    
reg     [7:0]                       Metric_Sel_4_CDC;    
reg     [7:0]                       Metric_Sel_5_CDC;    
reg     [7:0]                       Metric_Sel_6_CDC;    
reg     [7:0]                       Metric_Sel_7_CDC;    
reg     [7:0]                       Metric_Sel_8_CDC;    
reg     [7:0]                       Metric_Sel_9_CDC;    

reg     [31:0]                      Range_Reg_0_CDC;    
reg     [31:0]                      Range_Reg_1_CDC;    
reg     [31:0]                      Range_Reg_2_CDC;    
reg     [31:0]                      Range_Reg_3_CDC;    
reg     [31:0]                      Range_Reg_4_CDC;    
reg     [31:0]                      Range_Reg_5_CDC;    
reg     [31:0]                      Range_Reg_6_CDC;    
reg     [31:0]                      Range_Reg_7_CDC;    
reg     [31:0]                      Range_Reg_8_CDC;    
reg     [31:0]                      Range_Reg_9_CDC;    

reg     [31:0]                      Count0_Cut_Off_CDC;
reg     [31:0]                      Count1_Cut_Off_CDC;
reg     [31:0]                      Count2_Cut_Off_CDC;
reg     [31:0]                      Count3_Cut_Off_CDC;
reg     [31:0]                      Count4_Cut_Off_CDC;
reg     [31:0]                      Count5_Cut_Off_CDC;
reg     [31:0]                      Count6_Cut_Off_CDC;
reg     [31:0]                      Count7_Cut_Off_CDC;
reg     [31:0]                      Count8_Cut_Off_CDC;
reg     [31:0]                      Count9_Cut_Off_CDC;
reg                                 Lat_Addr_7downto4_is_0x0    ; 
reg                                 Lat_Addr_7downto4_is_0x1    ; 
reg                                 Lat_Addr_7downto4_is_0x2    ; 
reg                                 Lat_Addr_7downto4_is_0x3    ; 
reg                                 Lat_Addr_7downto4_is_0x4    ; 
reg                                 Lat_Addr_7downto4_is_0x5    ; 
reg                                 Lat_Addr_7downto4_is_0x6    ; 
reg                                 Lat_Addr_7downto4_is_0x7    ; 
reg                                 Lat_Addr_7downto4_is_0x8    ; 
reg                                 Lat_Addr_7downto4_is_0x9    ; 
reg                                 Lat_Addr_3downto0_is_0x0;
reg                                 Lat_Addr_3downto0_is_0x4;
reg                                 Lat_Addr_3downto0_is_0x8;
reg                                 Lat_Addr_3downto0_is_0xC;
reg                                 Lat_Control_Set_Rd_En       ; 
reg                                 Lat_Sample_Interval_Rd_En   ; 
reg                                 Lat_Global_Clk_Cnt_Set_Rd_En; 
reg                                 Lat_Global_Clk_Cnt_LSB_Rd_En; 
reg                                 Lat_Global_Clk_Cnt_MSB_Rd_En; 
reg                                 Lat_Intr_Reg_Set_Rd_En      ; 
reg                                 Lat_Intr_Reg_GIE_Rd_En      ; 
reg                                 Lat_Intr_Reg_IER_Rd_En      ; 
reg                                 Lat_Intr_Reg_ISR_Rd_En      ; 
reg                                 Lat_Sel_Reg_Set_Rd_En       ; 
reg                                 Lat_Metric_Sel_Reg_0_Rd_En  ; 
reg                                 Lat_Metric_Sel_Reg_1_Rd_En  ; 
reg                                 Lat_Metric_Sel_Reg_2_Rd_En  ; 
reg                                 Lat_Status_Reg_Set_Rd_En  ; 
reg                                 Lat_Status_Reg_FOC_Rd_En  ; 
reg                                 Lat_Status_Reg_WIF_Rd_En  ; 
reg                                 Lat_Rng_Reg_Set_Rd_En       ; 
reg                                 Lat_Metric_Cnt_Reg_Set_Rd_En; 
reg                                 Lat_Incr_Reg_Set_Rd_En      ; 
reg                                 Lat_Samp_Metric_Cnt_Reg_Set_Rd_En; 
reg                                 Lat_Samp_Incr_Reg_Set_Rd_En      ; 
reg                                 Lat_Event_Log_Set_Rd_En     ; 
reg                                 Lat_Latency_ID_Rd_En;
reg                                 Lat_ID_Mask_Rd_En;

reg                                 Count0_Event_Log_En_i;
reg                                 Count1_Event_Log_En_i;
reg                                 Count2_Event_Log_En_i;
reg                                 Count3_Event_Log_En_i;
reg                                 Count4_Event_Log_En_i;
reg                                 Count5_Event_Log_En_i;
reg                                 Count6_Event_Log_En_i;
reg                                 Count7_Event_Log_En_i;
reg                                 Count8_Event_Log_En_i;
reg                                 Count9_Event_Log_En_i;

reg                                 Lat_Enlog_Reg_Set_Rd_En;
reg                                 Lat_Sample_Reg_Rd_En;
reg                                 Lat_Sample_Reg_Rd_En_d3;
reg                                 Lat_Sample_Reg_Rd_En_d1;
wire                                Lat_Sample_Reg_Rd_En_d2;
wire  [9:0]                         Metric_Cnt_Ovf_En;  


wire [31:0]                         Count0_Cut_Off;
wire [31:0]                         Count1_Cut_Off;
wire [31:0]                         Count2_Cut_Off;
wire [31:0]                         Count3_Cut_Off;
wire [31:0]                         Count4_Cut_Off;
wire [31:0]                         Count5_Cut_Off;
wire [31:0]                         Count6_Cut_Off;
wire [31:0]                         Count7_Cut_Off;
wire [31:0]                         Count8_Cut_Off;
wire [31:0]                         Count9_Cut_Off;

wire                                Count0_Event_Log_En;
wire                                Count1_Event_Log_En;
wire                                Count2_Event_Log_En;
wire                                Count3_Event_Log_En;
wire                                Count4_Event_Log_En;
wire                                Count5_Event_Log_En;
wire                                Count6_Event_Log_En;
wire                                Count7_Event_Log_En;
wire                                Count8_Event_Log_En;
wire                                Count9_Event_Log_En;

wire [9:0]                          Sync_Metric_Cnt_Ovf_En;
wire [31:0]                         Lat_Global_Clk_Cnt_MSB;  

wire                               SW_Data_Wr_En_int;
reg [31:0]                         Sample_Interval_i_reg_CDC;
// ID filtering and masking bits
reg [15:0]                         Latency_WID_CDC;
reg [15:0]                         Latency_RID_CDC;
reg [15:0]                         WID_Mask_CDC;
reg [15:0]                         RID_Mask_CDC;
// latency start and end points
reg                                Wr_Lat_Start_CDC;
reg                                Wr_Lat_End_CDC;
reg                                Rd_Lat_Start_CDC;
reg                                Rd_Lat_End_CDC;
//Sample register read interval counter enable 
reg  [31:0]                        Sample_Time_Diff_Reg;  
reg                                Sample_Reg_Rd_First;  
wire [31:0]                        Sample_Time_Diff;  
wire [(C_NUM_INTR_INPUTS - 1):0]   Intr_Reg_IER_Int;    
//-------------------------------------------------------------------
// Begin architecture
//-------------------------------------------------------------------
assign IP2Bus_Error = 0;      // No error conditions hence tieng off the error signal to 0 
wire Addr_15downto8_is_0x00 = (Bus2IP_Addr[15:8] == 8'h00) ? 1'b1 : 1'b0;
wire Addr_15downto8_is_0x01 = (Bus2IP_Addr[15:8] == 8'h01) ? 1'b1 : 1'b0;
wire Addr_15downto8_is_0x02 = (Bus2IP_Addr[15:8] == 8'h02) ? 1'b1 : 1'b0;
wire Addr_15downto8_is_0x03 = (Bus2IP_Addr[15:8] == 8'h03) ? 1'b1 : 1'b0;
wire Addr_15downto8_is_0x04 = (Bus2IP_Addr[15:8] == 8'h04) ? 1'b1 : 1'b0;

wire Addr_7downto0_is_0x00  = (Bus2IP_Addr[7:0] == 8'h00) ? 1'b1 : 1'b0;
wire Addr_7downto0_is_0x04  = (Bus2IP_Addr[7:0] == 8'h04) ? 1'b1 : 1'b0;
wire Addr_7downto0_is_0x08  = (Bus2IP_Addr[7:0] == 8'h08) ? 1'b1 : 1'b0;

wire Addr_7downto4_is_0x0   = (Bus2IP_Addr[7:4] == 4'h0) ? 1'b1 : 1'b0;
wire Addr_7downto4_is_0x1   = (Bus2IP_Addr[7:4] == 4'h1) ? 1'b1 : 1'b0;
wire Addr_7downto4_is_0x2   = (Bus2IP_Addr[7:4] == 4'h2) ? 1'b1 : 1'b0;
wire Addr_7downto4_is_0x3   = (Bus2IP_Addr[7:4] == 4'h3) ? 1'b1 : 1'b0;
wire Addr_7downto4_is_0x4   = (Bus2IP_Addr[7:4] == 4'h4) ? 1'b1 : 1'b0;
wire Addr_7downto4_is_0x5   = (Bus2IP_Addr[7:4] == 4'h5) ? 1'b1 : 1'b0;
wire Addr_7downto4_is_0x6   = (Bus2IP_Addr[7:4] == 4'h6) ? 1'b1 : 1'b0;
wire Addr_7downto4_is_0x7   = (Bus2IP_Addr[7:4] == 4'h7) ? 1'b1 : 1'b0;
wire Addr_7downto4_is_0x8   = (Bus2IP_Addr[7:4] == 4'h8) ? 1'b1 : 1'b0;
wire Addr_7downto4_is_0x9   = (Bus2IP_Addr[7:4] == 4'h9) ? 1'b1 : 1'b0;

wire Addr_3downto0_is_0x0   = (Bus2IP_Addr[3:0] == 4'h0) ? 1'b1 : 1'b0;
wire Addr_3downto0_is_0x4   = (Bus2IP_Addr[3:0] == 4'h4) ? 1'b1 : 1'b0;
wire Addr_3downto0_is_0x8   = (Bus2IP_Addr[3:0] == 4'h8) ? 1'b1 : 1'b0;
wire Addr_3downto0_is_0xC   = (Bus2IP_Addr[3:0] == 4'hC) ? 1'b1 : 1'b0;
//-------------------------------------------------------------------------------
//-- Write enables and read enables generation
//-------------------------------------------------------------------------------

//-- Write enable for Control Register
wire Control_Set_Wr_En = Bus2IP_WrCE && Addr_15downto8_is_0x03 && Addr_7downto0_is_0x00;

//-- Read enable for Control Register
wire Control_Set_Rd_En = Bus2IP_RdCE && Addr_15downto8_is_0x03 && Addr_7downto0_is_0x00;

//-- Write enable for Latency ID register
wire Latency_ID_Wr_En = Bus2IP_WrCE && Addr_15downto8_is_0x03 && Addr_7downto0_is_0x04;
wire ID_Mask_Wr_En = Bus2IP_WrCE && Addr_15downto8_is_0x03 && Addr_7downto0_is_0x08;

//-- Read enable for Latency ID Register
wire Latency_ID_Rd_En = Bus2IP_RdCE && Addr_15downto8_is_0x03 && Addr_7downto0_is_0x04;
wire ID_Mask_Rd_En = Bus2IP_RdCE && Addr_15downto8_is_0x03 && Addr_7downto0_is_0x08;

//-- Write enable for Sample Interval Registers
wire Sample_Interval_Wr_En = Bus2IP_WrCE && Addr_15downto8_is_0x00 && Addr_7downto4_is_0x2;

//-- Read enable for Sample Interval Registers
wire Sample_Interval_Rd_En = Bus2IP_RdCE && Addr_15downto8_is_0x00 && Addr_7downto4_is_0x2;
wire Sample_Reg_Rd_En = Bus2IP_RdCE && Addr_15downto8_is_0x00 && Addr_7downto4_is_0x2 && Addr_3downto0_is_0xC;

//-- Read enables for Global Clock Count Registers
wire Global_Clk_Cnt_Set_Rd_En = Bus2IP_RdCE && Addr_15downto8_is_0x00 && Addr_7downto4_is_0x0;
wire Global_Clk_Cnt_MSB_Rd_En = Global_Clk_Cnt_Set_Rd_En && Addr_3downto0_is_0x0;
wire Global_Clk_Cnt_LSB_Rd_En = Global_Clk_Cnt_Set_Rd_En && Addr_3downto0_is_0x4;

//-- Write enables for Interrupt Registers
wire Intr_Reg_Set_Wr_En = Bus2IP_WrCE && Addr_15downto8_is_0x00 && Addr_7downto4_is_0x3;
wire Intr_Reg_GIE_Wr_En = Intr_Reg_Set_Wr_En && Addr_3downto0_is_0x0;
assign Intr_Reg_IER_Wr_En = Intr_Reg_Set_Wr_En && Addr_3downto0_is_0x4;
assign Intr_Reg_ISR_Wr_En = Intr_Reg_Set_Wr_En && Addr_3downto0_is_0x8;

//-- Read enables for Interrupt Registers
wire Intr_Reg_Set_Rd_En = Bus2IP_RdCE && Addr_15downto8_is_0x00 && Addr_7downto4_is_0x3;
wire Intr_Reg_GIE_Rd_En = Intr_Reg_Set_Rd_En && Addr_3downto0_is_0x0;
wire Intr_Reg_IER_Rd_En = Intr_Reg_Set_Rd_En && Addr_3downto0_is_0x4;
wire Intr_Reg_ISR_Rd_En = Intr_Reg_Set_Rd_En && Addr_3downto0_is_0x8;

//-- Write enables for Selector Registers
wire Sel_Reg_Set_Wr_En      = Bus2IP_WrCE && Addr_15downto8_is_0x00 && Addr_7downto4_is_0x4;
wire Metric_Sel_Reg_0_Wr_En = Sel_Reg_Set_Wr_En && Addr_3downto0_is_0x4;
wire Metric_Sel_Reg_1_Wr_En = Sel_Reg_Set_Wr_En && Addr_3downto0_is_0x8;
wire Metric_Sel_Reg_2_Wr_En = Sel_Reg_Set_Wr_En && Addr_3downto0_is_0xC;

//-- Read enables for Selector Registers
wire Sel_Reg_Set_Rd_En      = Bus2IP_RdCE && Addr_15downto8_is_0x00 && Addr_7downto4_is_0x4;
wire Metric_Sel_Reg_0_Rd_En = Sel_Reg_Set_Rd_En && Addr_3downto0_is_0x4;
wire Metric_Sel_Reg_1_Rd_En = Sel_Reg_Set_Rd_En && Addr_3downto0_is_0x8;
wire Metric_Sel_Reg_2_Rd_En = Sel_Reg_Set_Rd_En && Addr_3downto0_is_0xC;

//-- Write enables for status Registers
//  -- 0x0:FOC: Fifo Occupancy 
//  -- 0x4:WIF: Words in FIFO.
wire Status_Reg_Set_Wr_En = Bus2IP_WrCE && Addr_15downto8_is_0x00 && Addr_7downto4_is_0x5;
wire Status_Reg_FOC_Wr_En = Status_Reg_Set_Wr_En && Addr_3downto0_is_0x0;
//-- Read enables for status Registers
wire Status_Reg_Set_Rd_En = Bus2IP_RdCE && Addr_15downto8_is_0x00 && Addr_7downto4_is_0x5;
wire Status_Reg_FOC_Rd_En = Status_Reg_Set_Rd_En && Addr_3downto0_is_0x0;
wire Status_Reg_WIF_Rd_En = Status_Reg_Set_Rd_En && Addr_3downto0_is_0x4;

//-- Write enable for Range Registers
wire Rng_Reg_Set_Wr_En      = Bus2IP_WrCE && Addr_15downto8_is_0x01 && Addr_3downto0_is_0x8;

//-- Read enables for Range Registers
wire Rng_Reg_Set_Rd_En      = Bus2IP_RdCE && Addr_15downto8_is_0x01 && Addr_3downto0_is_0x8;

//-- Read enables for Metric Cnt Registers
wire Metric_Cnt_Reg_Set_Rd_En  = Bus2IP_RdCE && Addr_15downto8_is_0x01 && Addr_3downto0_is_0x0;

//-- Read enables for Incrementer Registers
wire Incr_Reg_Set_Rd_En  = Bus2IP_RdCE && Addr_15downto8_is_0x01 && Addr_3downto0_is_0x4;

//-- Write enable for Event log start register
wire Enlog_Reg_Set_Wr_En =  Bus2IP_WrCE && Addr_15downto8_is_0x01 && Addr_3downto0_is_0xC;

//-- Read enable for Event log start register
wire Enlog_Reg_Set_Rd_En =  Bus2IP_RdCE && Addr_15downto8_is_0x01 && Addr_3downto0_is_0xC;

//-- Read enables for Sampled Metric Cnt Registers
wire Samp_Metric_Cnt_Reg_Set_Rd_En  = Bus2IP_RdCE && Addr_15downto8_is_0x02 && Addr_3downto0_is_0x0;

//-- Read enables for Sampled Incrementer Registers
wire Samp_Incr_Reg_Set_Rd_En  = Bus2IP_RdCE && Addr_15downto8_is_0x02 && Addr_3downto0_is_0x4;

//-- Write enable for Event Log Registers
wire Event_Log_Set_Wr_En    = Bus2IP_WrCE && Addr_15downto8_is_0x04 && Addr_7downto4_is_0x0;

//-- Read enable for Event Log Registers
wire Event_Log_Set_Rd_En    = Bus2IP_RdCE && Addr_15downto8_is_0x04 && Addr_7downto4_is_0x0;

//-- Control Register
always @(posedge S_AXI_ACLK) begin 
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       Metrics_Cnt_En        <= 1'b0;
       Metrics_Cnt_Reset     <= 1'b0;
       Event_Log_En          <= 1'b0;
       Global_Clk_Cnt_En     <= 1'b0;
       Global_Clk_Cnt_Reset  <= 1'b0;
       Streaming_FIFO_Reset  <= 1'b0;
       Use_Ext_Trigger       <= 1'b0;
       Use_Ext_Trigger_Log   <= 1'b0;
       En_Id_Based           <= 1'b0;
       Wr_Lat_Start_CDC      <= 1'b0;
       Wr_Lat_End_CDC        <= 1'b0;
       Rd_Lat_Start_CDC      <= 1'b0;
       Rd_Lat_End_CDC        <= 1'b0;
   end
   else begin 
       if (Control_Set_Wr_En == 1'b1) begin
           Metrics_Cnt_En        <= Bus2IP_Data[0];
           Metrics_Cnt_Reset     <= Bus2IP_Data[1];
           Use_Ext_Trigger       <= Bus2IP_Data[2];
           En_Id_Based           <= Bus2IP_Data[3];
           Wr_Lat_Start_CDC      <= Bus2IP_Data[4];
           Wr_Lat_End_CDC        <= Bus2IP_Data[5];
           Rd_Lat_Start_CDC      <= Bus2IP_Data[6];
           Rd_Lat_End_CDC        <= Bus2IP_Data[7];
           Event_Log_En          <= Bus2IP_Data[8];
           Use_Ext_Trigger_Log   <= Bus2IP_Data[9];
           Global_Clk_Cnt_En     <= Bus2IP_Data[16];
           Global_Clk_Cnt_Reset  <= Bus2IP_Data[17];
           Streaming_FIFO_Reset  <= Bus2IP_Data[25];
       end
       else begin
           Metrics_Cnt_En        <= Metrics_Cnt_En;
           Metrics_Cnt_Reset     <= Metrics_Cnt_Reset;
           Use_Ext_Trigger       <= Use_Ext_Trigger;
           En_Id_Based           <= En_Id_Based;
           Wr_Lat_Start_CDC      <= Wr_Lat_Start_CDC;
           Wr_Lat_End_CDC        <= Wr_Lat_End_CDC;
           Rd_Lat_Start_CDC      <= Rd_Lat_Start_CDC;
           Rd_Lat_End_CDC        <= Rd_Lat_End_CDC;
           Event_Log_En          <= Event_Log_En;
           Use_Ext_Trigger_Log   <= Use_Ext_Trigger_Log;
           Global_Clk_Cnt_En     <= Global_Clk_Cnt_En;
           Global_Clk_Cnt_Reset  <= Global_Clk_Cnt_Reset;
           Streaming_FIFO_Reset  <= Streaming_FIFO_Reset;
       end
   end
end 

assign  Wr_Lat_Start = Wr_Lat_Start_CDC;
assign  Wr_Lat_End   = Wr_Lat_End_CDC;
assign  Rd_Lat_Start = Rd_Lat_Start_CDC;
assign  Rd_Lat_End   = Rd_Lat_End_CDC;


//-- ID Filter register
always @(posedge S_AXI_ACLK) begin 
   if (S_AXI_ARESETN == RST_ACTIVE) begin
      Latency_WID_CDC <= 0; 
      Latency_RID_CDC <= 0; 
   end
   else begin
      if(Latency_ID_Wr_En == 1'b1) begin
         Latency_WID_CDC <= Bus2IP_Data[15:0]; 
         Latency_RID_CDC <= Bus2IP_Data[31:16]; 
      end
      else begin
         Latency_WID_CDC <= Latency_WID_CDC;
         Latency_RID_CDC <= Latency_RID_CDC;
      end
   end
end

assign Latency_WID = Latency_WID_CDC;
assign Latency_RID = Latency_RID_CDC;

//-- ID Mask Register
always @(posedge S_AXI_ACLK) begin 
   if (S_AXI_ARESETN == RST_ACTIVE) begin
      WID_Mask_CDC <= 0; 
      RID_Mask_CDC <= 0; 
   end
   else begin
      if(ID_Mask_Wr_En == 1'b1) begin
         WID_Mask_CDC <= Bus2IP_Data[15:0]; 
         RID_Mask_CDC <= Bus2IP_Data[31:16]; 
      end
      else begin
         WID_Mask_CDC <= WID_Mask_CDC;
         RID_Mask_CDC <= RID_Mask_CDC;
      end
   end
end

assign WID_Mask = WID_Mask_CDC;
assign RID_Mask = RID_Mask_CDC;

//-- Sample Interval LSB Register
always @(posedge S_AXI_ACLK) begin 
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       Sample_Interval_i_reg_CDC <= 0;
   end
   else begin
       if ((Sample_Interval_Wr_En == 1'b1) && (Addr_3downto0_is_0x4 == 1'b1)) begin
           Sample_Interval_i_reg_CDC <= Bus2IP_Data[31:0];
       end
       else begin
           Sample_Interval_i_reg_CDC <= Sample_Interval_i_reg_CDC;
       end
   end
end 
  assign Sample_Interval_i = Sample_Interval_i_reg_CDC;
  assign Sample_Interval = Sample_Interval_i[31:0];

//-- Sample Interval Control Register
always @(posedge S_AXI_ACLK) begin 
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       Interval_Cnt_En             <= 1'b0;
       Interval_Cnt_Ld             <= 1'b0;
       Reset_On_Sample_Int_Lapse   <= 1'b1;
   end
   else begin
       if ((Sample_Interval_Wr_En == 1'b1) && (Addr_3downto0_is_0x8 == 1'b1)) begin
           Interval_Cnt_En             <= Bus2IP_Data[0];
           Interval_Cnt_Ld             <= Bus2IP_Data[1];
           Reset_On_Sample_Int_Lapse   <= Bus2IP_Data[8];
       end
       else begin
           Interval_Cnt_En             <= Interval_Cnt_En     ;
           Interval_Cnt_Ld             <= Interval_Cnt_Ld     ;
           Reset_On_Sample_Int_Lapse   <= Reset_On_Sample_Int_Lapse;
       end
   end
end 

//-- sample register read edge detection logic. 
//-- This will b used in core_aclk domain
generate
    if(C_AXI4LITE_CORE_CLK_ASYNC == 1 && C_ENABLE_EVENT_COUNT == 1) begin :GEN_SAMPLE_REG_ASYNC

    // Synchronizing sample register read enable 
    //-- Double Flop synchronization
    axi_perf_mon_v5_0_12_cdc_sync
    #(
       .c_cdc_type      (1             ),   
       .c_flop_input    (0             ),  
       .c_reset_state   (1             ),  
       .c_single_bit    (1             ),  
       .c_vector_width  (1             ),  
       .c_mtbf_stages   (4             )  
     ) sample_reg_read_inst 
     (
       .prmry_aclk      (S_AXI_ACLK              ),
       .prmry_rst_n     (S_AXI_ARESETN           ),
       .prmry_in        (Lat_Sample_Reg_Rd_En    ),
       .prmry_vect_in   (1'b0                    ),
       .scndry_aclk     (CORE_ACLK               ),
       .scndry_rst_n    (CORE_ARESETN            ),
       .prmry_ack       (                        ),
       .scndry_out      (Lat_Sample_Reg_Rd_En_d2 ),
       .scndry_vect_out (                        ) 
      );

       always @(posedge CORE_ACLK) begin 
         if (CORE_ARESETN == RST_ACTIVE) begin
            Lat_Sample_Reg_Rd_En_d3      <= 0;
         end
         else begin
            Lat_Sample_Reg_Rd_En_d3      <= Lat_Sample_Reg_Rd_En_d2;
         end
       end 

     //-- This rising edge pulse will be used to sample metric counts into sampled metric counts
     assign Lat_Sample_Reg =  Lat_Sample_Reg_Rd_En_d2 && ~Lat_Sample_Reg_Rd_En_d3;
  
    end
    else begin :GEN_SAMPLE_REG_SYNC
      always @(posedge CORE_ACLK) begin 
        if (CORE_ARESETN == RST_ACTIVE) begin
           Lat_Sample_Reg_Rd_En_d1      <= 0;
        end
        else begin
           Lat_Sample_Reg_Rd_En_d1      <= Lat_Sample_Reg_Rd_En;
        end
      end 

      assign  Lat_Sample_Reg= Lat_Sample_Reg_Rd_En && ~Lat_Sample_Reg_Rd_En_d1; 
    end

   endgenerate

   //-- Free running Counter after first read of sample register read 
   //-- The number of clocks is in S_AXI_ACLK domain
   axi_perf_mon_v5_0_12_counter 
     #(
          .C_FAMILY             (C_FAMILY),
          .C_NUM_BITS           (32),
	  .COUNTER_LOAD_VALUE   (32'h00000000)
      ) sample_reg_counter_inst 
      (
          .clk                  (S_AXI_ACLK),
          .rst_n                (S_AXI_ARESETN),
          .Load_In              (TIME_DIFF_LOAD_VALUE),
          .Count_Enable         (Sample_Reg_Rd_First),
          .Count_Load           (1'b0),
          .Count_Down           (1'b0),
          .Count_Out            (Sample_Time_Diff),
          .Carry_Out            ( )  //Overflow is left to the SW as they need to find out
                             // time difference between two sample register reads
      );  
   
   
   //-- Sample time difference capture 
   always @(posedge S_AXI_ACLK) begin 
      if (S_AXI_ARESETN == RST_ACTIVE) begin
          Sample_Time_Diff_Reg<= 0;
          Sample_Reg_Rd_First <= 0;
      end
      else begin
          if (Sample_Reg_Rd_En == 1'b1) begin
             Sample_Time_Diff_Reg<= Sample_Time_Diff;
             Sample_Reg_Rd_First <= 1;
          end
          else begin
             Sample_Time_Diff_Reg<= Sample_Time_Diff_Reg;
             Sample_Reg_Rd_First <= Sample_Reg_Rd_First;
          end
      end
   end 

   //-- Global Interrupt Enable Register
   always @(posedge S_AXI_ACLK) begin 
      if (S_AXI_ARESETN == RST_ACTIVE) begin
          Global_Intr_En <= 1'b0;
      end
      else begin
          if ((Intr_Reg_GIE_Wr_En == 1'b1)) begin
              Global_Intr_En <= Bus2IP_Data[0];
          end
          else begin
              Global_Intr_En <= Global_Intr_En;
          end
      end
   end 

//-- Global Clock Count (for 64-bit and 32-bit)
generate
if (C_GLOBAL_COUNT_WIDTH == 64) begin : GEN_GLOBAL_CLK_64
    assign Global_Clk_Cnt_LSB = Global_Clk_Cnt[31:0];
    assign Global_Clk_Cnt_MSB = Global_Clk_Cnt[63:32];
 
    //-- Latch global clk cnt MSB on synchronized RdEn
    always @(posedge CORE_ACLK) begin 
       if (CORE_ARESETN == RST_ACTIVE) begin
           Lat_Global_Clk_Cnt_MSB_CDCR <= 0;
           Lat_Global_Clk_Cnt_LSB_CDCR <= 0;
       end
       else begin
           if ((Rd_En_sync == 1'b1)) begin
               Lat_Global_Clk_Cnt_MSB_CDCR <= Global_Clk_Cnt_MSB;
               Lat_Global_Clk_Cnt_LSB_CDCR <= Global_Clk_Cnt_LSB;
           end
           else begin
               Lat_Global_Clk_Cnt_MSB_CDCR <= Lat_Global_Clk_Cnt_MSB_CDCR;
               Lat_Global_Clk_Cnt_LSB_CDCR <= Lat_Global_Clk_Cnt_LSB_CDCR;
           end
       end
    end 
    assign Lat_Global_Clk_Cnt_MSB = Lat_Global_Clk_Cnt_MSB_CDCR;
    
end    
else if (C_GLOBAL_COUNT_WIDTH == 32) begin : GEN_GLOBAL_CLK_32
    assign Global_Clk_Cnt_LSB = Global_Clk_Cnt[31:0];
    assign Global_Clk_Cnt_MSB = {32{1'b0}};

    //-- Latch global clk cnt MSB on synchronized RdEn
    always @(posedge CORE_ACLK) begin 
       if (CORE_ARESETN == RST_ACTIVE) begin
           Lat_Global_Clk_Cnt_LSB_CDCR <= 0;
       end
       else begin
           if ((Rd_En_sync == 1'b1)) begin
               Lat_Global_Clk_Cnt_LSB_CDCR <= Global_Clk_Cnt_LSB;
           end
           else begin
               Lat_Global_Clk_Cnt_LSB_CDCR <= Lat_Global_Clk_Cnt_LSB_CDCR;
           end
       end
    end 
    
    assign Lat_Global_Clk_Cnt_MSB = 0;
end    
endgenerate

generate
   if( C_ENABLE_EVENT_COUNT == 1 && C_ENABLE_EVENT_LOG == 1) begin :GEN_CNTRL_REG
   //--IER register read data
   assign Intr_Reg_IER_Int = Intr_Reg_IER;
   //--Control Register read
   assign Control_Reg = { {6{1'b0}}, Streaming_FIFO_Reset, 1'b0,
                          {6{1'b0}}, Global_Clk_Cnt_Reset, Global_Clk_Cnt_En,
                          {6{1'b0}}, Use_Ext_Trigger_Log, Event_Log_En,
                          Rd_Lat_End_CDC,Rd_Lat_Start_CDC,Wr_Lat_End_CDC,Wr_Lat_Start_CDC,
                          En_Id_Based,Use_Ext_Trigger,Metrics_Cnt_Reset, Metrics_Cnt_En };
end
else if(C_ENABLE_EVENT_COUNT == 1) begin:GEN_CNTRL_REG_EVENT_COUNT
   //--IER register read data
   assign Intr_Reg_IER_Int = {Intr_Reg_IER[12:3],1'b0,Intr_Reg_IER[1:0]};
   assign Control_Reg = { {14{1'b0}},
                          Global_Clk_Cnt_Reset, Global_Clk_Cnt_En,
                          {8{1'b0}},
                          Rd_Lat_End_CDC,Rd_Lat_Start_CDC,Wr_Lat_End_CDC,Wr_Lat_Start_CDC,
                          En_Id_Based,Use_Ext_Trigger,Metrics_Cnt_Reset, Metrics_Cnt_En };
end
else if(C_ENABLE_EVENT_LOG == 1) begin:GEN_CNTRL_REG_LOG
   assign Intr_Reg_IER_Int = { {10{1'b0}},Intr_Reg_IER[2],1'b0,Intr_Reg_IER[0]};
   assign Control_Reg = { {6{1'b0}}, Streaming_FIFO_Reset, 1'b0,
                          {6{1'b0}}, Global_Clk_Cnt_Reset, Global_Clk_Cnt_En,
                          {6{1'b0}}, Use_Ext_Trigger_Log, Event_Log_En,{8{1'b0}} };
end
endgenerate


// Synchronizing the enable only. User should load cutt off count and then need to enable 

    generate
    if(C_AXI4LITE_CORE_CLK_ASYNC == 1 && C_ENABLE_EVENT_COUNT == 1 && C_ENABLE_EVENT_LOG == 1) begin:GEN_Metric_Cnt_ASYNC

    // Synchronizing cross probing for 10-metric counters 
    //-- Double Flop synchronization
    axi_perf_mon_v5_0_12_cdc_sync
    #(
       .c_cdc_type      (1             ),   
       .c_flop_input    (0             ),  
       .c_reset_state   (1             ),  
       .c_single_bit    (0             ),  
       .c_vector_width  (10            ),  
       .c_mtbf_stages   (4             )  
     ) Sync_Metric_Cnt_Ovf_inst 
     (
       .prmry_aclk      (S_AXI_ACLK             ),
       .prmry_rst_n     (S_AXI_ARESETN          ),
       .prmry_in        (1'b0                   ),
       .prmry_vect_in   (Metric_Cnt_Ovf_En      ),
       .scndry_aclk     (CORE_ACLK              ),
       .scndry_rst_n    (CORE_ARESETN           ),
       .prmry_ack       (                       ),
       .scndry_out      (                       ),
       .scndry_vect_out (Sync_Metric_Cnt_Ovf_En ) 
      );
    end
    else begin :GEN_Metric_Cnt_SYNC
      assign Sync_Metric_Cnt_Ovf_En = Metric_Cnt_Ovf_En; 
    end

    endgenerate

generate
if (C_ENABLE_EVENT_COUNT == 1) begin : GEN_METRIC_0

//-- Metric Selector for Counter 0 Register
always @(posedge S_AXI_ACLK) begin 
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       Metric_Sel_0_CDC <= 0;
   end
   else begin 
       if (Metric_Sel_Reg_0_Wr_En == 1'b1) begin
           Metric_Sel_0_CDC <= Bus2IP_Data[7:0];
       end
       else begin
           Metric_Sel_0_CDC <= Metric_Sel_0_CDC;
       end
   end
end 

assign Metric_Sel_0 = Metric_Sel_0_CDC;

//-- Range for Counter 0 Register
always @(posedge S_AXI_ACLK) begin 
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       Range_Reg_0_CDC <= 0;
   end
   else begin 
       if ((Rng_Reg_Set_Wr_En == 1'b1) && (Addr_7downto4_is_0x0 == 1'b1)) begin
           Range_Reg_0_CDC <= Bus2IP_Data[31:0];
       end
       else begin
           Range_Reg_0_CDC <= Range_Reg_0_CDC;
       end
   end
end 

assign Range_Reg_0 = Range_Reg_0_CDC;

end 
else begin : GEN_NO_METRIC_0  //-- else for generate
    assign Metric_Sel_0 = 0;
    assign Range_Reg_0  = 0;
end    
endgenerate


// Generate for counter0 cross probing logic    
generate
if (C_ENABLE_EVENT_COUNT == 1 && C_ENABLE_EVENT_LOG == 1) begin : GEN_CROSS_PROBE_0
//-- Metric Counter0 Cutt off to enable event log 
always @(posedge S_AXI_ACLK) begin 
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       Count0_Cut_Off_CDC <= 0;
   end
   else begin 
       if ((Enlog_Reg_Set_Wr_En == 1'b1) && (Addr_7downto4_is_0x0 == 1'b1)) begin
           Count0_Cut_Off_CDC <= Bus2IP_Data[31:0];
       end
       else begin
           Count0_Cut_Off_CDC <= Count0_Cut_Off_CDC;
       end
   end
end 

assign Count0_Cut_Off = Count0_Cut_Off_CDC;


//-- Enable event log if metric count0 is greater than Count0_Cut_Off
always @(posedge CORE_ACLK) begin 
   if (CORE_ARESETN == RST_ACTIVE) begin
      Count0_Event_Log_En_i <= 0;
   end
   else begin
       if (Sync_Metric_Cnt_Ovf_En[0] == 1'b0) begin
           Count0_Event_Log_En_i <= 1'b0; 
       end
       else if ((Metric_Cnt_0 >= Count0_Cut_Off_CDC[15:0]) && 
                (Metric_Cnt_0 <= Count0_Cut_Off_CDC[31:16])) begin
           Count0_Event_Log_En_i <= 1'b1;
       end
       else begin
           Count0_Event_Log_En_i <= 1'b0;
       end
   end
end 

assign Count0_Event_Log_En = Count0_Event_Log_En_i;
    
end 
else begin : GEN_NO_CROSS_PROBE_0  //-- else for generate
    assign Count0_Cut_Off = 0;
    assign Count0_Event_Log_En = 0;
end    
endgenerate

//-- generate block for metric counter 1
generate
if ((C_ENABLE_EVENT_COUNT == 1) && (C_NUM_OF_COUNTERS > 1)) begin : GEN_METRIC_1

    //-- Metric Selector for Counter 1 Register
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Metric_Sel_1_CDC <= 0;
       end
       else begin 
           if (Metric_Sel_Reg_0_Wr_En == 1'b1) begin
               Metric_Sel_1_CDC <= Bus2IP_Data[15:8];
           end
           else begin
               Metric_Sel_1_CDC <= Metric_Sel_1_CDC;
           end
       end
    end 

    assign Metric_Sel_1 = Metric_Sel_1_CDC;

    //-- Range for Counter 1 Register
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Range_Reg_1_CDC <= 0;
       end
       else begin 
           if ((Rng_Reg_Set_Wr_En == 1'b1) && (Addr_7downto4_is_0x1 == 1'b1)) begin
               Range_Reg_1_CDC <= Bus2IP_Data[31:0];
           end
           else begin
               Range_Reg_1_CDC <= Range_Reg_1_CDC;
           end
       end
    end 
    
    assign Range_Reg_1 = Range_Reg_1_CDC;

end 
else begin : GEN_NO_METRIC_1  //-- else for generate
    assign Metric_Sel_1 = 0;
    assign Range_Reg_1  = 0;
end    
endgenerate


generate
if (C_ENABLE_EVENT_COUNT == 1 && C_ENABLE_EVENT_LOG == 1  && C_NUM_OF_COUNTERS > 1) begin : GEN_CROSS_PROBE_1

    //-- Metric Counter1 Cutt off to enable event log 
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Count1_Cut_Off_CDC <= 0;
       end
       else begin 
           if ((Enlog_Reg_Set_Wr_En == 1'b1) && (Addr_7downto4_is_0x1 == 1'b1)) begin
               Count1_Cut_Off_CDC <= Bus2IP_Data[31:0];
           end
           else begin
               Count1_Cut_Off_CDC <= Count1_Cut_Off_CDC;
           end
       end
    end 

    assign Count1_Cut_Off = Count1_Cut_Off_CDC;

    //-- Enable event log if metric count1 is greater than Count1_Cut_Off
    always @(posedge CORE_ACLK) begin 
       if (CORE_ARESETN == RST_ACTIVE) begin
          Count1_Event_Log_En_i <= 0;
       end
       else begin 
           if (Sync_Metric_Cnt_Ovf_En[1] == 1'b0) begin
               Count1_Event_Log_En_i <= 1'b0;
           end
           else if ((Metric_Cnt_1 >= Count1_Cut_Off_CDC[15:0]) && 
                    (Metric_Cnt_1 <= Count1_Cut_Off_CDC[31:16])) begin
               Count1_Event_Log_En_i <= 1'b1;
           end
           else begin
               Count1_Event_Log_En_i <= 1'b0;
           end
       end
    end 
   
    assign Count1_Event_Log_En = Count1_Event_Log_En_i;

end 
else begin :GEN_NO_CROSS_PROBE_1  //-- else for generate
    assign Count1_Cut_Off = 0;
    assign Count1_Event_Log_En = 0;
end    
endgenerate

//-- generate block for metric counter_2
generate
if ((C_ENABLE_EVENT_COUNT == 1) && (C_NUM_OF_COUNTERS > 2)) begin : GEN_METRIC_2

    //-- Metric Selector for Counter_2 Register
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Metric_Sel_2_CDC <= 0;
       end
       else begin 
           if (Metric_Sel_Reg_0_Wr_En == 1'b1) begin
               Metric_Sel_2_CDC <= Bus2IP_Data[23:16];
           end
           else begin
               Metric_Sel_2_CDC <= Metric_Sel_2_CDC;
           end
       end
    end 

    assign Metric_Sel_2 = Metric_Sel_2_CDC;

    //-- Range for Counter_2 Register
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Range_Reg_2_CDC <= 0;
       end
       else begin 
           if ((Rng_Reg_Set_Wr_En == 1'b1) && (Addr_7downto4_is_0x2 == 1'b1)) begin
               Range_Reg_2_CDC <= Bus2IP_Data[31:0];
           end
           else begin
               Range_Reg_2_CDC <= Range_Reg_2_CDC;
           end
       end
    end 
    
    assign Range_Reg_2 = Range_Reg_2_CDC;

end 
else begin : GEN_NO_METRIC_2  //-- else for generate
    assign Metric_Sel_2 = 0;
    assign Range_Reg_2  = 0;
end    
endgenerate


generate
if (C_ENABLE_EVENT_COUNT == 1 && C_ENABLE_EVENT_LOG == 1  && C_NUM_OF_COUNTERS > 2) begin : GEN_CROSS_PROBE_2
 //-- Metric Counter2 Cutt off to enable event log 
   always @(posedge S_AXI_ACLK) begin 
      if (S_AXI_ARESETN == RST_ACTIVE) begin
          Count2_Cut_Off_CDC <= 0;
      end
      else begin 
          if ((Enlog_Reg_Set_Wr_En == 1'b1) && (Addr_7downto4_is_0x2 == 1'b1)) begin
              Count2_Cut_Off_CDC <= Bus2IP_Data[31:0];
          end
          else begin
              Count2_Cut_Off_CDC <= Count2_Cut_Off_CDC;
          end
      end
   end 

   assign Count2_Cut_Off = Count2_Cut_Off_CDC;

    //-- Enable event log if metric count2 is greater than Count2_Cut_Off
    always @(posedge CORE_ACLK) begin 
       if (CORE_ARESETN == RST_ACTIVE) begin
          Count2_Event_Log_En_i <= 0;
       end
       else begin 
           if (Sync_Metric_Cnt_Ovf_En[2] == 1'b0) begin
               Count2_Event_Log_En_i <= 1'b0;
           end
           else if ((Metric_Cnt_2 >= Count2_Cut_Off_CDC[15:0]) && 
                    (Metric_Cnt_2 <= Count2_Cut_Off_CDC[31:16])) begin
               Count2_Event_Log_En_i <= 1'b1;
           end
           else begin
               Count2_Event_Log_En_i <= 1'b0;
           end
       end
    end 
    assign Count2_Event_Log_En = Count2_Event_Log_En_i;
end 
else begin : GEN_NO_CROSS_PROBE_2  //-- else for generate
    assign Count2_Cut_Off = 0;
    assign Count2_Event_Log_En = 0;
end    
endgenerate


//-- generate block for metric counter 3
generate
if ((C_ENABLE_EVENT_COUNT == 1) && (C_NUM_OF_COUNTERS > 3)) begin : GEN_METRIC_3

    //-- Metric Selector for Counter 3 Register
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Metric_Sel_3_CDC <= 0;
       end
       else begin 
           if (Metric_Sel_Reg_0_Wr_En == 1'b1) begin
               Metric_Sel_3_CDC <= Bus2IP_Data[31:24];
           end
           else begin
               Metric_Sel_3_CDC <= Metric_Sel_3_CDC;
           end
       end
    end 

    assign Metric_Sel_3 = Metric_Sel_3_CDC;

    //-- Range for Counter_3 Register
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Range_Reg_3_CDC <= 0;
       end
       else begin 
           if ((Rng_Reg_Set_Wr_En == 1'b1) && (Addr_7downto4_is_0x3 == 1'b1)) begin
               Range_Reg_3_CDC <= Bus2IP_Data[31:0];
           end
           else begin
               Range_Reg_3_CDC <= Range_Reg_3_CDC;
           end
       end
    end 
    
    assign Range_Reg_3 = Range_Reg_3_CDC;

end 
else begin : GEN_NO_METRIC_3  //-- else for generate
    assign Metric_Sel_3 = 0;
    assign Range_Reg_3 = 0;
end    
endgenerate


generate
if (C_ENABLE_EVENT_COUNT == 1 && C_ENABLE_EVENT_LOG == 1  && C_NUM_OF_COUNTERS > 3) begin : GEN_CROSS_PROBE_3
    //-- Metric Counter3 Cutt off to enable event log 
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Count3_Cut_Off_CDC <= 0;
       end
       else begin 
           if ((Enlog_Reg_Set_Wr_En == 1'b1) && (Addr_7downto4_is_0x3 == 1'b1)) begin
               Count3_Cut_Off_CDC <= Bus2IP_Data[31:0];
           end
           else begin
               Count3_Cut_Off_CDC <= Count3_Cut_Off_CDC;
           end
       end
    end 

    assign Count3_Cut_Off = Count3_Cut_Off_CDC;

     //-- Enable event log if metric count3 is greater than Count3_Cut_Off
    always @(posedge CORE_ACLK) begin 
       if (CORE_ARESETN == RST_ACTIVE) begin
          Count3_Event_Log_En_i <= 0;
       end
       else begin 
           if (Sync_Metric_Cnt_Ovf_En[3] == 1'b0) begin
               Count3_Event_Log_En_i <= 1'b0;
           end 
           else if ((Metric_Cnt_3 >= Count3_Cut_Off_CDC[15:0]) && 
                    (Metric_Cnt_3 <= Count3_Cut_Off_CDC[31:16])) begin
               Count3_Event_Log_En_i <= 1'b1;
           end
           else begin
               Count3_Event_Log_En_i <= 1'b0;
           end
       end
    end 
   
    assign Count3_Event_Log_En = Count3_Event_Log_En_i;
end 
else begin : GEN_NO_CROSS_PROBE_3  //-- else for generate
    assign Count3_Cut_Off = 0;
    assign Count3_Event_Log_En = 0;
end    
endgenerate


//-- generate block for metric counter 4
generate
if ((C_ENABLE_EVENT_COUNT == 1) && (C_NUM_OF_COUNTERS > 4)) begin : GEN_METRIC_4

    //-- Metric Selector for Counter 4 Register
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Metric_Sel_4_CDC <= 0;
       end
       else begin 
           if (Metric_Sel_Reg_1_Wr_En == 1'b1) begin
               Metric_Sel_4_CDC <= Bus2IP_Data[7:0];
           end
           else begin
               Metric_Sel_4_CDC <= Metric_Sel_4_CDC;
           end
       end
    end 

    assign Metric_Sel_4 = Metric_Sel_4_CDC;

    //-- Range for Counter_4 Register
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Range_Reg_4_CDC <= 0;
       end
       else begin 
           if ((Rng_Reg_Set_Wr_En == 1'b1) && (Addr_7downto4_is_0x4 == 1'b1)) begin
               Range_Reg_4_CDC <= Bus2IP_Data[31:0];
           end
           else begin
               Range_Reg_4_CDC <= Range_Reg_4_CDC;
           end
       end
    end 
    
    assign Range_Reg_4 = Range_Reg_4_CDC;

end 
else begin : GEN_NO_METRIC_4  //-- else for generate
    assign Metric_Sel_4 = 0;
    assign Range_Reg_4 = 0;
end    
endgenerate


generate
if (C_ENABLE_EVENT_COUNT == 1 && C_ENABLE_EVENT_LOG == 1  && C_NUM_OF_COUNTERS > 4) begin : GEN_CROSS_PROBE_4
 //-- Metric Counter4 Cutt off to enable event log 
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Count4_Cut_Off_CDC <= 0;
       end
       else begin 
           if ((Enlog_Reg_Set_Wr_En == 1'b1) && (Addr_7downto4_is_0x4 == 1'b1)) begin
               Count4_Cut_Off_CDC <= Bus2IP_Data[31:0];
           end
           else begin
               Count4_Cut_Off_CDC <= Count4_Cut_Off_CDC;
           end
       end
    end 

    assign Count4_Cut_Off = Count4_Cut_Off_CDC;

    //-- Enable event log if metric count4 is greater than Count4_Cut_Off
    always @(posedge CORE_ACLK) begin 
       if (CORE_ARESETN == RST_ACTIVE) begin
          Count4_Event_Log_En_i <= 0;
       end
       else begin 
           if (Sync_Metric_Cnt_Ovf_En[4] == 1'b0) begin
               Count4_Event_Log_En_i <= 1'b0;
           end
           else if ((Metric_Cnt_4 >= Count4_Cut_Off_CDC[15:0]) &&
                    (Metric_Cnt_4 <= Count4_Cut_Off_CDC[31:16])) begin
               Count4_Event_Log_En_i <= 1'b1;
           end
           else begin
               Count4_Event_Log_En_i <= 1'b0;
           end
       end
    end 
   
    assign Count4_Event_Log_En = Count4_Event_Log_En_i;

end 
else begin : GEN_NO_CROSS_PROBE_4  //-- else for generate
    assign Count4_Cut_Off = 0; 
    assign Count4_Event_Log_En = 0;
end    
endgenerate


//-- generate block for metric counter 5
generate
if ((C_ENABLE_EVENT_COUNT == 1) && (C_NUM_OF_COUNTERS > 5)) begin : GEN_METRIC_5

    //-- Metric Selector for Counter 5 Register
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Metric_Sel_5_CDC <= 0;
       end
       else begin 
           if (Metric_Sel_Reg_1_Wr_En == 1'b1) begin
               Metric_Sel_5_CDC <= Bus2IP_Data[15:8];
           end
           else begin
               Metric_Sel_5_CDC <= Metric_Sel_5_CDC;
           end
       end
    end 

    assign Metric_Sel_5 = Metric_Sel_5_CDC;

    //-- Range for Counter_5 Register
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Range_Reg_5_CDC <= 0;
       end
       else begin 
           if ((Rng_Reg_Set_Wr_En == 1'b1) && (Addr_7downto4_is_0x5 == 1'b1)) begin
               Range_Reg_5_CDC <= Bus2IP_Data[31:0];
           end
           else begin
               Range_Reg_5_CDC <= Range_Reg_5_CDC;
           end
       end
    end 
    
    assign Range_Reg_5 = Range_Reg_5_CDC;

end 
else begin : GEN_NO_METRIC_5  //-- else for generate
    assign Metric_Sel_5 = 0;
    assign Range_Reg_5  = 0;
end    
endgenerate


generate
if (C_ENABLE_EVENT_COUNT == 1 && C_ENABLE_EVENT_LOG == 1  && C_NUM_OF_COUNTERS > 5) begin : GEN_CROSS_PROBE_5
    //-- Metric Counter5 Cutt off to enable event log 
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Count5_Cut_Off_CDC <= 0;
       end
       else begin 
           if ((Enlog_Reg_Set_Wr_En == 1'b1) && (Addr_7downto4_is_0x5 == 1'b1)) begin
               Count5_Cut_Off_CDC <= Bus2IP_Data[31:0];
           end
           else begin
               Count5_Cut_Off_CDC <= Count5_Cut_Off_CDC;
           end
       end
    end 

    assign Count5_Cut_Off = Count5_Cut_Off_CDC;

    //-- Enable event log if metric count5 is greater than Count5_Cut_Off
    always @(posedge CORE_ACLK) begin 
       if (CORE_ARESETN == RST_ACTIVE) begin
          Count5_Event_Log_En_i <= 0;
       end
       else begin
           if (Sync_Metric_Cnt_Ovf_En[5] == 1'b0) begin
               Count5_Event_Log_En_i <= 1'b0;
           end
           else if ((Metric_Cnt_5 >= Count5_Cut_Off_CDC[15:0]) &&
                    (Metric_Cnt_5 <= Count5_Cut_Off_CDC[31:16])) begin
               Count5_Event_Log_En_i <= 1'b1;
           end
           else begin
               Count5_Event_Log_En_i <= 1'b0;
           end
       end
    end 
   
    assign Count5_Event_Log_En = Count5_Event_Log_En_i;

end 
else begin : GEN_NO_CROSS_PROBE_5  //-- else for generate
    assign Count5_Cut_Off = 0;
    assign Count5_Event_Log_En = 0;
end    
endgenerate


//-- generate block for metric counter 6
generate
if ((C_ENABLE_EVENT_COUNT == 1) && (C_NUM_OF_COUNTERS > 6)) begin : GEN_METRIC_6

    //-- Metric Selector for Counter 6 Register
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Metric_Sel_6_CDC <= 0;
       end
       else begin 
           if (Metric_Sel_Reg_1_Wr_En == 1'b1) begin
               Metric_Sel_6_CDC <= Bus2IP_Data[23:16];
           end
           else begin
               Metric_Sel_6_CDC <= Metric_Sel_6_CDC;
           end
       end
    end 

    assign Metric_Sel_6 = Metric_Sel_6_CDC;

    //-- Range for Counter_6 Register
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Range_Reg_6_CDC <= 0;
       end
       else begin 
           if ((Rng_Reg_Set_Wr_En == 1'b1) && (Addr_7downto4_is_0x6 == 1'b1)) begin
               Range_Reg_6_CDC <= Bus2IP_Data[31:0];
           end
           else begin
               Range_Reg_6_CDC <= Range_Reg_6_CDC;
           end
       end
    end 
    
    assign Range_Reg_6 = Range_Reg_6_CDC;

    end 
else begin : GEN_NO_METRIC_6  //-- else for generate
    assign Metric_Sel_6 = 0;
    assign Range_Reg_6  = 0;
end    
endgenerate

generate
if (C_ENABLE_EVENT_COUNT == 1 && C_ENABLE_EVENT_LOG == 1  && C_NUM_OF_COUNTERS > 6) begin : GEN_CROSS_PROBE_6
    //-- Metric Counter6 Cutt off to enable event log 
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Count6_Cut_Off_CDC <= 0;
       end
       else begin 
           if ((Enlog_Reg_Set_Wr_En == 1'b1) && (Addr_7downto4_is_0x6 == 1'b1)) begin
               Count6_Cut_Off_CDC <= Bus2IP_Data[31:0];
           end
           else begin
               Count6_Cut_Off_CDC <= Count6_Cut_Off_CDC;
           end
       end
    end 

    assign Count6_Cut_Off = Count6_Cut_Off_CDC;

    //-- Enable event log if metric count6 is greater than Count6_Cut_Off
    always @(posedge CORE_ACLK) begin 
       if (CORE_ARESETN == RST_ACTIVE) begin
          Count6_Event_Log_En_i <= 0;
       end
       else begin 
           if (Sync_Metric_Cnt_Ovf_En[6] == 1'b0) begin
               Count6_Event_Log_En_i <= 1'b0;
           end
           else if ((Metric_Cnt_6 >= Count6_Cut_Off_CDC[15:0]) && 
                    (Metric_Cnt_6 <= Count6_Cut_Off_CDC[31:16])) begin
               Count6_Event_Log_En_i <= 1'b1;
           end
           else begin
               Count6_Event_Log_En_i <= 1'b0;
           end
       end
    end 
   
    assign Count6_Event_Log_En = Count6_Event_Log_En_i;

end 
else begin : GEN_NO_CROSS_PROBE_6  //-- else for generate
    assign Count6_Cut_Off = 0;
    assign Count6_Event_Log_En = 0;
end    
endgenerate

//-- generate block for metric counter 7
generate
if ((C_ENABLE_EVENT_COUNT == 1) && (C_NUM_OF_COUNTERS > 7)) begin : GEN_METRIC_7

    //-- Metric Selector for Counter 7 Register
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Metric_Sel_7_CDC <= 0;
       end
       else begin 
           if (Metric_Sel_Reg_1_Wr_En == 1'b1) begin
               Metric_Sel_7_CDC <= Bus2IP_Data[31:24];
           end
           else begin
               Metric_Sel_7_CDC <= Metric_Sel_7_CDC;
           end
       end
    end 

    assign Metric_Sel_7 = Metric_Sel_7_CDC;

    //-- Range for Counter_7 Register
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Range_Reg_7_CDC <= 0;
       end
       else begin 
           if ((Rng_Reg_Set_Wr_En == 1'b1) && (Addr_7downto4_is_0x7 == 1'b1)) begin
               Range_Reg_7_CDC <= Bus2IP_Data[31:0];
           end
           else begin
               Range_Reg_7_CDC <= Range_Reg_7_CDC;
           end
       end
    end 
    
    assign Range_Reg_7 = Range_Reg_7_CDC;
 
end 
else begin : GEN_NO_METRIC_7  //-- else for generate
    assign Metric_Sel_7 = 0;
    assign Range_Reg_7  = 0;
end    
endgenerate

generate
if (C_ENABLE_EVENT_COUNT == 1 && C_ENABLE_EVENT_LOG == 1  && C_NUM_OF_COUNTERS > 7) begin : GEN_CROSS_PROBE_7
       //-- Metric Counter7 Cutt off to enable event log 
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Count7_Cut_Off_CDC <= 0;
       end
       else begin 
           if ((Enlog_Reg_Set_Wr_En == 1'b1) && (Addr_7downto4_is_0x7 == 1'b1)) begin
               Count7_Cut_Off_CDC <= Bus2IP_Data[31:0];
           end
           else begin
               Count7_Cut_Off_CDC <= Count7_Cut_Off_CDC;
           end
       end
    end 

    assign Count7_Cut_Off = Count7_Cut_Off_CDC;

    //-- Enable event log if metric count7 is greater than Count7_Cut_Off
    always @(posedge CORE_ACLK) begin 
       if (CORE_ARESETN == RST_ACTIVE) begin
          Count7_Event_Log_En_i <= 0;
       end
       else begin 
           if (Sync_Metric_Cnt_Ovf_En[7] == 1'b0) begin
               Count7_Event_Log_En_i <= 1'b0;
           end
           else if ((Metric_Cnt_7 >= Count7_Cut_Off_CDC[15:0]) &&
                    (Metric_Cnt_7 <= Count7_Cut_Off_CDC[31:16])) begin
               Count7_Event_Log_En_i <= 1'b1;
           end
           else begin
               Count7_Event_Log_En_i <= 1'b0;
           end
       end
    end 
   
    assign Count7_Event_Log_En = Count7_Event_Log_En_i;

end 
else begin : GEN_NO_CROSS_PROBE_7  //-- else for generate
    assign Count7_Cut_Off = 0;
    assign Count7_Event_Log_En = 0;
end    
endgenerate

//-- generate block for metric counter 8
generate
if ((C_ENABLE_EVENT_COUNT == 1) && (C_NUM_OF_COUNTERS > 8)) begin : GEN_METRIC_8

    //-- Metric Selector for Counter 8 Register
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Metric_Sel_8_CDC <= 0;
       end
       else begin 
           if (Metric_Sel_Reg_2_Wr_En == 1'b1) begin
               Metric_Sel_8_CDC <= Bus2IP_Data[7:0];
           end
           else begin
               Metric_Sel_8_CDC <= Metric_Sel_8_CDC;
           end
       end
    end 

    assign Metric_Sel_8 = Metric_Sel_8_CDC;

    //-- Range for Counter_8 Register
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Range_Reg_8_CDC <= 0;
       end
       else begin 
           if ((Rng_Reg_Set_Wr_En == 1'b1) && (Addr_7downto4_is_0x8 == 1'b1)) begin
               Range_Reg_8_CDC <= Bus2IP_Data[31:0];
           end
           else begin
               Range_Reg_8_CDC <= Range_Reg_8_CDC;
           end
       end
    end 
    
    assign Range_Reg_8 = Range_Reg_8_CDC;
        
end 
else begin : GEN_NO_METRIC_8  //-- else for generate
    assign Metric_Sel_8 = 0;
    assign Range_Reg_8  = 0;
end    
endgenerate

generate
if (C_ENABLE_EVENT_COUNT == 1 && C_ENABLE_EVENT_LOG == 1  && C_NUM_OF_COUNTERS > 8) begin : GEN_CROSS_PROBE_8
     //-- Metric Counter8 Cutt off to enable event log 
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Count8_Cut_Off_CDC <= 0;
       end
       else begin 
           if ((Enlog_Reg_Set_Wr_En == 1'b1) && (Addr_7downto4_is_0x8 == 1'b1)) begin
               Count8_Cut_Off_CDC <= Bus2IP_Data[31:0];
           end
           else begin
               Count8_Cut_Off_CDC <= Count8_Cut_Off_CDC;
           end
       end
    end 

    assign Count8_Cut_Off = Count8_Cut_Off_CDC;

    //-- Enable event log if metric count8 is greater than Count8_Cut_Off
    always @(posedge CORE_ACLK) begin 
       if (CORE_ARESETN == RST_ACTIVE) begin
          Count8_Event_Log_En_i <= 0;
       end
       else begin 
           if (Sync_Metric_Cnt_Ovf_En[8] == 1'b0) begin
               Count8_Event_Log_En_i <= 1'b0;
           end
           else if ((Metric_Cnt_8 >= Count8_Cut_Off_CDC[15:0]) &&
                    (Metric_Cnt_8 <= Count8_Cut_Off_CDC[31:16])) begin
               Count8_Event_Log_En_i <= 1'b1;
           end
           else begin
               Count8_Event_Log_En_i <= 1'b0;
           end
       end
    end 
   
    assign Count8_Event_Log_En = Count8_Event_Log_En_i;
end 
else begin : GEN_NO_CROSS_PROBE_8  //-- else for generate
    assign Count8_Cut_Off = 0;
    assign Count8_Event_Log_En = 0;
end    
endgenerate

//-- generate block for metric counter 9
generate
if ((C_ENABLE_EVENT_COUNT == 1) && (C_NUM_OF_COUNTERS > 9)) begin : GEN_METRIC_9

    //-- Metric Selector for Counter 9 Register
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Metric_Sel_9_CDC <= 0;
       end
       else begin 
           if (Metric_Sel_Reg_2_Wr_En == 1'b1) begin
               Metric_Sel_9_CDC <= Bus2IP_Data[15:8];
           end
           else begin
               Metric_Sel_9_CDC <= Metric_Sel_9_CDC;
           end
       end
    end 

    assign Metric_Sel_9 = Metric_Sel_9_CDC;

    //-- Range for Counter_9 Register
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Range_Reg_9_CDC <= 0;
       end
       else begin 
           if ((Rng_Reg_Set_Wr_En == 1'b1) && (Addr_7downto4_is_0x9 == 1'b1)) begin
               Range_Reg_9_CDC <= Bus2IP_Data[31:0];
           end
           else begin
               Range_Reg_9_CDC <= Range_Reg_9_CDC;
           end
       end
    end 
    
    assign Range_Reg_9 = Range_Reg_9_CDC;

   end 
else begin : GEN_NO_METRIC_9  //-- else for generate
    assign Metric_Sel_9 = 0;
    assign Range_Reg_9  = 0;
end    
endgenerate

generate
if (C_ENABLE_EVENT_COUNT == 1 && C_ENABLE_EVENT_LOG == 1  && C_NUM_OF_COUNTERS > 9) begin : GEN_CROSS_PROBE_9
     //-- Metric Counter9 Cutt off to enable event log 
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Count9_Cut_Off_CDC <= 0;
       end
       else begin 
           if ((Enlog_Reg_Set_Wr_En == 1'b1) && (Addr_7downto4_is_0x9 == 1'b1)) begin
               Count9_Cut_Off_CDC <= Bus2IP_Data[31:0];
           end
           else begin
               Count9_Cut_Off_CDC <= Count9_Cut_Off_CDC;
           end
       end
    end 

    assign Count9_Cut_Off = Count9_Cut_Off_CDC;

    //-- Enable event log if metric count9 is greater than Count9_Cut_Off
    always @(posedge CORE_ACLK) begin 
       if (CORE_ARESETN == RST_ACTIVE) begin
          Count9_Event_Log_En_i <= 0;
       end
       else begin 
           if (Sync_Metric_Cnt_Ovf_En[9] == 1'b0) begin
               Count9_Event_Log_En_i <= 1'b0;
           end
           else if ((Metric_Cnt_9 >= Count9_Cut_Off_CDC[15:0]) &&
                    (Metric_Cnt_9 <= Count9_Cut_Off_CDC[31:16])) begin
               Count9_Event_Log_En_i <= 1'b1;
           end
           else begin
               Count9_Event_Log_En_i <= 1'b0;
           end
       end
    end 
   
    assign Count9_Event_Log_En = Count9_Event_Log_En_i;

end 
else begin : GEN_NO_CROSS_PROBE_9  //-- else for generate
    assign Count9_Cut_Off = 0;
    assign Count9_Event_Log_En = 0;
end    
endgenerate


generate
    if(C_ENABLE_EVENT_LOG == 1) begin :GEN_LOG_DATA_REG
     
       reg [6:0]                          Flag_Enable_Reg_CDC;    
       reg                                SW_Data_Log_En_CDC; 
       reg [2:0]                          Ext_Event_Flag_En_CDC;   
       reg                                Global_Clk_Cnt_Ovf_En_int;
       reg                                Sample_Metric_Cnt_Ovf_En_int;
       reg [9:0]                          Metric_Cnt_Ovf_En_int;
       reg [C_SW_SYNC_DATA_WIDTH-1:0]     SW_Data_reg_CDC; 
       reg                                SW_Data_Wr_En_reg; 
       //-- Flag Enable Register
       always @(posedge S_AXI_ACLK) begin 
          if (S_AXI_ARESETN == RST_ACTIVE) begin
              Flag_Enable_Reg_CDC          <= 0;
              SW_Data_Log_En_CDC           <= 1'b0;
              Ext_Event_Flag_En_CDC        <= 0;
              Global_Clk_Cnt_Ovf_En_int    <= 0;
              Sample_Metric_Cnt_Ovf_En_int <= 0;
              Metric_Cnt_Ovf_En_int        <= 0;
          end
          else begin
              if ((Event_Log_Set_Wr_En == 1'b1) && (Addr_3downto0_is_0x0 == 1'b1)) begin
                  Flag_Enable_Reg_CDC          <= Bus2IP_Data[6:0];
                  SW_Data_Log_En_CDC           <= Bus2IP_Data[16];
                  Ext_Event_Flag_En_CDC        <= Bus2IP_Data[19:17];
                  Global_Clk_Cnt_Ovf_En_int    <= Bus2IP_Data[20];
                  Sample_Metric_Cnt_Ovf_En_int <= Bus2IP_Data[21];
                  Metric_Cnt_Ovf_En_int        <= Bus2IP_Data[31:22];
              end
              else begin
                  Flag_Enable_Reg_CDC          <= Flag_Enable_Reg_CDC;
                  SW_Data_Log_En_CDC           <= SW_Data_Log_En_CDC;
                  Ext_Event_Flag_En_CDC        <= Ext_Event_Flag_En_CDC;
                  Global_Clk_Cnt_Ovf_En_int    <= Global_Clk_Cnt_Ovf_En_int ;
                  Sample_Metric_Cnt_Ovf_En_int <= Sample_Metric_Cnt_Ovf_En_int;
                  Metric_Cnt_Ovf_En_int        <= Metric_Cnt_Ovf_En_int;
              end
          end
       end 
       
       assign Flag_Enable_Reg          = Flag_Enable_Reg_CDC;
       assign SW_Data_Log_En           = SW_Data_Log_En_CDC;
       assign Ext_Event_Flag_En        = Ext_Event_Flag_En_CDC;
       assign Global_Clk_Cnt_Ovf_En    = Global_Clk_Cnt_Ovf_En_int;
       assign Sample_Metric_Cnt_Ovf_En = Sample_Metric_Cnt_Ovf_En_int;
       assign Metric_Cnt_Ovf_En        = Metric_Cnt_Ovf_En_int;

      
       //-- Software-written Data Register
       always @(posedge S_AXI_ACLK) begin 
          if (S_AXI_ARESETN == RST_ACTIVE) begin
              SW_Data_reg_CDC       <= 0;
              SW_Data_Wr_En_reg     <= 1'b0;
          end
          else begin
              if ((Event_Log_Set_Wr_En == 1'b1) && (Addr_3downto0_is_0x4 == 1'b1)) begin
                  SW_Data_reg_CDC       <= Bus2IP_Data[C_SW_SYNC_DATA_WIDTH-1:0];
                  SW_Data_Wr_En_reg     <= 1'b1;
              end
              else begin
                  SW_Data_reg_CDC       <= SW_Data_reg_CDC;
                  SW_Data_Wr_En_reg     <= 1'b0;
              end
          end
       end 
       assign SW_Data = SW_Data_reg_CDC;
       assign SW_Data_Wr_En_int = SW_Data_Wr_En_reg;
    end
    else begin :GEN_NO_LOG_DATA_REG
      assign SW_Data                 = 0;
      assign SW_Data_Wr_En_int       = 0;
      assign Flag_Enable_Reg         = 0; 
      assign SW_Data_Log_En          = 0;
      assign Ext_Event_Flag_En       = 0;
      assign Global_Clk_Cnt_Ovf_En   = 0;
      assign Sample_Metric_Cnt_Ovf_En= 0;
      assign Metric_Cnt_Ovf_En       = 0;
    end

endgenerate

      

 // Synchronizing SW_Data write enable signal 
 //--Double Flop synchronization
 generate
    if(C_AXI4LITE_CORE_CLK_ASYNC == 1 && C_ENABLE_EVENT_LOG == 1) begin :GEN_SW_DATA_ASYNC

    axi_perf_mon_v5_0_12_cdc_sync
    #(
       .c_cdc_type      (1             ),   
       .c_flop_input    (0             ),  
       .c_reset_state   (1             ),  
       .c_single_bit    (1             ),  
       .c_vector_width  (1             ),  
       .c_mtbf_stages   (4             )  
     ) sw_data_wr_en_inst 
     (
       .prmry_aclk      (S_AXI_ACLK        ),
       .prmry_rst_n     (S_AXI_ARESETN     ),
       .prmry_in        (SW_Data_Wr_En_int ),
       .prmry_vect_in   (1'b0              ),
       .scndry_aclk     (CORE_ACLK         ),
       .scndry_rst_n    (CORE_ARESETN      ),
       .prmry_ack       (                  ),
       .scndry_out      (SW_Data_Wr_En     ),
       .scndry_vect_out (                  ) 
      );
    end
    else begin :GEN_SW_DATA_SYNC
      assign  SW_Data_Wr_En = SW_Data_Wr_En_int; 
    end

   endgenerate



//-- Address Latched on RdEn
always @(posedge S_AXI_ACLK) begin 
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       Lat_Addr_7downto4_is_0x0          <= 1'b0;
       Lat_Addr_7downto4_is_0x1          <= 1'b0;
       Lat_Addr_7downto4_is_0x2          <= 1'b0;
       Lat_Addr_7downto4_is_0x3          <= 1'b0;
       Lat_Addr_7downto4_is_0x4          <= 1'b0;
       Lat_Addr_7downto4_is_0x5          <= 1'b0;
       Lat_Addr_7downto4_is_0x6          <= 1'b0;
       Lat_Addr_7downto4_is_0x7          <= 1'b0;
       Lat_Addr_7downto4_is_0x8          <= 1'b0;
       Lat_Addr_7downto4_is_0x9          <= 1'b0;

       Lat_Addr_3downto0_is_0x0          <= 1'b0;
       Lat_Addr_3downto0_is_0x4          <= 1'b0;
       Lat_Addr_3downto0_is_0x8          <= 1'b0;
       Lat_Addr_3downto0_is_0xC          <= 1'b0;
       Lat_Control_Set_Rd_En             <= 1'b0;
       Lat_Sample_Interval_Rd_En         <= 1'b0;
       Lat_Sample_Reg_Rd_En              <= 1'b0;
       Lat_Global_Clk_Cnt_Set_Rd_En      <= 1'b0;
       Lat_Global_Clk_Cnt_LSB_Rd_En      <= 1'b0;
       Lat_Global_Clk_Cnt_MSB_Rd_En      <= 1'b0;
       Lat_Intr_Reg_Set_Rd_En            <= 1'b0; 
       Lat_Intr_Reg_GIE_Rd_En            <= 1'b0; 
       Lat_Intr_Reg_IER_Rd_En            <= 1'b0; 
       Lat_Intr_Reg_ISR_Rd_En            <= 1'b0; 
       Lat_Sel_Reg_Set_Rd_En             <= 1'b0; 
       Lat_Metric_Sel_Reg_0_Rd_En        <= 1'b0; 
       Lat_Metric_Sel_Reg_1_Rd_En        <= 1'b0; 
       Lat_Metric_Sel_Reg_2_Rd_En        <= 1'b0; 
       Lat_Status_Reg_Set_Rd_En          <= 1'b0; 
       Lat_Status_Reg_FOC_Rd_En          <= 1'b0; 
       Lat_Status_Reg_WIF_Rd_En          <= 1'b0; 
       Lat_Rng_Reg_Set_Rd_En             <= 1'b0; 
       Lat_Metric_Cnt_Reg_Set_Rd_En      <= 1'b0; 
       Lat_Incr_Reg_Set_Rd_En            <= 1'b0; 
       Lat_Samp_Metric_Cnt_Reg_Set_Rd_En <= 1'b0; 
       Lat_Samp_Incr_Reg_Set_Rd_En       <= 1'b0; 
       Lat_Event_Log_Set_Rd_En           <= 1'b0; 
       Lat_Enlog_Reg_Set_Rd_En           <= 1'b0;
       Lat_Addr_9downto2_CDC             <= 0;
       Lat_Latency_ID_Rd_En              <= 1'b0;
       Lat_ID_Mask_Rd_En                 <= 1'b0;
   end
   else begin
       if ((Bus2IP_RdCE == 1'b1)) begin
           Lat_Addr_7downto4_is_0x0          <= Addr_7downto4_is_0x0;
           Lat_Addr_7downto4_is_0x1          <= Addr_7downto4_is_0x1;
           Lat_Addr_7downto4_is_0x2          <= Addr_7downto4_is_0x2;
           Lat_Addr_7downto4_is_0x3          <= Addr_7downto4_is_0x3;
           Lat_Addr_7downto4_is_0x4          <= Addr_7downto4_is_0x4;
           Lat_Addr_7downto4_is_0x5          <= Addr_7downto4_is_0x5;
           Lat_Addr_7downto4_is_0x6          <= Addr_7downto4_is_0x6;
           Lat_Addr_7downto4_is_0x7          <= Addr_7downto4_is_0x7;
           Lat_Addr_7downto4_is_0x8          <= Addr_7downto4_is_0x8;
           Lat_Addr_7downto4_is_0x9          <= Addr_7downto4_is_0x9;
 
           Lat_Addr_3downto0_is_0x0          <= Addr_3downto0_is_0x0;
           Lat_Addr_3downto0_is_0x4          <= Addr_3downto0_is_0x4;
           Lat_Addr_3downto0_is_0x8          <= Addr_3downto0_is_0x8;
           Lat_Addr_3downto0_is_0xC          <= Addr_3downto0_is_0xC;

           Lat_Control_Set_Rd_En             <= Control_Set_Rd_En;
           Lat_Sample_Interval_Rd_En         <= Sample_Interval_Rd_En;
           Lat_Sample_Reg_Rd_En              <= Sample_Reg_Rd_En;
           Lat_Global_Clk_Cnt_Set_Rd_En      <= Global_Clk_Cnt_Set_Rd_En;
           Lat_Global_Clk_Cnt_LSB_Rd_En      <= Global_Clk_Cnt_LSB_Rd_En;
           Lat_Global_Clk_Cnt_MSB_Rd_En      <= Global_Clk_Cnt_MSB_Rd_En;
           Lat_Intr_Reg_Set_Rd_En            <= Intr_Reg_Set_Rd_En; 
           Lat_Intr_Reg_GIE_Rd_En            <= Intr_Reg_GIE_Rd_En; 
           Lat_Intr_Reg_IER_Rd_En            <= Intr_Reg_IER_Rd_En; 
           Lat_Intr_Reg_ISR_Rd_En            <= Intr_Reg_ISR_Rd_En; 
           Lat_Sel_Reg_Set_Rd_En             <= Sel_Reg_Set_Rd_En     ; 
           Lat_Metric_Sel_Reg_0_Rd_En        <= Metric_Sel_Reg_0_Rd_En; 
           Lat_Metric_Sel_Reg_1_Rd_En        <= Metric_Sel_Reg_1_Rd_En; 
           Lat_Metric_Sel_Reg_2_Rd_En        <= Metric_Sel_Reg_2_Rd_En; 
           Lat_Status_Reg_Set_Rd_En          <= Status_Reg_Set_Rd_En  ; 
           Lat_Status_Reg_FOC_Rd_En          <= Status_Reg_FOC_Rd_En  ; 
           Lat_Status_Reg_WIF_Rd_En          <= Status_Reg_WIF_Rd_En  ; 
           Lat_Rng_Reg_Set_Rd_En             <= Rng_Reg_Set_Rd_En; 
           Lat_Metric_Cnt_Reg_Set_Rd_En      <= Metric_Cnt_Reg_Set_Rd_En; 
           Lat_Incr_Reg_Set_Rd_En            <= Incr_Reg_Set_Rd_En; 
           Lat_Samp_Metric_Cnt_Reg_Set_Rd_En <= Samp_Metric_Cnt_Reg_Set_Rd_En; 
           Lat_Samp_Incr_Reg_Set_Rd_En       <= Samp_Incr_Reg_Set_Rd_En; 
           Lat_Event_Log_Set_Rd_En           <= Event_Log_Set_Rd_En; 
           Lat_Enlog_Reg_Set_Rd_En           <= Enlog_Reg_Set_Rd_En;
           Lat_Addr_9downto2_CDC             <= Bus2IP_Addr[9:2];
           Lat_Latency_ID_Rd_En              <= Latency_ID_Rd_En;
           Lat_ID_Mask_Rd_En                 <= ID_Mask_Rd_En;
       end
       else begin
           Lat_Addr_7downto4_is_0x0          <= Lat_Addr_7downto4_is_0x0;
           Lat_Addr_7downto4_is_0x1          <= Lat_Addr_7downto4_is_0x1;
           Lat_Addr_7downto4_is_0x2          <= Lat_Addr_7downto4_is_0x2;
           Lat_Addr_7downto4_is_0x3          <= Lat_Addr_7downto4_is_0x3;
           Lat_Addr_7downto4_is_0x4          <= Lat_Addr_7downto4_is_0x4;
           Lat_Addr_7downto4_is_0x5          <= Lat_Addr_7downto4_is_0x5;
           Lat_Addr_7downto4_is_0x6          <= Lat_Addr_7downto4_is_0x6;
           Lat_Addr_7downto4_is_0x7          <= Lat_Addr_7downto4_is_0x7;
           Lat_Addr_7downto4_is_0x8          <= Lat_Addr_7downto4_is_0x8;
           Lat_Addr_7downto4_is_0x9          <= Lat_Addr_7downto4_is_0x9;
 
           Lat_Addr_3downto0_is_0x0          <= Lat_Addr_3downto0_is_0x0;
           Lat_Addr_3downto0_is_0x4          <= Lat_Addr_3downto0_is_0x4;
           Lat_Addr_3downto0_is_0x8          <= Lat_Addr_3downto0_is_0x8;
           Lat_Addr_3downto0_is_0xC          <= Lat_Addr_3downto0_is_0xC;

           Lat_Control_Set_Rd_En             <= Lat_Control_Set_Rd_En;
           Lat_Sample_Interval_Rd_En         <= Lat_Sample_Interval_Rd_En;
           Lat_Sample_Reg_Rd_En              <= Lat_Sample_Reg_Rd_En;
           Lat_Global_Clk_Cnt_Set_Rd_En      <= Lat_Global_Clk_Cnt_Set_Rd_En;
           Lat_Global_Clk_Cnt_LSB_Rd_En      <= Lat_Global_Clk_Cnt_LSB_Rd_En;
           Lat_Global_Clk_Cnt_MSB_Rd_En      <= Lat_Global_Clk_Cnt_MSB_Rd_En;
           Lat_Intr_Reg_Set_Rd_En            <= Lat_Intr_Reg_Set_Rd_En; 
           Lat_Intr_Reg_GIE_Rd_En            <= Lat_Intr_Reg_GIE_Rd_En; 
           Lat_Intr_Reg_IER_Rd_En            <= Lat_Intr_Reg_IER_Rd_En; 
           Lat_Intr_Reg_ISR_Rd_En            <= Lat_Intr_Reg_ISR_Rd_En; 
           Lat_Sel_Reg_Set_Rd_En             <= Lat_Sel_Reg_Set_Rd_En     ; 
           Lat_Metric_Sel_Reg_0_Rd_En        <= Lat_Metric_Sel_Reg_0_Rd_En; 
           Lat_Metric_Sel_Reg_1_Rd_En        <= Lat_Metric_Sel_Reg_1_Rd_En; 
           Lat_Metric_Sel_Reg_2_Rd_En        <= Lat_Metric_Sel_Reg_2_Rd_En; 
           Lat_Status_Reg_Set_Rd_En          <= Lat_Status_Reg_Set_Rd_En ; 
           Lat_Status_Reg_FOC_Rd_En          <= Lat_Status_Reg_FOC_Rd_En ; 
           Lat_Status_Reg_WIF_Rd_En          <= Lat_Status_Reg_WIF_Rd_En ; 
           Lat_Rng_Reg_Set_Rd_En             <= Lat_Rng_Reg_Set_Rd_En; 
           Lat_Metric_Cnt_Reg_Set_Rd_En      <= Lat_Metric_Cnt_Reg_Set_Rd_En; 
           Lat_Incr_Reg_Set_Rd_En            <= Lat_Incr_Reg_Set_Rd_En; 
           Lat_Samp_Metric_Cnt_Reg_Set_Rd_En <= Lat_Samp_Metric_Cnt_Reg_Set_Rd_En; 
           Lat_Samp_Incr_Reg_Set_Rd_En       <= Lat_Samp_Incr_Reg_Set_Rd_En; 
           Lat_Event_Log_Set_Rd_En           <= Lat_Event_Log_Set_Rd_En; 
           Lat_Enlog_Reg_Set_Rd_En           <= Lat_Enlog_Reg_Set_Rd_En;
           Lat_Addr_9downto2_CDC             <= Lat_Addr_9downto2_CDC;
           Lat_Latency_ID_Rd_En              <= Lat_Latency_ID_Rd_En;
           Lat_ID_Mask_Rd_En                 <= Lat_ID_Mask_Rd_En;
       end
   end
end 


//-- synchronizing RdEn to core clk domain
//-- Pulse synchronization
    axi_perf_mon_v5_0_12_cdc_sync
    #(
       .c_cdc_type      (0    ),   
       .c_flop_input    (0    ),  
       .c_reset_state   (1    ),  
       .c_single_bit    (1    ),  
       .c_vector_width  (1    ),  
       .c_mtbf_stages   (4    )  
     )cdc_sync_inst1 
     (
       .prmry_aclk      (S_AXI_ACLK       ),
       .prmry_rst_n     (S_AXI_ARESETN    ),
       .prmry_in        (Bus2IP_RdCE      ),
       .prmry_vect_in   (1'b0             ),
       .scndry_aclk     (CORE_ACLK        ),
       .scndry_rst_n    (CORE_ARESETN     ),
       .prmry_ack       (                 ),
       .scndry_out      (Rd_En_sync       ),
       .scndry_vect_out (                 ) 
      );

//-- synchronizing Rd_En_sync to AXI clk domain
//-- Pulse synchronization
     axi_perf_mon_v5_0_12_cdc_sync
    #(
       .c_cdc_type      (0    ),   
       .c_flop_input    (0    ),  
       .c_reset_state   (1    ),  
       .c_single_bit    (1    ),  
       .c_vector_width  (1    ),  
       .c_mtbf_stages   (4    )  
     )cdc_sync_inst2 
     (
       .prmry_aclk      (CORE_ACLK          ),
       .prmry_rst_n     (CORE_ARESETN       ),
       .prmry_in        (Rd_En_sync         ),
       .prmry_vect_in   (1'b0               ),
       .scndry_aclk     (S_AXI_ACLK         ),
       .scndry_rst_n    (S_AXI_ARESETN      ),
       .prmry_ack       (                   ),
       .scndry_out      (RValid             ),
       .scndry_vect_out (                   ) 
      );

//-- Data Valid generation 
always @(posedge S_AXI_ACLK) begin
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       IP2Bus_DataValid <= 1'b0;
   end
   else begin
       IP2Bus_DataValid <= RValid;
   end  
end


//-- Register Read Logic
always @(posedge S_AXI_ACLK) begin
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       IP2Bus_Data <= 0;
   end
   else begin
       if (RValid == 1'b1) begin
           if (Lat_Global_Clk_Cnt_Set_Rd_En == 1'b1) begin
               if (Lat_Global_Clk_Cnt_MSB_Rd_En == 1'b1) begin
                   IP2Bus_Data <= Lat_Global_Clk_Cnt_MSB;
               end
               else if (Lat_Global_Clk_Cnt_LSB_Rd_En == 1'b1) begin
                   IP2Bus_Data <= Lat_Global_Clk_Cnt_LSB_CDCR;
               end
               else begin
                   IP2Bus_Data <= 0;
               end
           end
           else if (Lat_Sample_Interval_Rd_En == 1'b1) begin
               if (Lat_Addr_3downto0_is_0x4 == 1'b1) begin
                   IP2Bus_Data      <= Sample_Interval_i[31:0];   
               end
               else if (Lat_Addr_3downto0_is_0x8 == 1'b1) begin
                   IP2Bus_Data      <= {{23{1'b0}},Reset_On_Sample_Int_Lapse,{6{1'b0}},
                                        Interval_Cnt_Ld, Interval_Cnt_En};   
               end
               else if(Lat_Addr_3downto0_is_0xC == 1'b1) begin
                   IP2Bus_Data      <= Sample_Time_Diff_Reg; 
               end
               else begin
                   IP2Bus_Data      <= 0;
               end
           end
           else if (Lat_Sel_Reg_Set_Rd_En == 1'b1) begin
               if (Lat_Metric_Sel_Reg_0_Rd_En == 1'b1) begin
                   IP2Bus_Data      <= { Metric_Sel_3, Metric_Sel_2, Metric_Sel_1, Metric_Sel_0};   
               end
               else if (Lat_Metric_Sel_Reg_1_Rd_En == 1'b1) begin
                   IP2Bus_Data      <= { Metric_Sel_7, Metric_Sel_6, Metric_Sel_5, Metric_Sel_4};   
               end
               else if (Lat_Metric_Sel_Reg_2_Rd_En == 1'b1) begin
                   IP2Bus_Data      <= {{16{1'b0}}, Metric_Sel_9, Metric_Sel_8};   
               end
               else begin
                   IP2Bus_Data      <= 0;
               end
           end
           else if (Lat_Status_Reg_Set_Rd_En == 1'b1) begin
               if (Lat_Status_Reg_FOC_Rd_En == 1'b1) begin
                   IP2Bus_Data      <= sync_eventlog_cur_cnt;
               end
               else if (Lat_Status_Reg_WIF_Rd_En == 1'b1) begin
                   IP2Bus_Data      <= (C_AXIS_DWIDTH_ROUND_TO_32/32);
               end
               else begin
                   IP2Bus_Data      <= 0;
               end
           end
           else if (Lat_Control_Set_Rd_En == 1'b1) begin
               IP2Bus_Data      <= Control_Reg;   
           end
           else if (Lat_Latency_ID_Rd_En == 1'b1) begin
               IP2Bus_Data      <= {Latency_RID_CDC,Latency_WID_CDC};   
           end
           else if (Lat_ID_Mask_Rd_En == 1'b1) begin
               IP2Bus_Data      <= {RID_Mask_CDC,WID_Mask_CDC};   
           end
           else if (Lat_Intr_Reg_Set_Rd_En == 1'b1) begin
               if (Lat_Intr_Reg_GIE_Rd_En == 1'b1) begin
                   IP2Bus_Data  <= { {31{1'b0}}, Global_Intr_En};   
               end
               else if (Lat_Intr_Reg_IER_Rd_En == 1'b1) begin
                   IP2Bus_Data  <= { {(32-C_NUM_INTR_INPUTS){1'b0}}, Intr_Reg_IER_Int};   
               end
               else if (Lat_Intr_Reg_ISR_Rd_En == 1'b1) begin
                   IP2Bus_Data  <= { {(32-C_NUM_INTR_INPUTS){1'b0}}, Intr_Reg_ISR};   
               end
               else begin
                   IP2Bus_Data  <= 0;
               end
           end
           else if (Lat_Rng_Reg_Set_Rd_En == 1'b1) begin
               if (Lat_Addr_7downto4_is_0x0 == 1'b1) begin
                   IP2Bus_Data  <= Range_Reg_0;   
               end
               else if (Lat_Addr_7downto4_is_0x1 == 1'b1) begin
                   IP2Bus_Data  <= Range_Reg_1;   
               end
               else if (Lat_Addr_7downto4_is_0x2 == 1'b1) begin
                   IP2Bus_Data   <= Range_Reg_2;   
               end
               else if (Lat_Addr_7downto4_is_0x3 == 1'b1) begin
                   IP2Bus_Data   <= Range_Reg_3;   
               end
               else if (Lat_Addr_7downto4_is_0x4 == 1'b1) begin
                   IP2Bus_Data   <= Range_Reg_4;   
               end
               else if (Lat_Addr_7downto4_is_0x5 == 1'b1) begin
                   IP2Bus_Data    <= Range_Reg_5;   
               end
               else if (Lat_Addr_7downto4_is_0x6 == 1'b1) begin
                   IP2Bus_Data    <= Range_Reg_6;   
               end
               else if (Lat_Addr_7downto4_is_0x7 == 1'b1) begin
                   IP2Bus_Data    <= Range_Reg_7;   
               end
               else if (Lat_Addr_7downto4_is_0x8 == 1'b1) begin
                   IP2Bus_Data    <= Range_Reg_8;   
               end
               else if (Lat_Addr_7downto4_is_0x9 == 1'b1) begin
                   IP2Bus_Data    <= Range_Reg_9;   
               end
               else begin
                   IP2Bus_Data     <= 0;
               end
           end
           else if(Lat_Enlog_Reg_Set_Rd_En == 1'b1) begin
               if (Lat_Addr_7downto4_is_0x0 == 1'b1) begin
                   IP2Bus_Data     <= Count0_Cut_Off;   
               end
               else if (Lat_Addr_7downto4_is_0x1 == 1'b1) begin
                   IP2Bus_Data     <= Count1_Cut_Off;   
               end
               else if (Lat_Addr_7downto4_is_0x2 == 1'b1) begin
                   IP2Bus_Data     <= Count2_Cut_Off;   
               end
               else if (Lat_Addr_7downto4_is_0x3 == 1'b1) begin
                   IP2Bus_Data     <= Count3_Cut_Off;   
               end
               else if (Lat_Addr_7downto4_is_0x4 == 1'b1) begin
                   IP2Bus_Data     <= Count4_Cut_Off;   
               end
               else if (Lat_Addr_7downto4_is_0x5 == 1'b1) begin
                   IP2Bus_Data     <= Count5_Cut_Off;   
               end
               else if (Lat_Addr_7downto4_is_0x6 == 1'b1) begin
                   IP2Bus_Data     <= Count6_Cut_Off;   
               end
               else if (Lat_Addr_7downto4_is_0x7 == 1'b1) begin
                   IP2Bus_Data     <= Count7_Cut_Off;   
               end
               else if (Lat_Addr_7downto4_is_0x8 == 1'b1) begin
                   IP2Bus_Data     <= Count8_Cut_Off;   
               end
               else if (Lat_Addr_7downto4_is_0x9 == 1'b1) begin
                   IP2Bus_Data     <= Count9_Cut_Off;   
               end
               else begin
                   IP2Bus_Data     <= 0;
               end
           end
           else if (Lat_Event_Log_Set_Rd_En == 1'b1) begin
               if (Lat_Addr_3downto0_is_0x0 == 1'b1) begin
                   IP2Bus_Data     <= {Metric_Cnt_Ovf_En,Sample_Metric_Cnt_Ovf_En,Global_Clk_Cnt_Ovf_En
                                     ,Ext_Event_Flag_En, SW_Data_Log_En, {9{1'b0}}, Flag_Enable_Reg};   
               end
               else if (Lat_Addr_3downto0_is_0x4 == 1'b1) begin
                   IP2Bus_Data     <= SW_Data;   
               end
               else begin
                   IP2Bus_Data     <= 0;
               end
           end
           else if (Lat_Metric_Cnt_Reg_Set_Rd_En == 1'b1 || Lat_Incr_Reg_Set_Rd_En == 1'b1
                    || Lat_Samp_Metric_Cnt_Reg_Set_Rd_En == 1'b1 || Lat_Samp_Incr_Reg_Set_Rd_En == 1'b1) begin
               IP2Bus_Data  <= Metric_ram_Out;
           end    
           else begin
               IP2Bus_Data <= 0;
           end
       end
       else begin
           IP2Bus_Data <= 0;
       end
   end  
end

generate
if (C_ENABLE_EVENT_COUNT == 1) begin : GEN_METRIC_RAM

//----------------------------------------------------------------------------------
// Loading Metric counts in RAM memory
//----------------------------------------------------------------------------------
reg [31:0] metric_ram_data_in;
reg [31:0] Metric_ram_Out_Reg_CDCR;

always @(*) begin 
      case (Lat_Addr_9downto2_CDC)
        8'h40: metric_ram_data_in<= Metric_Cnt_0;
        8'h41: metric_ram_data_in<= Incrementer_0;
        8'h44: metric_ram_data_in<= Metric_Cnt_1;
        8'h45: metric_ram_data_in<= Incrementer_1;
        8'h48: metric_ram_data_in<= Metric_Cnt_2;
        8'h49: metric_ram_data_in<= Incrementer_2;
        8'h4C: metric_ram_data_in<= Metric_Cnt_3;
        8'h4D: metric_ram_data_in<= Incrementer_3;
        8'h50: metric_ram_data_in<= Metric_Cnt_4;
        8'h51: metric_ram_data_in<= Incrementer_4;
        8'h54: metric_ram_data_in <= Metric_Cnt_5;
        8'h55: metric_ram_data_in <= Incrementer_5;
        8'h58: metric_ram_data_in <= Metric_Cnt_6;
        8'h59: metric_ram_data_in <= Incrementer_6;
        8'h5C: metric_ram_data_in <= Metric_Cnt_7;
        8'h5D: metric_ram_data_in <= Incrementer_7;
        8'h60: metric_ram_data_in <= Metric_Cnt_8;
        8'h61: metric_ram_data_in <= Incrementer_8;
        8'h64: metric_ram_data_in <= Metric_Cnt_9;
        8'h65: metric_ram_data_in <= Incrementer_9;
        8'h80: metric_ram_data_in <= Samp_Metric_Cnt_0;
        8'h81: metric_ram_data_in <= Samp_Incrementer_0;
        8'h84: metric_ram_data_in <= Samp_Metric_Cnt_1;
        8'h85: metric_ram_data_in <= Samp_Incrementer_1;
        8'h88: metric_ram_data_in <= Samp_Metric_Cnt_2;
        8'h89: metric_ram_data_in <= Samp_Incrementer_2;
        8'h8C: metric_ram_data_in <= Samp_Metric_Cnt_3;
        8'h8D: metric_ram_data_in <= Samp_Incrementer_3;
        8'h90: metric_ram_data_in <= Samp_Metric_Cnt_4;
        8'h91: metric_ram_data_in <= Samp_Incrementer_4;
        8'h94: metric_ram_data_in <= Samp_Metric_Cnt_5;
        8'h95: metric_ram_data_in <= Samp_Incrementer_5;
        8'h98: metric_ram_data_in <= Samp_Metric_Cnt_6;
        8'h99: metric_ram_data_in <= Samp_Incrementer_6;
        8'h9C: metric_ram_data_in <= Samp_Metric_Cnt_7;
        8'h9D: metric_ram_data_in <= Samp_Incrementer_7;
        8'hA0: metric_ram_data_in <= Samp_Metric_Cnt_8;
        8'hA1: metric_ram_data_in <= Samp_Incrementer_8;
        8'hA4: metric_ram_data_in <= Samp_Metric_Cnt_9;
        8'hA5: metric_ram_data_in <= Samp_Incrementer_9;
        default:metric_ram_data_in <= 0; 
      endcase
end 


always @(posedge CORE_ACLK) begin 
    if(Rd_En_sync == 1'b1) begin
        Metric_ram_CDCR[Lat_Addr_9downto2_CDC] <= metric_ram_data_in;
    end
    Metric_ram_Out_Reg_CDCR <= Metric_ram_CDCR[Lat_Addr_9downto2_CDC];
end 
    assign Metric_ram_Out = Metric_ram_Out_Reg_CDCR;
end 
else begin : GEN_NO_METRICRAM  
   assign Metric_ram_Out = 0; 
end    
endgenerate


//-- Enable event log if any metric count is greater than Cut_Off count
always @(posedge CORE_ACLK) begin 
   if (CORE_ARESETN == RST_ACTIVE) begin
      Count_Event_Log_En <= 0;
   end
   else begin 
      Count_Event_Log_En  <= Count0_Event_Log_En | Count1_Event_Log_En | Count2_Event_Log_En 
                      | Count3_Event_Log_En | Count4_Event_Log_En | Count5_Event_Log_En
                      | Count6_Event_Log_En | Count7_Event_Log_En | Count8_Event_Log_En
                      | Count9_Event_Log_En ;
   end
end 

//PR#741428
//Synchronize event log read data count to register
// interface clock

    axi_perf_mon_v5_0_12_cdc_sync
    #(
       .c_cdc_type      (1             ),   
       .c_flop_input    (0             ),  
       .c_reset_state   (1             ),  
       .c_single_bit    (0             ),  
       .c_vector_width  (32            ),  
       .c_mtbf_stages   (4             )  
     ) eventlog_fifo_rden 
     (
       .prmry_aclk      (eventlog_rd_clk       ),
       .prmry_rst_n     (eventlog_rd_rstn      ),
       .prmry_in        (1'b0                  ),
       .prmry_vect_in   (eventlog_cur_cnt      ),
       .scndry_aclk     (S_AXI_ACLK            ),
       .scndry_rst_n    (S_AXI_ARESETN         ),
       .prmry_ack       (                      ),
       .scndry_out      (                      ),
       .scndry_vect_out (sync_eventlog_cur_cnt ) 
      );
endmodule


//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename   :  axi_perf_mon_v5_0_12_samp_intl_cnt.v
// Version    :  v5.0
// Description:  sample interval counter module instantiates the counter
//               with load value from sample interval register  
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
// axi_perf_mon.v
//      \-- axi_perf_mon_v5_0_12_samp_intl_cnt.v
//-----------------------------------------------------------------------------
// Author:      Kalpanath
// History:
// Kalpanath 07/25/2012      First Version
// ^^^^^^
//-----------------------------------------------------------------------------
`timescale 1ns/1ps
module axi_perf_mon_v5_0_12_samp_intl_cnt 
#(
   parameter                          C_FAMILY             = "nofamily",
   parameter                          C_METRICS_SAMPLE_COUNT_WIDTH = 32
)
(
   input                                         clk,
   input                                         rst_n,
   input                                         Interval_Cnt_En,   
   input                                         Interval_Cnt_Ld,   
   input  [(C_METRICS_SAMPLE_COUNT_WIDTH - 1):0] Interval_Cnt_Ld_Val,  
   output [(C_METRICS_SAMPLE_COUNT_WIDTH - 1):0] Sample_Interval_Cnt,  
   output                                        Sample_Interval_Cnt_Lapse   

);



//-------------------------------------------------------------------
// Parameter Declaration
//-------------------------------------------------------------------
localparam RST_ACTIVE = 1'b0;
localparam ALL_ZEROES = {C_METRICS_SAMPLE_COUNT_WIDTH{1'b0}};

//-------------------------------------------------------------------
// Signal Declaration
//-------------------------------------------------------------------
wire Sample_Interval_Cnt_Lapse_int;
wire Sample_Cnt_Ld = Interval_Cnt_Ld | Sample_Interval_Cnt_Lapse_int;

//-------------------------------------------------------------------
// Begin architecture
//-------------------------------------------------------------------

//-- Counter Instantiation
axi_perf_mon_v5_0_12_counter 
  #(
       .C_FAMILY             (C_FAMILY),
       .C_NUM_BITS           (C_METRICS_SAMPLE_COUNT_WIDTH),
       .COUNTER_LOAD_VALUE   (32'h00000000)
   ) counter_inst 
   (
       .clk                  (clk),
       .rst_n                (rst_n),
       .Load_In              (Interval_Cnt_Ld_Val),
       .Count_Enable         (Interval_Cnt_En),
       .Count_Load           (Sample_Cnt_Ld),
       .Count_Down           (1'b1),
       .Count_Out            (Sample_Interval_Cnt),
       .Carry_Out            (Sample_Interval_Cnt_Lapse_int)
   );

assign Sample_Interval_Cnt_Lapse = Sample_Interval_Cnt_Lapse_int;


endmodule




//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename     : axi_perf_mon_v5_0_12_samp_metrics_data.v
// Version      : v5.0
// Description  : sampled metrics data registering module
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
//  axi_perf_mon.v
//      \
//      \-- axi_perf_mon_v5_0_12_samp_metrics_data.v
//
//-----------------------------------------------------------------------------
// Author:    Kalpanath
// History:    
// Kalpanath 07/25/2012      First Version
// ~~~~~~
//-----------------------------------------------------------------------------
`timescale 1ns/1ps
module axi_perf_mon_v5_0_12_samp_metrics_data 
#(
   parameter                              C_FAMILY                     = "virtex7",

   parameter                              C_NUM_OF_COUNTERS            = 10,
   parameter                              C_ENABLE_EVENT_COUNT         = 1,  //-- enables/disables perf mon counting logic
   parameter                              C_HAVE_SAMPLED_METRIC_CNT    = 1   //-- enable sampled metric counters logic
)
(
   input                                             clk,
   input                                             rst_n,

   input                                             Sample_En,

   // Metric Counters - in core clk domain
   input [31:0]                                      Metric_Cnt_0,    
   input [31:0]                                      Metric_Cnt_1,    
   input [31:0]                                      Metric_Cnt_2,    
   input [31:0]                                      Metric_Cnt_3,    
   input [31:0]                                      Metric_Cnt_4,    
   input [31:0]                                      Metric_Cnt_5,    
   input [31:0]                                      Metric_Cnt_6,    
   input [31:0]                                      Metric_Cnt_7,    
   input [31:0]                                      Metric_Cnt_8,    
   input [31:0]                                      Metric_Cnt_9,    

   // Incrementers in core clk domain
   input [31:0]                                      Incrementer_0,    
   input [31:0]                                      Incrementer_1,    
   input [31:0]                                      Incrementer_2,    
   input [31:0]                                      Incrementer_3,    
   input [31:0]                                      Incrementer_4,    
   input [31:0]                                      Incrementer_5,    
   input [31:0]                                      Incrementer_6,    
   input [31:0]                                      Incrementer_7,    
   input [31:0]                                      Incrementer_8,    
   input [31:0]                                      Incrementer_9,    

   // Sampled Metric Counters - in core clk domain
   output reg [31:0]                                 Samp_Metric_Cnt_0,    
   output reg [31:0]                                 Samp_Metric_Cnt_1,    
   output reg [31:0]                                 Samp_Metric_Cnt_2,    
   output reg [31:0]                                 Samp_Metric_Cnt_3,    
   output reg [31:0]                                 Samp_Metric_Cnt_4,    
   output reg [31:0]                                 Samp_Metric_Cnt_5,    
   output reg [31:0]                                 Samp_Metric_Cnt_6,    
   output reg [31:0]                                 Samp_Metric_Cnt_7,    
   output reg [31:0]                                 Samp_Metric_Cnt_8,    
   output reg [31:0]                                 Samp_Metric_Cnt_9,    

   // Sampled Incrementers - in core clk domain
   output reg [31:0]                                 Samp_Incrementer_0,    
   output reg [31:0]                                 Samp_Incrementer_1,    
   output reg [31:0]                                 Samp_Incrementer_2,    
   output reg [31:0]                                 Samp_Incrementer_3,    
   output reg [31:0]                                 Samp_Incrementer_4,    
   output reg [31:0]                                 Samp_Incrementer_5,    
   output reg [31:0]                                 Samp_Incrementer_6,    
   output reg [31:0]                                 Samp_Incrementer_7,    
   output reg [31:0]                                 Samp_Incrementer_8,    
   output reg [31:0]                                 Samp_Incrementer_9    


);




//-------------------------------------------------------------------
// Parameter Declaration
//-------------------------------------------------------------------
localparam RST_ACTIVE = 1'b0;


//-------------------------------------------------------------------
// Signal Declaration
//-------------------------------------------------------------------
wire [31:0]  all_zeros = 32'b0;    



//-------------------------------------------------------------------
// Begin architecture
//-------------------------------------------------------------------

//-- Sampled Metric Counter_0
generate
if ((C_HAVE_SAMPLED_METRIC_CNT == 1) && (C_ENABLE_EVENT_COUNT == 1)) begin : GEN_SAMPLE_METRIC_CNT_0
    always @(posedge clk) begin 
       if (rst_n == RST_ACTIVE) begin
           Samp_Metric_Cnt_0  <= 0;
           Samp_Incrementer_0 <= 0;
       end
       else begin
           if (Sample_En == 1'b1) begin
               Samp_Metric_Cnt_0  <= Metric_Cnt_0;
               Samp_Incrementer_0 <= Incrementer_0;
           end
           else begin
               Samp_Metric_Cnt_0  <= Samp_Metric_Cnt_0;
               Samp_Incrementer_0 <= Samp_Incrementer_0;
           end
       end
    end 
end    
else begin : GEN_NO_SAMPLE_METRIC_CNT_0
    always @(*) 
        Samp_Metric_Cnt_0  <= all_zeros;
    always @(*) 
        Samp_Incrementer_0 <= all_zeros;
end
endgenerate

        
//-- Sampled Metric Counter_1
generate
if ((C_HAVE_SAMPLED_METRIC_CNT == 1) && (C_ENABLE_EVENT_COUNT == 1) && (C_NUM_OF_COUNTERS > 1)) begin : GEN_SAMPLE_METRIC_CNT_1
    always @(posedge clk) begin 
       if (rst_n == RST_ACTIVE) begin
           Samp_Metric_Cnt_1  <= 0;
           Samp_Incrementer_1 <= 0;
       end
       else begin
           if (Sample_En == 1'b1) begin
               Samp_Metric_Cnt_1  <= Metric_Cnt_1;
               Samp_Incrementer_1 <= Incrementer_1;
           end
           else begin
               Samp_Metric_Cnt_1  <= Samp_Metric_Cnt_1;
               Samp_Incrementer_1 <= Samp_Incrementer_1;
           end
       end
    end 
end    
else begin : GEN_NO_SAMPLE_METRIC_CNT_1
    always @(*) 
        Samp_Metric_Cnt_1  <= all_zeros;
    always @(*) 
        Samp_Incrementer_1 <= all_zeros;
end
endgenerate


//-- Sampled Metric Counter_2
generate
if ((C_HAVE_SAMPLED_METRIC_CNT == 1) && (C_ENABLE_EVENT_COUNT == 1) && (C_NUM_OF_COUNTERS > 2)) begin : GEN_SAMPLE_METRIC_CNT_2
    always @(posedge clk) begin 
       if (rst_n == RST_ACTIVE) begin
           Samp_Metric_Cnt_2  <= 0;
           Samp_Incrementer_2 <= 0;
       end
       else begin
           if (Sample_En == 1'b1) begin
               Samp_Metric_Cnt_2  <= Metric_Cnt_2;
               Samp_Incrementer_2 <= Incrementer_2;
           end
           else begin
               Samp_Metric_Cnt_2  <= Samp_Metric_Cnt_2;
               Samp_Incrementer_2 <= Samp_Incrementer_2;
           end
       end
    end 
end    
else begin : GEN_NO_SAMPLE_METRIC_CNT_2
    always @(*) 
        Samp_Metric_Cnt_2  <= all_zeros;
    always @(*) 
        Samp_Incrementer_2 <= all_zeros;
end
endgenerate


//-- Sampled Metric Counter_3
generate
if ((C_HAVE_SAMPLED_METRIC_CNT == 1) && (C_ENABLE_EVENT_COUNT == 1) && (C_NUM_OF_COUNTERS > 3)) begin : GEN_SAMPLE_METRIC_CNT_3
    always @(posedge clk) begin 
       if (rst_n == RST_ACTIVE) begin
           Samp_Metric_Cnt_3  <= 0;
           Samp_Incrementer_3 <= 0;
       end
       else begin
           if (Sample_En == 1'b1) begin
               Samp_Metric_Cnt_3  <= Metric_Cnt_3;
               Samp_Incrementer_3 <= Incrementer_3;
           end
           else begin
               Samp_Metric_Cnt_3  <= Samp_Metric_Cnt_3;
               Samp_Incrementer_3 <= Samp_Incrementer_3;
           end
       end
    end 
end    
else begin : GEN_NO_SAMPLE_METRIC_CNT_3
    always @(*) 
        Samp_Metric_Cnt_3  <= all_zeros;
    always @(*) 
        Samp_Incrementer_3 <= all_zeros;
end
endgenerate


//-- Sampled Metric Counter_4
generate
if ((C_HAVE_SAMPLED_METRIC_CNT == 1) && (C_ENABLE_EVENT_COUNT == 1) && (C_NUM_OF_COUNTERS > 4)) begin : GEN_SAMPLE_METRIC_CNT_4
    always @(posedge clk) begin 
       if (rst_n == RST_ACTIVE) begin
           Samp_Metric_Cnt_4  <= 0;
           Samp_Incrementer_4 <= 0;
       end
       else begin
           if (Sample_En == 1'b1) begin
               Samp_Metric_Cnt_4  <= Metric_Cnt_4;
               Samp_Incrementer_4 <= Incrementer_4;
           end
           else begin
               Samp_Metric_Cnt_4  <= Samp_Metric_Cnt_4;
               Samp_Incrementer_4 <= Samp_Incrementer_4;
           end
       end
    end 
end    
else begin : GEN_NO_SAMPLE_METRIC_CNT_4
    always @(*) 
       Samp_Metric_Cnt_4  <= all_zeros;
    always @(*) 
       Samp_Incrementer_4 <= all_zeros;
end
endgenerate


//-- Sampled Metric Counter_5
generate
if ((C_HAVE_SAMPLED_METRIC_CNT == 1) && (C_ENABLE_EVENT_COUNT == 1) && (C_NUM_OF_COUNTERS > 5)) begin : GEN_SAMPLE_METRIC_CNT_5
    always @(posedge clk) begin 
       if (rst_n == RST_ACTIVE) begin
           Samp_Metric_Cnt_5  <= 0;
           Samp_Incrementer_5 <= 0;
       end
       else begin
           if (Sample_En == 1'b1) begin
               Samp_Metric_Cnt_5  <= Metric_Cnt_5;
               Samp_Incrementer_5 <= Incrementer_5;
           end
           else begin
               Samp_Metric_Cnt_5  <= Samp_Metric_Cnt_5;
               Samp_Incrementer_5 <= Samp_Incrementer_5;
           end
       end
    end 
end    
else begin : GEN_NO_SAMPLE_METRIC_CNT_5
    always @(*) 
        Samp_Metric_Cnt_5  <= all_zeros;
    always @(*) 
        Samp_Incrementer_5 <= all_zeros;
end
endgenerate


//-- Sampled Metric Counter_6
generate
if ((C_HAVE_SAMPLED_METRIC_CNT == 1) && (C_ENABLE_EVENT_COUNT == 1) && (C_NUM_OF_COUNTERS > 6)) begin : GEN_SAMPLE_METRIC_CNT_6
    always @(posedge clk) begin 
       if (rst_n == RST_ACTIVE) begin
           Samp_Metric_Cnt_6  <= 0;
           Samp_Incrementer_6 <= 0;
       end
       else begin
           if (Sample_En == 1'b1) begin
               Samp_Metric_Cnt_6  <= Metric_Cnt_6;
               Samp_Incrementer_6 <= Incrementer_6;
           end
           else begin
               Samp_Metric_Cnt_6  <= Samp_Metric_Cnt_6;
               Samp_Incrementer_6 <= Samp_Incrementer_6;
           end
       end
    end 
end    
else begin : GEN_NO_SAMPLE_METRIC_CNT_6
    always @(*) 
        Samp_Metric_Cnt_6  <= all_zeros;
    always @(*) 
        Samp_Incrementer_6 <= all_zeros;
end
endgenerate


//-- Sampled Metric Counter_7
generate
if ((C_HAVE_SAMPLED_METRIC_CNT == 1) && (C_ENABLE_EVENT_COUNT == 1) && (C_NUM_OF_COUNTERS > 7)) begin : GEN_SAMPLE_METRIC_CNT_7
    always @(posedge clk) begin 
       if (rst_n == RST_ACTIVE) begin
           Samp_Metric_Cnt_7  <= 0;
           Samp_Incrementer_7 <= 0;
       end
       else begin
           if (Sample_En == 1'b1) begin
               Samp_Metric_Cnt_7  <= Metric_Cnt_7;
               Samp_Incrementer_7 <= Incrementer_7;
           end
           else begin
               Samp_Metric_Cnt_7  <= Samp_Metric_Cnt_7;
               Samp_Incrementer_7 <= Samp_Incrementer_7;
           end
       end
    end 
end    
else begin : GEN_NO_SAMPLE_METRIC_CNT_7
    always @(*) 
        Samp_Metric_Cnt_7  <= all_zeros;
    always @(*) 
        Samp_Incrementer_7 <= all_zeros;
end
endgenerate


//-- Sampled Metric Counter_8
generate
if ((C_HAVE_SAMPLED_METRIC_CNT == 1) && (C_ENABLE_EVENT_COUNT == 1) && (C_NUM_OF_COUNTERS > 8)) begin : GEN_SAMPLE_METRIC_CNT_8
    always @(posedge clk) begin 
       if (rst_n == RST_ACTIVE) begin
           Samp_Metric_Cnt_8  <= 0;
           Samp_Incrementer_8 <= 0;
       end
       else begin
           if (Sample_En == 1'b1) begin
               Samp_Metric_Cnt_8  <= Metric_Cnt_8;
               Samp_Incrementer_8 <= Incrementer_8;
           end
           else begin
               Samp_Metric_Cnt_8  <= Samp_Metric_Cnt_8;
               Samp_Incrementer_8 <= Samp_Incrementer_8;
           end
       end
    end 
end    
else begin : GEN_NO_SAMPLE_METRIC_CNT_8
    always @(*) 
        Samp_Metric_Cnt_8  <= all_zeros;
    always @(*) 
        Samp_Incrementer_8 <= all_zeros;
end
endgenerate


//-- Sampled Metric Counter_9
generate
if ((C_HAVE_SAMPLED_METRIC_CNT == 1) && (C_ENABLE_EVENT_COUNT == 1) && (C_NUM_OF_COUNTERS > 9)) begin : GEN_SAMPLE_METRIC_CNT_9
    always @(posedge clk) begin 
       if (rst_n == RST_ACTIVE) begin
           Samp_Metric_Cnt_9  <= 0;
           Samp_Incrementer_9 <= 0;
       end
       else begin
           if (Sample_En == 1'b1) begin
               Samp_Metric_Cnt_9  <= Metric_Cnt_9;
               Samp_Incrementer_9 <= Incrementer_9;
           end
           else begin
               Samp_Metric_Cnt_9  <= Samp_Metric_Cnt_9;
               Samp_Incrementer_9 <= Samp_Incrementer_9;
           end
       end
    end 
end    
else begin : GEN_NO_SAMPLE_METRIC_CNT_9
    always @(*) 
       Samp_Metric_Cnt_9  <= all_zeros;
    always @(*) 
       Samp_Incrementer_9 <= all_zeros;
end
endgenerate





endmodule       


//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename   : axi_perf_mon_v5_0_12_strm_fifo_wr_logic.v
// Version    : v5.0
// Description: Event log streaming fifo write logic module 
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
// axi_perf_mon.v
//      \--axi_perf_mon_v5_0_12_strm_fifo_wr_logic.v 
//-----------------------------------------------------------------------------
// Author:      Kalpanath
// History:
// Kalpanath 07/25/2012      First Version
// ^^^^^^
// NLR       03/20/2013      Updated Time stamp counter load value
// ^^^^^^
//-----------------------------------------------------------------------------
`timescale 1ns/1ps
module axi_perf_mon_v5_0_12_strm_fifo_wr_logic 
#(
   parameter C_FAMILY                        = "nofamily",
   parameter C_NUM_MONITOR_SLOTS             = 8,
   parameter C_SW_SYNC_DATA_WIDTH            = 32,  //-- Width of SW data register
   parameter C_SLOT_0_LOG_WIDTH              = 64,
   parameter C_SLOT_1_LOG_WIDTH              = 64,
   parameter C_SLOT_2_LOG_WIDTH              = 64,
   parameter C_SLOT_3_LOG_WIDTH              = 64,
   parameter C_SLOT_4_LOG_WIDTH              = 64,
   parameter C_SLOT_5_LOG_WIDTH              = 64,
   parameter C_SLOT_6_LOG_WIDTH              = 64,
   parameter C_SLOT_7_LOG_WIDTH              = 64,
   parameter C_FIFO_AXIS_TDATA_WIDTH         = 258, // AXI Streaming FIFO width
   parameter C_EN_AXI_DEBUG                  = 0,
   //parameter C_EN_ALL_TRACE                  = 0, 
   parameter C_EN_TRIGGER                    = 0

)
(
   input                                    clk,
   input                                    rst_n,

   input                                    Event_Log_En,     //-- synchronized to core clk

   input  [C_SLOT_0_LOG_WIDTH-1:0]          Slot_0_Log,
   input                                    Slot_0_Log_En,
   input  [C_SLOT_1_LOG_WIDTH-1:0]          Slot_1_Log,
   input                                    Slot_1_Log_En,
   input  [C_SLOT_2_LOG_WIDTH-1:0]          Slot_2_Log,
   input                                    Slot_2_Log_En,
   input  [C_SLOT_3_LOG_WIDTH-1:0]          Slot_3_Log,
   input                                    Slot_3_Log_En,
   input  [C_SLOT_4_LOG_WIDTH-1:0]          Slot_4_Log,
   input                                    Slot_4_Log_En,
   input  [C_SLOT_5_LOG_WIDTH-1:0]          Slot_5_Log,
   input                                    Slot_5_Log_En,
   input  [C_SLOT_6_LOG_WIDTH-1:0]          Slot_6_Log,
   input                                    Slot_6_Log_En,
   input  [C_SLOT_7_LOG_WIDTH-1:0]          Slot_7_Log,
   input                                    Slot_7_Log_En,

   input                                    SW_Data_Log_En,    
   input  [C_SW_SYNC_DATA_WIDTH-1:0]        SW_Data,    
   input                                    SW_Data_Wr_En,    //-- synchronized to core clk
   
   input  [2:0]                             Ext_Event0_Flags,
   input  [2:0]                             Ext_Event1_Flags,
   input  [2:0]                             Ext_Event2_Flags,
   input  [2:0]                             Ext_Event3_Flags,
   input  [2:0]                             Ext_Event4_Flags,
   input  [2:0]                             Ext_Event5_Flags,
   input  [2:0]                             Ext_Event6_Flags,
   input  [2:0]                             Ext_Event7_Flags,
   //input  [31:0]                            Trace_Ctrl_reg_bits,

   input                                    Fifo_Full,
   input                                    Fifo_Empty,

   output reg                               Fifo_Wr_En,
   output reg [C_FIFO_AXIS_TDATA_WIDTH-1:0] Fifo_Wr_Data,
   input                       			     trigger
);



//-------------------------------------------------------------------
// Parameter Declaration
//-------------------------------------------------------------------
localparam RST_ACTIVE = 1'b0;
localparam TIME_DIFF_LOAD_VALUE = 16'h0001;

//-------------------------------------------------------------------
// Signal Declaration
//-------------------------------------------------------------------
//wire
wire [15:0]                         Time_Diff;    
wire                                over_flow;    
//FIFO WIDTH-(16bit timestamp+1bit loopevent+1bitlog id)
wire [C_FIFO_AXIS_TDATA_WIDTH-19:0] mon_wr_data_int;

//reg
reg                                 Mon_Wr_En;    
reg [C_FIFO_AXIS_TDATA_WIDTH-19:0]  Mon_Wr_Data;
reg                                 Event_Log_En_D1;    
reg                                 over_flow_cap;   
reg [C_FIFO_AXIS_TDATA_WIDTH-1:0]   Fifo_Reg_Data; 
reg                                 Fifo_Reg_Wr_En;


wire [7:0] Slot_Log_En = {Slot_0_Log_En,Slot_1_Log_En,Slot_2_Log_En,Slot_3_Log_En,Slot_4_Log_En,
                          Slot_5_Log_En,Slot_6_Log_En,Slot_7_Log_En};

//-------------------------------------------------------------------
// Begin architecture
//-------------------------------------------------------------------

//--Monitor write data assignment based on number of monitor slots

  generate 
  if(C_NUM_MONITOR_SLOTS == 1) begin:GEN_ONE_LOG
       if (!C_EN_AXI_DEBUG)
       assign mon_wr_data_int = {Slot_0_Log,Ext_Event0_Flags};
     else
       assign mon_wr_data_int = {Slot_0_Log};
  end
  else if(C_NUM_MONITOR_SLOTS == 2) begin:GEN_TWO_LOG
    if (!C_EN_AXI_DEBUG)
    assign mon_wr_data_int = {Slot_1_Log,Ext_Event1_Flags,Slot_0_Log,Ext_Event0_Flags};
      else
    assign mon_wr_data_int = {Slot_1_Log,Slot_0_Log};

  end
  else if(C_NUM_MONITOR_SLOTS == 3) begin:GEN_THREE_LOG
    if (!C_EN_AXI_DEBUG)
     assign mon_wr_data_int = {Slot_2_Log, Ext_Event2_Flags,Slot_1_Log, Ext_Event1_Flags, Slot_0_Log,Ext_Event0_Flags};
    else
     assign mon_wr_data_int = {Slot_2_Log,Slot_1_Log,Slot_0_Log};
  end
  else if(C_NUM_MONITOR_SLOTS == 4) begin:GEN_FOUR_LOG
    if (!C_EN_AXI_DEBUG)
     assign mon_wr_data_int = {Slot_3_Log, Ext_Event3_Flags, Slot_2_Log, Ext_Event2_Flags,Slot_1_Log, 
                              Ext_Event1_Flags, Slot_0_Log, Ext_Event0_Flags};
    else
     assign mon_wr_data_int = {Slot_3_Log,Slot_2_Log,Slot_1_Log,Slot_0_Log};
  end
  else if(C_NUM_MONITOR_SLOTS == 5) begin:GEN_FIVE_LOG
    if (!C_EN_AXI_DEBUG)
    assign mon_wr_data_int = {Slot_4_Log, Ext_Event4_Flags, Slot_3_Log, Ext_Event3_Flags, Slot_2_Log, 
                              Ext_Event2_Flags,Slot_1_Log, Ext_Event1_Flags, Slot_0_Log, Ext_Event0_Flags};
    else
     assign mon_wr_data_int = {Slot_4_Log,Slot_3_Log,Slot_2_Log,Slot_1_Log,Slot_0_Log};
  end
  else if(C_NUM_MONITOR_SLOTS == 6) begin:GEN_SIX_LOG
    if (!C_EN_AXI_DEBUG)
    assign mon_wr_data_int = {Slot_5_Log, Ext_Event5_Flags, Slot_4_Log, Ext_Event4_Flags, Slot_3_Log, 
                              Ext_Event3_Flags, Slot_2_Log, Ext_Event2_Flags,Slot_1_Log, Ext_Event1_Flags, 
                              Slot_0_Log, Ext_Event0_Flags};
    else
     assign mon_wr_data_int = {Slot_5_Log,Slot_4_Log,Slot_3_Log,Slot_2_Log,Slot_1_Log,Slot_0_Log};
  end
  else if(C_NUM_MONITOR_SLOTS == 7) begin:GEN_SEVEN_LOG
    if (!C_EN_AXI_DEBUG)
    assign mon_wr_data_int = {Slot_6_Log, Ext_Event6_Flags, Slot_5_Log, Ext_Event5_Flags, Slot_4_Log, 
                              Ext_Event4_Flags, Slot_3_Log, Ext_Event3_Flags, Slot_2_Log, Ext_Event2_Flags,
                              Slot_1_Log, Ext_Event1_Flags, Slot_0_Log, Ext_Event0_Flags};
    else
     assign mon_wr_data_int = {Slot_6_Log,Slot_5_Log,Slot_4_Log,Slot_3_Log,Slot_2_Log,Slot_1_Log,Slot_0_Log};
  end
  else if(C_NUM_MONITOR_SLOTS == 8) begin:GEN_EIGHT_LOG
    if (!C_EN_AXI_DEBUG)
    assign mon_wr_data_int = {Slot_7_Log, Ext_Event7_Flags, Slot_6_Log, Ext_Event6_Flags, Slot_5_Log, 
                              Ext_Event5_Flags, Slot_4_Log, Ext_Event4_Flags, Slot_3_Log, Ext_Event3_Flags, 
                              Slot_2_Log, Ext_Event2_Flags,Slot_1_Log, Ext_Event1_Flags, Slot_0_Log, 
                              Ext_Event0_Flags};
    else
     assign mon_wr_data_int = {Slot_7_Log,Slot_6_Log,Slot_5_Log,Slot_4_Log,Slot_3_Log,Slot_2_Log,Slot_1_Log,Slot_0_Log};
  end
  endgenerate

//-- Flag generation
always @(posedge clk) begin 
   if (rst_n == RST_ACTIVE) begin
       Mon_Wr_En   <= 1'b0;
       Mon_Wr_Data <= 0;
   end
   else begin
 //   if (C_EN_AXI_DEBUG == 0 && C_EN_ALL_TRACE == 1)
 //          Mon_Wr_En   <=  | (Slot_Log_En | (Trace_Ctrl_reg_bits[0]&(|Ext_Event0_Flags)) | (Trace_Ctrl_reg_bits[4]&(|Ext_Event1_Flags)) | (Trace_Ctrl_reg_bits[8]&(|Ext_Event2_Flags)) | (Trace_Ctrl_reg_bits[12]&(|Ext_Event3_Flags)) | (Trace_Ctrl_reg_bits[16]&(|Ext_Event4_Flags)) | (Trace_Ctrl_reg_bits[20]&(|Ext_Event5_Flags)) | (Trace_Ctrl_reg_bits[24]&(|Ext_Event6_Flags)) | (Trace_Ctrl_reg_bits[28]&(|Ext_Event7_Flags)));
    if(!C_EN_AXI_DEBUG)
           Mon_Wr_En   <=  | (Slot_Log_En | Ext_Event0_Flags | Ext_Event1_Flags | Ext_Event2_Flags | Ext_Event3_Flags | Ext_Event4_Flags | Ext_Event5_Flags | Ext_Event6_Flags | Ext_Event7_Flags);
      else
           Mon_Wr_En   <=  | (Slot_Log_En);
       Mon_Wr_Data <= mon_wr_data_int;
   end
end 

//--Event Log enable registering 
always @(posedge clk) begin 
   if (rst_n == RST_ACTIVE) begin
       Event_Log_En_D1 <= 1'b0;
   end
   else begin
       Event_Log_En_D1 <= Event_Log_En;
   end
end 

//-- Event Log Enable edge detection
wire Event_Log_En_Edge = Event_Log_En && (!Event_Log_En_D1);

wire SW_Data_Log_n_Wr_En = SW_Data_Log_En && SW_Data_Wr_En;

wire Count_Reset = Event_Log_En_Edge || Mon_Wr_En || SW_Data_Log_n_Wr_En;

//-- Time difference Counter Instantiation
axi_perf_mon_v5_0_12_counter 
  #(
       .C_FAMILY             (C_FAMILY),
       .C_NUM_BITS           (16),
       .COUNTER_LOAD_VALUE   (32'h00000000)
   ) counter_inst 
   (
       .clk                  (clk),
       .rst_n                (rst_n),
       .Load_In              (TIME_DIFF_LOAD_VALUE),
       .Count_Enable         (Event_Log_En),
       .Count_Load           (Count_Reset),
       .Count_Down           (1'b0),
       .Count_Out            (Time_Diff),
       .Carry_Out            (over_flow)
   );

//-- Capturing Overflow
always @(posedge clk) begin 
   if (rst_n == RST_ACTIVE) begin
       over_flow_cap <= 1'b0;
   end
   else begin
       if ((Fifo_Wr_En == 1'b1)) begin
          over_flow_cap <= 1'b0;
       end
       else if ((over_flow == 1'b1)) begin
          over_flow_cap <= 1'b1;
       end
       else begin
          over_flow_cap <= over_flow_cap;
       end
   end
end 


   reg mark_first_trigger ;
   reg trigger_r1;
   wire first_trigger;
  generate 
  if(C_EN_TRIGGER == 1) begin:GEN_TRIGGER

   always @(posedge clk or negedge rst_n )
     if (!rst_n ) begin
	   // Beginning of autoreset for uninitialized flops
   	mark_first_trigger <= 1'h0;
	   trigger_r1 <=0;
   	// End of automatics
     end
     else
       begin
	    trigger_r1 <= trigger;
   	   if (trigger_r1)
	        mark_first_trigger <=1;
	      else if (!trigger_r1 )
	        mark_first_trigger <=0;
	  end
   assign first_trigger = (~mark_first_trigger) & trigger_r1; 
   end
   endgenerate

//-- FIFO Write Enable and Write Data generation
//-- This logic sends either software written data register value or
//-- the AXI/external events log.
//-- This logic is written to handle the concurrent software written data register
//-- write and axi/external events occurance
always @(posedge clk) begin 
   if (rst_n == RST_ACTIVE) begin
       Fifo_Wr_En     <= 1'b0;    //write enable to FIFO
       Fifo_Wr_Data   <= 0;       //write data to FIFO
       Fifo_Reg_Data  <= 0;       //Registered Monitor slot write data 
       Fifo_Reg_Wr_En <= 1'b0;    //Registered write enable to FIFO
   end
   else begin
       if ((Fifo_Full == 1'b0) && (Event_Log_En == 1'b1)) begin
           if (SW_Data_Log_n_Wr_En == 1'b1) begin          //SW data
               Fifo_Wr_En     <= 1'b1;
               Fifo_Wr_Data   <= { 6'b0, SW_Data, over_flow_cap, Time_Diff,1'b1};
               if(Mon_Wr_En == 1'b1) begin
                 Fifo_Reg_Data  <= { Mon_Wr_Data, over_flow_cap, 16'b0,1'b0}; //Time diff 0
                 Fifo_Reg_Wr_En <= 1'b1;
               end
               else begin
                 Fifo_Reg_Data  <= 0;
                 Fifo_Reg_Wr_En <= 1'b0;
               end
           end
           else if (Fifo_Reg_Wr_En == 1'b1) begin           
               Fifo_Wr_Data <= Fifo_Reg_Data;
               Fifo_Wr_En   <= 1'b1; 
               if(Mon_Wr_En == 1'b1) begin
                 Fifo_Reg_Data  <= { Mon_Wr_Data, over_flow_cap, 16'b0,1'b0}; //Time diff 0
                 Fifo_Reg_Wr_En <= 1'b1;
               end
               else begin
                 Fifo_Reg_Data  <= 0;
                 Fifo_Reg_Wr_En <= 1'b0;
               end
           end
           else if (Mon_Wr_En == 1'b1) begin
               Fifo_Wr_En     <= 1'b1;
               if (C_EN_TRIGGER == 1)
               Fifo_Wr_Data   <= { Mon_Wr_Data, first_trigger, over_flow_cap, Time_Diff,SW_Data_Log_n_Wr_En};
               else
               Fifo_Wr_Data   <= { Mon_Wr_Data, over_flow_cap, Time_Diff,1'b0};
               Fifo_Reg_Data  <= 0;
               Fifo_Reg_Wr_En <= 1'b0;
           end
           else begin
               Fifo_Wr_En     <= 1'b0;
               Fifo_Wr_Data   <= 0;
               Fifo_Reg_Data  <= 0;
               Fifo_Reg_Wr_En <= 1'b0;
           end
       end
       else begin
           Fifo_Wr_En   <= 1'b0;
           Fifo_Wr_Data <= 0;
           Fifo_Reg_Data  <= 0;
           Fifo_Reg_Wr_En <= 1'b0;
       end
   end
end 


endmodule










//-----------------------------------------------------------------------------
// axi_perf_mon_v5_0_12_throttle  module
//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename     : axi_perf_mon_v5_0_12_throttle.v
// Version      : v5.0
// Description  : This is the top level wrapper file for the AXI Performance
//                Monitor profile mode. 
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
// axi_perf_mon_v5_0_12_top.v
//   \--axi_perf_mon_v5_0_12_profile.v
//     \-- axi_perf_mon_v5_0_12_axi_interface.v
//             \--axi_perf_mon_v5_0_12_cdc_sync.v
//             \-- axi_perf_mon_v5_0_12_intr_sync.v
//                 \--axi_perf_mon_v5_0_12_cdc_sync.v
//      \-- axi_perf_mon_v5_0_12_interrupt_module.v
//      \-- axi_perf_mon_v5_0_12_cdc_sync.v
//      \-- axi_perf_mon_v5_0_12_mon_fifo.v
//           \-- axi_perf_mon_v5_0_12_async_fifo.vhd
//       \-- axi_perf_mon_v5_0_12_register_module_profile.v
//       \-- axi_perf_mon_v5_0_12_metric_calc_profile.v
//            \-- axi_perf_mon_v5_0_12_sync_fifo.vhd
//            \-- axi_perf_mon_v5_0_12_counter.v
//       \-- axi_perf_mon_v5_0_12_metric_counters_profile.v
//           \-- axi_perf_mon_v5_0_12_acc_sample_profile.v
//       \-- axi_perf_mon_v5_0_12_postTriggerMarker.v
//           \-- axi_perf_mon_v5_0_12_throttle.v
//      \-- axi_perf_mon_v5_0_12_strm_fifo_wr_logic.v
//      \-- axi_perf_mon_v5_0_12_async_stream_fifo.v
//       \-- axi_perf_mon_v5_0_12_flags_gen_trace.v
//---------------------------------------------------------------------------
// Author  :   Kartheek 
// History :    
// Kartheek    19/01/2015      First Version
// ^^^^^^
//---------------------------------------------------------------------------
//Aligning start and end events of transactions

`timescale 1ns/1ps
(* DowngradeIPIdentifiedWarnings="yes" *)

module axi_perf_mon_v5_0_12_throttle 
	    (
		 input 	clk,
		 input 	rst_n,
		 input 	start_token,
		 input 	end_token,
		 input 	trigger,
	    input   reStart,
		 output  enable_start_out,
	    output enable_end_out		
		 );

   parameter COUNTER_Width=6;    // counter width
   // counter used to count AXI outstanding tranx
   reg [COUNTER_Width:0] outstanding_c;
   reg [COUNTER_Width:0] outstanding_r; 
   reg [COUNTER_Width :0] outstanding_in;

   // marders fro star and end events  
   reg 			   enable_start;
   reg 			   enable_end;
   reg [1:0] 			       currentState, nextState;

   localparam Idle = 2'b00;
   localparam Reset = 2'b01;
   localparam Filter = 2'b10;
   localparam Bypass =2'b11;
  

   always @ (posedge clk)
    begin
   	if (!rst_n ) begin
	    outstanding_c <=0;
	    outstanding_r <=0;
	   end
	   else  begin
	    if (reStart) begin
	     outstanding_c <= 0;
	     outstanding_r <=0;
	    end
	   else
	    begin
	     outstanding_r <= outstanding_in;
	     if (start_token && !end_token)
		   outstanding_c <= outstanding_c +1;
	     else if (!start_token && end_token)
		   outstanding_c <= outstanding_c -1;
	     else if (start_token && end_token)
		   outstanding_c <= outstanding_c;
	     else 
		   outstanding_c <= outstanding_c;
	     end
	   end
     end
   
   always @( end_token or nextState
	    or outstanding_c or outstanding_r or start_token)
     begin
	   if (nextState == Reset || nextState == Bypass)
	     outstanding_in <=0;
	   else if (nextState == Idle ) begin
	      if (start_token && !end_token)
		     outstanding_in <= outstanding_c +1;
	      else if (!start_token && end_token)
		     outstanding_in <= outstanding_c -1;
	      else if (start_token && end_token)
		     outstanding_in <= outstanding_c;
	      else 
		     outstanding_in <= outstanding_c;
	   end
	   else if (nextState == Filter ) begin
	    if (end_token )
	     outstanding_in <= outstanding_r -1;
	    else
	     outstanding_in <= outstanding_r;
	   end
	   else
	     outstanding_in <= 0;
      end
//state machine, used to align the starts and ends of AXI outstanding tranx      

   always @(posedge clk)
    begin
   	if (!rst_n)
	    begin
	     enable_end <= 1'h0;
	     enable_start <= 1'h0;
	    end
	   else
	    begin
	     case (nextState)
		   Reset: begin
		    enable_end <= 1'h0;
		    enable_start <= 1'h0;
		   end
		   Idle:
		    begin
		     enable_start <= 1'b0;
		     enable_end <= 1'b0;
		    end
		   Filter: begin
		     enable_end <= 1'b0;
		     enable_start <=start_token;
		   end
		   Bypass: begin
		    enable_start<=start_token;
		    enable_end <= end_token;
		   end
		   default: begin
		    enable_start <=1'b0;
		    enable_end <=1'b0;
		   end
      endcase
	  end
    end // always @ (posedge clk or negedge rst_n)
   

   always @(currentState or outstanding_r or trigger)
     begin
	  case (currentState )
	    Reset:begin
	     nextState <= Idle;
	    end
	    Idle: begin
	     if (trigger) begin 
		   nextState <= Filter;
	     end
	     else
	       nextState <= Idle;
	    end
	    Filter : begin
	     if (trigger == 1) begin 
	       if (outstanding_r == 0)
		     nextState <= Bypass;
	       else
		     nextState <= Filter;
	     end
	     else
	      nextState <= Reset;
	    end
	    Bypass:begin
	     if (trigger)
	       nextState <= Bypass;
	     else
	       nextState <= Reset;
	    end
	    default:
	     nextState <= Reset;
   	endcase // case (currentState )
     end

     always @ (posedge clk) begin
     if (!rst_n ) begin
       currentState <= 2'b0;
     end
     else
       currentState <=nextState;
     end

   assign enable_start_out = enable_start;
   assign enable_end_out = enable_end;
   

endmodule // throttle


//-----------------------------------------------------------------------------
// axi_perf_mon_v5_0_12_postTriggerMarker  module
//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename     : axi_perf_mon_v5_0_12_postTriggerMarker.v
// Version      : v5.0
// Description  : This is the top level wrapper file for the AXI Performance
//                Monitor profile mode. 
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
// axi_perf_mon_v5_0_12_top.v
//   \--axi_perf_mon_v5_0_12_profile.v
//     \-- axi_perf_mon_v5_0_12_axi_interface.v
//             \--axi_perf_mon_v5_0_12_cdc_sync.v
//             \-- axi_perf_mon_v5_0_12_intr_sync.v
//                 \--axi_perf_mon_v5_0_12_cdc_sync.v
//      \-- axi_perf_mon_v5_0_12_interrupt_module.v
//      \-- axi_perf_mon_v5_0_12_cdc_sync.v
//      \-- axi_perf_mon_v5_0_12_mon_fifo.v
//           \-- axi_perf_mon_v5_0_12_async_fifo.vhd
//       \-- axi_perf_mon_v5_0_12_register_module_profile.v
//       \-- axi_perf_mon_v5_0_12_metric_calc_profile.v
//            \-- axi_perf_mon_v5_0_12_sync_fifo.vhd
//            \-- axi_perf_mon_v5_0_12_counter.v
//       \-- axi_perf_mon_v5_0_12_metric_counters_profile.v
//           \-- axi_perf_mon_v5_0_12_acc_sample_profile.v
//       \-- axi_perf_mon_v5_0_12_postTriggerMarker.v
//           \-- axi_perf_mon_v5_0_12_throttle.v
//      \-- axi_perf_mon_v5_0_12_strm_fifo_wr_logic.v
//      \-- axi_perf_mon_v5_0_12_async_stream_fifo.v
//       \-- axi_perf_mon_v5_0_12_flags_gen_trace.v
//---------------------------------------------------------------------------
// Author  :   Kartheek 
// History :    
// Kartheek    15/01/2015      First Version
// ^^^^^^
//---------------------------------------------------------------------------

module axi_perf_mon_v5_0_12_postTriggerMarker
  # (
     parameter C_FAMILY                 = "nofamily",
     parameter C_MON_FIFO_DATA_WIDTH    = 64,
     parameter C_LOG_WIDTH              = 71,
     parameter C_FLAG_WIDTH             = 7,  //-- 7: for AXI4   2: for AXI4S
     //AXI Slot Interface parameters
     parameter C_AXI_ADDR_WIDTH         = 32,
     parameter C_AXI_DATA_WIDTH         = 32,
     parameter C_AXI_ID_WIDTH           = 1,
     parameter C_AXI_PROTOCOL           = "AXI4",
     parameter C_SHOW_AXI_IDS           = 1,
     parameter C_SHOW_AXI_LEN           = 1,
     
     parameter C_EN_WR_ADD_FLAG         = 1,
     parameter C_EN_FIRST_WRITE_FLAG    = 1, 
     parameter C_EN_LAST_WRITE_FLAG     = 1, 
     parameter C_EN_RESPONSE_FLAG       = 1, 
     parameter C_EN_RD_ADD_FLAG         = 1, 
     parameter C_EN_FIRST_READ_FLAG = 1, 
     parameter C_EN_LAST_READ_FLAG      = 1, 
     parameter C_OUTSTANDING_TRANX      = 6,

     parameter C_FLAG_SPLIT_POINT        = 4,
     parameter C_EN_EXT_EVENTS_FLAG     = 0
     )
   (
     input 		      clk,
     input 		      rst_n,

     input 		      trigger, // assuming that the trigger signal has been synchronized
     
     input [C_LOG_WIDTH-1:0]  Log_Data,
     input 		      Log_En,
     input 		      reStart,
     output [C_LOG_WIDTH+3:0] Log_Data_Marked,
     output 		      Log_en_out

    
   );
   localparam C_PATH_WIDTH = C_AXI_ADDR_WIDTH+8+2; // 8 is burst length, 2 bit for tokens.
   localparam RD_START_TOKEN = 1;
   localparam RD_END_TOKEN =0;
   localparam WR_START_TOKEN = C_PATH_WIDTH+1;
   localparam WR_END_TOKEN =C_PATH_WIDTH;
   
  
   // parse the start events and end events
   wire 		     Rd_startToken =  Log_Data[RD_START_TOKEN]; 
   wire 		     Rd_endToken = Log_Data [RD_END_TOKEN]; 		     

   wire 		     Wr_startToken = Log_Data[WR_START_TOKEN] ;
   wire 		     Wr_endToken = Log_Data[WR_END_TOKEN] ;

   

   wire 		     Wr_mark_start, Wr_mark_end;
   wire 		     Rd_mark_start, Rd_mark_end; 		     


   reg [C_PATH_WIDTH-1:0]  writePath;
   reg [C_PATH_WIDTH-1:0]  readPath;
   wire [C_PATH_WIDTH+1:0] marked_write_out, marked_read_out;
   wire 		   wr_en, rd_en;
   reg 			   mark_first_trigger;
   wire 		   first_trigger;
   

   // generate post-trigger markers for start and end events
   axi_perf_mon_v5_0_12_throttle throttle_rd (
			 // Outputs
			 .enable_start_out		(Rd_mark_start),
			 .enable_end_out		(Rd_mark_end),
			 // Inputs
			 .clk			(clk),
			 .rst_n			(rst_n),
			 .start_token		(Rd_startToken),
			 .end_token		(Rd_endToken),
			 .reStart (reStart),
			 .trigger		(trigger));
   axi_perf_mon_v5_0_12_throttle throttle_wr (
			 // Outputs
			 .enable_start_out		(Wr_mark_start),
			 .enable_end_out		(Wr_mark_end),
			 // Inputs
			 .clk			(clk),
			 .rst_n			(rst_n),
			 .start_token		(Wr_startToken),
			 .end_token		(Wr_endToken),
			 .reStart (reStart),
			 .trigger		(trigger));
   
   
   always @(posedge clk or negedge rst_n )
     if (!rst_n)
       begin

	  readPath <= {C_PATH_WIDTH{1'b0}};
	  writePath <= {C_PATH_WIDTH{1'b0}};

       end
     else begin
	writePath <= {Log_Data[2*C_PATH_WIDTH-1:C_PATH_WIDTH] }; 
	readPath <= {Log_Data[C_PATH_WIDTH-1: 0]};
     end

   wire [C_AXI_ADDR_WIDTH-1 :0] AWADDR = writePath [C_PATH_WIDTH-1 : C_PATH_WIDTH-C_AXI_ADDR_WIDTH];
    wire [C_AXI_ADDR_WIDTH-1 :0] ARADDR = readPath [C_PATH_WIDTH-1 : C_PATH_WIDTH-C_AXI_ADDR_WIDTH];


   always @(posedge clk or negedge rst_n )
     if (!rst_n ) begin

	mark_first_trigger <= 1'h0;

     end
     else
       begin
	  if (reStart )
	    mark_first_trigger <=0;
	  else if (trigger)
	    mark_first_trigger <=1;
	  else if (!trigger )
	    mark_first_trigger <=0;
	 
       end
   
   // when trigger signal comes in, genereate a one-cyle pulse.  
   assign first_trigger = (~mark_first_trigger) & trigger;

   assign marked_write_out = {writePath, {Wr_mark_start,Wr_mark_end}};
   assign marked_read_out  = {readPath, {Rd_mark_start,Rd_mark_end}};

   //generate enable sigal for FIFO usage
   assign wr_en = writePath[1]|writePath[0];
   assign rd_en = readPath[1]|readPath[0];

   assign Log_Data_Marked = {marked_write_out,marked_read_out };

   
   assign Log_en_out = wr_en |rd_en |first_trigger;
		      

   
endmodule 


//-----------------------------------------------------------------------------
// axi_perf_mon_v5_0_12_advanced  module
//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename     : axi_perf_mon_v5_0_12_advanced.v
// Version      : v5.0
// Description  : This is the top level wrapper file for the AXI Performance
//                Monitor advanced mode. 
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
// axi_perf_mon_v5_0_12_top.v
//   \-- axi_perf_mon_v5_0_12_advanced.v
//     \-- axi_perf_mon_v5_0_12_axi_interface.v
//     \-- axi_perf_mon_v5_0_12_register_module.v
//             \--axi_perf_mon_v5_0_12_cdc_sync.v
//             \-- axi_perf_mon_v5_0_12_intr_sync.v
//             \--axi_perf_mon_v5_0_12_cdc_sync.v
//      \-- axi_perf_mon_v5_0_12_interrupt_module.v
//      \-- axi_perf_mon_v5_0_12_cdc_sync.v
//          \-- axi_perf_mon_v5_0_12_glbl_clk_cnt.v
//           \-- axi_perf_mon_v5_0_12_counter.v
//      \-- axi_perf_mon_v5_0_12_mon_fifo.v
//           \-- axi_perf_mon_v5_0_12_async_fifo.vhd
//      \-- axi_perf_mon_v5_0_12_metric_calc.v
//            \-- axi_perf_mon_v5_0_12_sync_fifo.vhd
//            \-- axi_perf_mon_v5_0_12_counter.v
//      \-- axi_perf_mon_v5_0_12_metric_counters.v
//            \-- axi_perf_mon_v5_0_12_metric_sel_n_cnt.v 
//            \--axi_perf_mon_v5_0_12_acc_n_incr.v
//               \--axi_perf_mon_v5_0_12_counter.v
//      \-- axi_perf_mon_v5_0_12_samp_intl_cnt.v
//          \-- axi_perf_mon_v5_0_12_counter.v
//      \-- axi_perf_mon_v5_0_12_samp_metrics_data.v
//      \-- axi_perf_mon_v5_0_12_flags_gen.v
//      \-- axi_perf_mon_v5_0_12_strm_fifo_wr_logic.v
//          \-- axi_perf_mon_v5_0_12_counter.v
//      \-- axi_perf_mon_v5_0_12_async_stream_fifo.v
//           \-- axi_perf_mon_v5_0_12_async_fifo.vhd
//---------------------------------------------------------------------------
// Author  :   NLR 
// History :    
// NLR       07/25/2012      First Version
// ^^^^^^
// NLR       12/18/2012      Release of v3_00_a with feature updates
// ^^^^^^
// NLR       03/20/2013      Release of v5_0
// ^^^^^^ 
// NLR       04/15/2013      Added resetting of sampled metric counters with
//                           Control register bit 
// ^^^^^^^
// NLR       06/18/2013      Restructred the code with proper generate statements 
// ^^^^^^^
// NLR       10/02/2013      Added advanced, profile and trace mode supports
// ^^^^^^^                   Metric scaling factor support
//---------------------------------------------------------------------------
`timescale 1ns/1ps
(* DowngradeIPIdentifiedWarnings="yes" *)

module axi_perf_mon_v5_0_12_advanced 
  # (
    parameter C_FAMILY                        = "virtex7",

    //AXI Slave Interface parameters for this core
    parameter C_S_AXI_ADDR_WIDTH              = 16, 
    parameter C_S_AXI_DATA_WIDTH              = 32,
    parameter C_S_AXI_PROTOCOL                = "AXI4LITE",
    parameter C_S_AXI_ID_WIDTH                = 1,
    parameter C_SUPPORT_ID_REFLECTION         = 0,

    //Counter Parameters
    parameter C_NUM_MONITOR_SLOTS             = 1,
    parameter C_ENABLE_EVENT_COUNT            = 1,  //-- enables/disables perf mon counting logic
    parameter C_NUM_OF_COUNTERS               = 10,
    parameter C_METRIC_COUNT_WIDTH            = 32, 
    parameter C_METRIC_COUNT_SCALE            = 1, 
    parameter C_GLOBAL_COUNT_WIDTH            = 32,
    parameter C_HAVE_SAMPLED_METRIC_CNT       = 1,  //-- enable sampled metric counters logic
    parameter C_METRICS_SAMPLE_COUNT_WIDTH    = 32,
    parameter C_AXI4LITE_CORE_CLK_ASYNC       = 1,  //-- disable synchronizers incase its 0 

    //AXI Slot 0 Interface parameters
    parameter C_SLOT_0_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_0_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_0_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_0_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_0_AXI_SUB_PROTOCOL       = "AXI4LITE",
    parameter C_SLOT_0_AXIS_TDATA_WIDTH       = 32,
    parameter C_SLOT_0_AXIS_TID_WIDTH         = 1,
    parameter C_SLOT_0_AXIS_TDEST_WIDTH       = 1,
    parameter C_SLOT_0_AXIS_TUSER_WIDTH       = 1,
    parameter C_SLOT_0_FIFO_ENABLE            = 1,

    //AXI Slot 1 Interface parameters
    parameter C_SLOT_1_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_1_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_1_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_1_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_1_AXI_SUB_PROTOCOL       = "AXI4LITE",
    parameter C_SLOT_1_AXIS_TDATA_WIDTH       = 32,
    parameter C_SLOT_1_AXIS_TID_WIDTH         = 1,
    parameter C_SLOT_1_AXIS_TDEST_WIDTH       = 1,
    parameter C_SLOT_1_AXIS_TUSER_WIDTH       = 1,
    parameter C_SLOT_1_FIFO_ENABLE            = 1,

    //AXI Slot 2 Interface parameters
    parameter C_SLOT_2_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_2_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_2_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_2_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_2_AXI_SUB_PROTOCOL       = "AXI4LITE",
    parameter C_SLOT_2_AXIS_TDATA_WIDTH       = 32,
    parameter C_SLOT_2_AXIS_TID_WIDTH         = 1,
    parameter C_SLOT_2_AXIS_TDEST_WIDTH       = 1,
    parameter C_SLOT_2_AXIS_TUSER_WIDTH       = 1,
    parameter C_SLOT_2_FIFO_ENABLE            = 1,
 
    //AXI Slot 3 Interface parameters
    parameter C_SLOT_3_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_3_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_3_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_3_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_3_AXI_SUB_PROTOCOL       = "AXI4LITE",
    parameter C_SLOT_3_AXIS_TDATA_WIDTH       = 32,
    parameter C_SLOT_3_AXIS_TID_WIDTH         = 1,
    parameter C_SLOT_3_AXIS_TDEST_WIDTH       = 1,
    parameter C_SLOT_3_AXIS_TUSER_WIDTH       = 1,
    parameter C_SLOT_3_FIFO_ENABLE            = 1,

    //AXI Slot 4 Interface parameters
    parameter C_SLOT_4_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_4_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_4_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_4_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_4_AXI_SUB_PROTOCOL       = "AXI4LITE",
    parameter C_SLOT_4_AXIS_TDATA_WIDTH       = 32,
    parameter C_SLOT_4_AXIS_TID_WIDTH         = 1,
    parameter C_SLOT_4_AXIS_TDEST_WIDTH       = 1,
    parameter C_SLOT_4_AXIS_TUSER_WIDTH       = 1,
    parameter C_SLOT_4_FIFO_ENABLE            = 1,

    //AXI Slot 5 Interface parameters
    parameter C_SLOT_5_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_5_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_5_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_5_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_5_AXI_SUB_PROTOCOL       = "AXI4LITE",
    parameter C_SLOT_5_AXIS_TDATA_WIDTH       = 32,
    parameter C_SLOT_5_AXIS_TID_WIDTH         = 1,
    parameter C_SLOT_5_AXIS_TDEST_WIDTH       = 1,
    parameter C_SLOT_5_AXIS_TUSER_WIDTH       = 1,
    parameter C_SLOT_5_FIFO_ENABLE            = 1,

    //AXI Slot 6 Interface parameters
    parameter C_SLOT_6_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_6_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_6_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_6_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_6_AXI_SUB_PROTOCOL       = "AXI4LITE",
    parameter C_SLOT_6_AXIS_TDATA_WIDTH       = 32,
    parameter C_SLOT_6_AXIS_TID_WIDTH         = 1,
    parameter C_SLOT_6_AXIS_TDEST_WIDTH       = 1,
    parameter C_SLOT_6_AXIS_TUSER_WIDTH       = 1,
    parameter C_SLOT_6_FIFO_ENABLE            = 1,

    //AXI Slot 7 Interface parameters
    parameter C_SLOT_7_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_7_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_7_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_7_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_7_AXI_SUB_PROTOCOL       = "AXI4LITE",
    parameter C_SLOT_7_AXIS_TDATA_WIDTH       = 32,
    parameter C_SLOT_7_AXIS_TID_WIDTH         = 1,
    parameter C_SLOT_7_AXIS_TDEST_WIDTH       = 1,
    parameter C_SLOT_7_AXIS_TUSER_WIDTH       = 1,
    parameter C_SLOT_7_FIFO_ENABLE            = 1,

    // Register all Monitor inputs option
    parameter C_REG_ALL_MONITOR_SIGNALS       = 0,

    // Fifo option for external events
    parameter C_EXT_EVENT0_FIFO_ENABLE        = 1,
    parameter C_EXT_EVENT1_FIFO_ENABLE        = 1,
    parameter C_EXT_EVENT2_FIFO_ENABLE        = 1,
    parameter C_EXT_EVENT3_FIFO_ENABLE        = 1,
    parameter C_EXT_EVENT4_FIFO_ENABLE        = 1,
    parameter C_EXT_EVENT5_FIFO_ENABLE        = 1,
    parameter C_EXT_EVENT6_FIFO_ENABLE        = 1,
    parameter C_EXT_EVENT7_FIFO_ENABLE        = 1,

    //Event Log Parameters
    parameter C_ENABLE_EVENT_LOG              = 0,   //-- enables event logging logic
    parameter C_FIFO_AXIS_DEPTH               = 32,  // AXI Streaming FIFO depth
    parameter C_FIFO_AXIS_TDATA_WIDTH         = 56, // AXI Streaming FIFO width
    parameter C_AXIS_DWIDTH_ROUND_TO_32       = 56, // AXI Streaming FIFO width rounded to next 32bit
    parameter C_FIFO_AXIS_TID_WIDTH           = 1,   // AXI Streaming FIFO ID width
    parameter C_FIFO_AXIS_SYNC                = 0,   // 1=Sync FIFO, 0=ASYNC FIFO
    parameter C_SHOW_AXI_IDS                  = 1,
    parameter C_SHOW_AXI_LEN                  = 1,
    parameter C_SHOW_AXIS_TID                 = 1,
    parameter C_SHOW_AXIS_TDEST               = 1,
    parameter C_SHOW_AXIS_TUSER               = 1,
    parameter COUNTER_LOAD_VALUE              = 32'h00000000,
    parameter C_LOG_DATA_OFFLD                = 0,//0- stream offload,1-Memorymap offload 
    parameter S_AXI_OFFLD_ID_WIDTH            = 1,//offload interface ID width.
    parameter C_EN_TRIGGER                    = 0,//Enable trigger logic
    parameter C_EN_AXI_DEBUG                  = 0 //Enable AXI Debug
        )
    (
    //AXI-Lite Interface   
    input                                    s_axi_aclk,
    input                                    s_axi_aresetn,
    input [15:0]                             s_axi_awaddr,
    input                                    s_axi_awvalid,
    input [C_S_AXI_ID_WIDTH-1:0]             s_axi_awid,     //AXI4 Full Interface support
    output                                   s_axi_awready,
    input [31:0]                             s_axi_wdata,
    input [3:0]                              s_axi_wstrb,
    input                                    s_axi_wvalid,
    output                                   s_axi_wready,
    output [1:0]                             s_axi_bresp,
    output                                   s_axi_bvalid,
    output [C_S_AXI_ID_WIDTH-1:0]            s_axi_bid,      //AXI4 Full Interface support
    input                                    s_axi_bready,
    input  [15:0]                            s_axi_araddr,
    input                                    s_axi_arvalid,
    input [C_S_AXI_ID_WIDTH-1:0]             s_axi_arid,     //AXI4 Full Interface support
    output                                   s_axi_arready,
    output [31:0]                            s_axi_rdata,
    output [1:0]                             s_axi_rresp,
    output                                   s_axi_rvalid,
    output [C_S_AXI_ID_WIDTH-1:0]            s_axi_rid,      //AXI4 Full Interface support
    input                                    s_axi_rready,
  
    // SLOT 0 AXI MM Interface signals
    input                                    slot_0_axi_aclk,
    input                                    slot_0_axi_aresetn,
    input [C_SLOT_0_AXI_ID_WIDTH-1:0]        slot_0_axi_awid,
    input [C_SLOT_0_AXI_ADDR_WIDTH-1:0]      slot_0_axi_awaddr,
    input [2:0]                              slot_0_axi_awprot,
    input [7:0]                              slot_0_axi_awlen,
    input [2:0]                              slot_0_axi_awsize,
    input [1:0]                              slot_0_axi_awburst,
    input [3:0]                              slot_0_axi_awcache,
    input                                    slot_0_axi_awlock,
    input                                    slot_0_axi_awvalid,
    input                                    slot_0_axi_awready,
    input [C_SLOT_0_AXI_DATA_WIDTH-1:0]      slot_0_axi_wdata,
    input [C_SLOT_0_AXI_DATA_WIDTH/8-1:0]    slot_0_axi_wstrb,
    input                                    slot_0_axi_wlast,
    input                                    slot_0_axi_wvalid,
    input                                    slot_0_axi_wready,
    input [C_SLOT_0_AXI_ID_WIDTH-1:0]        slot_0_axi_bid,
    input [1:0]                              slot_0_axi_bresp,
    input                                    slot_0_axi_bvalid,
    input                                    slot_0_axi_bready,
    input [C_SLOT_0_AXI_ID_WIDTH-1:0]        slot_0_axi_arid,
    input [C_SLOT_0_AXI_ADDR_WIDTH-1:0]      slot_0_axi_araddr,
    input [7:0]                              slot_0_axi_arlen,
    input [2:0]                              slot_0_axi_arsize,
    input [1:0]                              slot_0_axi_arburst,
    input [3:0]                              slot_0_axi_arcache,
    input [2:0]                              slot_0_axi_arprot,
    input                                    slot_0_axi_arlock,
    input                                    slot_0_axi_arvalid,
    input                                    slot_0_axi_arready,
    input [C_SLOT_0_AXI_ID_WIDTH-1:0]        slot_0_axi_rid,
    input [C_SLOT_0_AXI_DATA_WIDTH-1:0]      slot_0_axi_rdata,
    input [1:0]                              slot_0_axi_rresp,
    input                                    slot_0_axi_rlast,
    input                                    slot_0_axi_rvalid,
    input                                    slot_0_axi_rready,
  
    //SLOT 0 AXI Streaming Interface
    input                                    slot_0_axis_aclk,
    input                                    slot_0_axis_aresetn,
    input                                    slot_0_axis_tvalid,
    input                                    slot_0_axis_tready,
    input [C_SLOT_0_AXIS_TDATA_WIDTH-1:0]    slot_0_axis_tdata,
    input [C_SLOT_0_AXIS_TDATA_WIDTH/8-1:0]  slot_0_axis_tstrb,
    input [C_SLOT_0_AXIS_TDATA_WIDTH/8-1:0]  slot_0_axis_tkeep,
    input                                    slot_0_axis_tlast,
    input [C_SLOT_0_AXIS_TID_WIDTH-1:0]      slot_0_axis_tid,
    input [C_SLOT_0_AXIS_TDEST_WIDTH-1:0]    slot_0_axis_tdest,
    input [C_SLOT_0_AXIS_TUSER_WIDTH-1:0]    slot_0_axis_tuser,

    //SLOT 0 External Triggers
    input                                    slot_0_ext_trig,
    input                                    slot_0_ext_trig_stop,
  
    // SLOT 1 AXI MM interface signals
    
    input                                    slot_1_axi_aclk,
    input                                    slot_1_axi_aresetn,
    input [C_SLOT_1_AXI_ID_WIDTH-1:0]        slot_1_axi_awid,
    input [C_SLOT_1_AXI_ADDR_WIDTH-1:0]      slot_1_axi_awaddr,
    input [2:0]                              slot_1_axi_awprot,
    input [7:0]                              slot_1_axi_awlen,
    input [2:0]                              slot_1_axi_awsize,
    input [1:0]                              slot_1_axi_awburst,
    input [3:0]                              slot_1_axi_awcache,
    input                                    slot_1_axi_awlock,
    input                                    slot_1_axi_awvalid,
    input                                    slot_1_axi_awready,
    input [C_SLOT_1_AXI_DATA_WIDTH-1:0]      slot_1_axi_wdata,
    input [C_SLOT_1_AXI_DATA_WIDTH/8-1:0]    slot_1_axi_wstrb,
    input                                    slot_1_axi_wlast,
    input                                    slot_1_axi_wvalid,
    input                                    slot_1_axi_wready,
    input [C_SLOT_1_AXI_ID_WIDTH-1:0]        slot_1_axi_bid,
    input [1:0]                              slot_1_axi_bresp,
    input                                    slot_1_axi_bvalid,
    input                                    slot_1_axi_bready,
    input [C_SLOT_1_AXI_ID_WIDTH-1:0]        slot_1_axi_arid,
    input [C_SLOT_1_AXI_ADDR_WIDTH-1:0]      slot_1_axi_araddr,
    input [7:0]                              slot_1_axi_arlen,
    input [2:0]                              slot_1_axi_arsize,
    input [1:0]                              slot_1_axi_arburst,
    input [3:0]                              slot_1_axi_arcache,
    input [2:0]                              slot_1_axi_arprot,
    input                                    slot_1_axi_arlock,
    input                                    slot_1_axi_arvalid,
    input                                    slot_1_axi_arready,
    input [C_SLOT_1_AXI_ID_WIDTH-1:0]        slot_1_axi_rid,
    input [C_SLOT_1_AXI_DATA_WIDTH-1:0]      slot_1_axi_rdata,
    input [1:0]                              slot_1_axi_rresp,
    input                                    slot_1_axi_rlast,
    input                                    slot_1_axi_rvalid,
    input                                    slot_1_axi_rready,
  
    //SLOT 1 AXI Streaming Interface
    input                                    slot_1_axis_aclk,
    input                                    slot_1_axis_aresetn,
    input                                    slot_1_axis_tvalid,
    input                                    slot_1_axis_tready,
    input [C_SLOT_1_AXIS_TDATA_WIDTH-1:0]    slot_1_axis_tdata,
    input [C_SLOT_1_AXIS_TDATA_WIDTH/8-1:0]  slot_1_axis_tstrb,
    input [C_SLOT_1_AXIS_TDATA_WIDTH/8-1:0]  slot_1_axis_tkeep,
    input                                    slot_1_axis_tlast,
    input [C_SLOT_1_AXIS_TID_WIDTH-1:0]      slot_1_axis_tid,
    input [C_SLOT_1_AXIS_TDEST_WIDTH-1:0]    slot_1_axis_tdest,
    input [C_SLOT_1_AXIS_TUSER_WIDTH-1:0]    slot_1_axis_tuser,
  
    //SLOT 1 External Trigger
    input                                    slot_1_ext_trig,
    input                                    slot_1_ext_trig_stop,

    //SLOT 2 AXI MM Interface 
  
    input                                    slot_2_axi_aclk,
    input                                    slot_2_axi_aresetn,
    input [C_SLOT_2_AXI_ID_WIDTH-1:0]        slot_2_axi_awid,
    input [C_SLOT_2_AXI_ADDR_WIDTH-1:0]      slot_2_axi_awaddr,
    input [2:0]                              slot_2_axi_awprot,
    input [7:0]                              slot_2_axi_awlen,
    input [2:0]                              slot_2_axi_awsize,
    input [1:0]                              slot_2_axi_awburst,
    input [3:0]                              slot_2_axi_awcache,
    input                                    slot_2_axi_awlock,
    input                                    slot_2_axi_awvalid,
    input                                    slot_2_axi_awready,
    input [C_SLOT_2_AXI_DATA_WIDTH-1:0]      slot_2_axi_wdata,
    input [C_SLOT_2_AXI_DATA_WIDTH/8-1: 0]   slot_2_axi_wstrb,
    input                                    slot_2_axi_wlast,
    input                                    slot_2_axi_wvalid,
    input                                    slot_2_axi_wready,
    input [C_SLOT_2_AXI_ID_WIDTH-1:0]        slot_2_axi_bid,
    input [1:0]                              slot_2_axi_bresp,
    input                                    slot_2_axi_bvalid,
    input                                    slot_2_axi_bready,
    input [C_SLOT_2_AXI_ID_WIDTH-1:0]        slot_2_axi_arid,
    input [C_SLOT_2_AXI_ADDR_WIDTH-1:0]      slot_2_axi_araddr,
    input [7:0]                              slot_2_axi_arlen,
    input [2:0]                              slot_2_axi_arsize,
    input [1:0]                              slot_2_axi_arburst,
    input [3:0]                              slot_2_axi_arcache,
    input [2:0]                              slot_2_axi_arprot,
    input                                    slot_2_axi_arlock,
    input                                    slot_2_axi_arvalid,
    input                                    slot_2_axi_arready,
    input [C_SLOT_2_AXI_ID_WIDTH-1:0]        slot_2_axi_rid,
    input [C_SLOT_2_AXI_DATA_WIDTH-1:0]      slot_2_axi_rdata,
    input [1:0]                              slot_2_axi_rresp,
    input                                    slot_2_axi_rlast,
    input                                    slot_2_axi_rvalid,
    input                                    slot_2_axi_rready,
  
   //SLOT 2 AXI Streaming Interface
    input                                    slot_2_axis_aclk,
    input                                    slot_2_axis_aresetn,
    input                                    slot_2_axis_tvalid,
    input                                    slot_2_axis_tready,
    input [C_SLOT_2_AXIS_TDATA_WIDTH-1:0]    slot_2_axis_tdata,
    input [C_SLOT_2_AXIS_TDATA_WIDTH/8-1:0]  slot_2_axis_tstrb,
    input [C_SLOT_2_AXIS_TDATA_WIDTH/8-1:0]  slot_2_axis_tkeep,
    input                                    slot_2_axis_tlast,
    input [C_SLOT_2_AXIS_TID_WIDTH-1:0]      slot_2_axis_tid,
    input [C_SLOT_2_AXIS_TDEST_WIDTH-1:0]    slot_2_axis_tdest,
    input [C_SLOT_2_AXIS_TUSER_WIDTH-1:0]    slot_2_axis_tuser,

   //SLOT 2 External Trigger
    input                                    slot_2_ext_trig,
    input                                    slot_2_ext_trig_stop,
  
   //SLOT 3 AXI MM Interface
    input                                    slot_3_axi_aclk,
    input                                    slot_3_axi_aresetn,
    input [C_SLOT_3_AXI_ID_WIDTH-1:0]        slot_3_axi_awid,
    input [C_SLOT_3_AXI_ADDR_WIDTH-1:0]      slot_3_axi_awaddr,
    input [2:0]                              slot_3_axi_awprot,
    input [7:0]                              slot_3_axi_awlen,
    input [2:0]                              slot_3_axi_awsize,
    input [1:0]                              slot_3_axi_awburst,
    input [3:0]                              slot_3_axi_awcache,
    input                                    slot_3_axi_awlock,
    input                                    slot_3_axi_awvalid,
    input                                    slot_3_axi_awready,
    input [C_SLOT_3_AXI_DATA_WIDTH-1:0]      slot_3_axi_wdata,
    input [C_SLOT_3_AXI_DATA_WIDTH/8-1:0]    slot_3_axi_wstrb,
    input                                    slot_3_axi_wlast,
    input                                    slot_3_axi_wvalid,
    input                                    slot_3_axi_wready,
    input [C_SLOT_3_AXI_ID_WIDTH-1:0]        slot_3_axi_bid,
    input [1:0]                              slot_3_axi_bresp,
    input                                    slot_3_axi_bvalid,
    input                                    slot_3_axi_bready,
    input [C_SLOT_3_AXI_ID_WIDTH-1:0]        slot_3_axi_arid,
    input [C_SLOT_3_AXI_ADDR_WIDTH-1:0]      slot_3_axi_araddr,
    input [7:0]                              slot_3_axi_arlen,
    input [2:0]                              slot_3_axi_arsize,
    input [1:0]                              slot_3_axi_arburst,
    input [3:0]                              slot_3_axi_arcache,
    input [2:0]                              slot_3_axi_arprot,
    input                                    slot_3_axi_arlock,
    input                                    slot_3_axi_arvalid,
    input                                    slot_3_axi_arready,
    input [C_SLOT_3_AXI_ID_WIDTH-1:0]        slot_3_axi_rid,
    input [C_SLOT_3_AXI_DATA_WIDTH-1:0]      slot_3_axi_rdata,
    input [1:0]                              slot_3_axi_rresp,
    input                                    slot_3_axi_rlast,
    input                                    slot_3_axi_rvalid,
    input                                    slot_3_axi_rready,
  
    //SLOT 3 AXI Streaming Interface
    input                                    slot_3_axis_aclk,
    input                                    slot_3_axis_aresetn,
    input                                    slot_3_axis_tvalid,
    input                                    slot_3_axis_tready,
    input [C_SLOT_3_AXIS_TDATA_WIDTH-1:0]    slot_3_axis_tdata,
    input [C_SLOT_3_AXIS_TDATA_WIDTH/8-1:0]  slot_3_axis_tstrb,
    input [C_SLOT_3_AXIS_TDATA_WIDTH/8-1:0]  slot_3_axis_tkeep,
    input                                    slot_3_axis_tlast,
    input [C_SLOT_3_AXIS_TID_WIDTH-1:0]      slot_3_axis_tid,
    input [C_SLOT_3_AXIS_TDEST_WIDTH-1:0]    slot_3_axis_tdest,
    input [C_SLOT_3_AXIS_TUSER_WIDTH-1:0]    slot_3_axis_tuser,

    //SLOT 3 External Trigger
    input                                    slot_3_ext_trig,
    input                                    slot_3_ext_trig_stop,
  
    //SLOT 4 AXI MM Interface
    input                                    slot_4_axi_aclk,
    input                                    slot_4_axi_aresetn,
    input [C_SLOT_4_AXI_ID_WIDTH-1:0]        slot_4_axi_awid,
    input [C_SLOT_4_AXI_ADDR_WIDTH-1:0]      slot_4_axi_awaddr,
    input [2:0]                              slot_4_axi_awprot,
    input [7:0]                              slot_4_axi_awlen,
    input [2:0]                              slot_4_axi_awsize,
    input [1:0]                              slot_4_axi_awburst,
    input [3:0]                              slot_4_axi_awcache,
    input                                    slot_4_axi_awlock,
    input                                    slot_4_axi_awvalid,
    input                                    slot_4_axi_awready,
    input [C_SLOT_4_AXI_DATA_WIDTH-1:0]      slot_4_axi_wdata,
    input [C_SLOT_4_AXI_DATA_WIDTH/8-1:0]    slot_4_axi_wstrb,
    input                                    slot_4_axi_wlast,
    input                                    slot_4_axi_wvalid,
    input                                    slot_4_axi_wready,
    input [C_SLOT_4_AXI_ID_WIDTH-1:0]        slot_4_axi_bid,
    input [1:0]                              slot_4_axi_bresp,
    input                                    slot_4_axi_bvalid,
    input                                    slot_4_axi_bready,
    input  [C_SLOT_4_AXI_ID_WIDTH-1:0]       slot_4_axi_arid,
    input  [C_SLOT_4_AXI_ADDR_WIDTH-1:0]     slot_4_axi_araddr,
    input  [7:0]                             slot_4_axi_arlen,
    input  [2:0]                             slot_4_axi_arsize,
    input  [1:0]                             slot_4_axi_arburst,
    input  [3:0]                             slot_4_axi_arcache,
    input  [2:0]                             slot_4_axi_arprot,
    input                                    slot_4_axi_arlock,
    input                                    slot_4_axi_arvalid,
    input                                    slot_4_axi_arready,
    input [C_SLOT_4_AXI_ID_WIDTH-1:0]        slot_4_axi_rid,
    input [C_SLOT_4_AXI_DATA_WIDTH-1:0]      slot_4_axi_rdata,
    input [1:0]                              slot_4_axi_rresp,
    input                                    slot_4_axi_rlast,
    input                                    slot_4_axi_rvalid,
    input                                    slot_4_axi_rready,
  
    //SLOT 4 AXI Streaming Interface
    input                                    slot_4_axis_aclk,
    input                                    slot_4_axis_aresetn,
    input                                    slot_4_axis_tvalid,
    input                                    slot_4_axis_tready,
    input [C_SLOT_4_AXIS_TDATA_WIDTH-1:0]    slot_4_axis_tdata,
    input [C_SLOT_4_AXIS_TDATA_WIDTH/8-1:0]  slot_4_axis_tstrb,
    input [C_SLOT_4_AXIS_TDATA_WIDTH/8-1:0]  slot_4_axis_tkeep,
    input                                    slot_4_axis_tlast,
    input [C_SLOT_4_AXIS_TID_WIDTH-1:0]      slot_4_axis_tid,
    input [C_SLOT_4_AXIS_TDEST_WIDTH-1:0]    slot_4_axis_tdest,
    input [C_SLOT_4_AXIS_TUSER_WIDTH-1:0]    slot_4_axis_tuser,

    //SLOT 4 External Trigger
    input                                    slot_4_ext_trig,
    input                                    slot_4_ext_trig_stop,

    //SLOT 5 AXI MM Interface
  
    input                                    slot_5_axi_aclk,
    input                                    slot_5_axi_aresetn,
    input [C_SLOT_5_AXI_ID_WIDTH-1:0]        slot_5_axi_awid,
    input [C_SLOT_5_AXI_ADDR_WIDTH-1:0]      slot_5_axi_awaddr,
    input [2:0]                              slot_5_axi_awprot,
    input [7:0]                              slot_5_axi_awlen,
    input [2:0]                              slot_5_axi_awsize,
    input [1:0]                              slot_5_axi_awburst,
    input [3:0]                              slot_5_axi_awcache,
    input                                    slot_5_axi_awlock,
    input                                    slot_5_axi_awvalid,
    input                                    slot_5_axi_awready,
    input [C_SLOT_5_AXI_DATA_WIDTH-1:0]      slot_5_axi_wdata,
    input [C_SLOT_5_AXI_DATA_WIDTH/8-1:0]    slot_5_axi_wstrb,
    input                                    slot_5_axi_wlast,
    input                                    slot_5_axi_wvalid,
    input                                    slot_5_axi_wready,
    input [C_SLOT_5_AXI_ID_WIDTH-1:0]        slot_5_axi_bid,
    input [1:0]                              slot_5_axi_bresp,
    input                                    slot_5_axi_bvalid,
    input                                    slot_5_axi_bready,
    input [C_SLOT_5_AXI_ID_WIDTH-1:0]        slot_5_axi_arid,
    input [C_SLOT_5_AXI_ADDR_WIDTH-1:0]      slot_5_axi_araddr,
    input [7:0]                              slot_5_axi_arlen,
    input [2:0]                              slot_5_axi_arsize,
    input [1:0]                              slot_5_axi_arburst,
    input [3:0]                              slot_5_axi_arcache,
    input [2:0]                              slot_5_axi_arprot,
    input                                    slot_5_axi_arlock,
    input                                    slot_5_axi_arvalid,
    input                                    slot_5_axi_arready,
    input [C_SLOT_5_AXI_ID_WIDTH-1:0]        slot_5_axi_rid,
    input [C_SLOT_5_AXI_DATA_WIDTH-1:0]      slot_5_axi_rdata,
    input [1:0]                              slot_5_axi_rresp,
    input                                    slot_5_axi_rlast,
    input                                    slot_5_axi_rvalid,
    input                                    slot_5_axi_rready,
  
    //SLOT 5 AXI Streaming Interface
    input                                    slot_5_axis_aclk,
    input                                    slot_5_axis_aresetn,
    input                                    slot_5_axis_tvalid,
    input                                    slot_5_axis_tready,
    input [C_SLOT_5_AXIS_TDATA_WIDTH-1:0]    slot_5_axis_tdata,
    input [C_SLOT_5_AXIS_TDATA_WIDTH/8-1:0]  slot_5_axis_tstrb,
    input [C_SLOT_5_AXIS_TDATA_WIDTH/8-1:0]  slot_5_axis_tkeep,
    input                                    slot_5_axis_tlast,
    input [C_SLOT_5_AXIS_TID_WIDTH-1:0]      slot_5_axis_tid,
    input [C_SLOT_5_AXIS_TDEST_WIDTH-1:0]    slot_5_axis_tdest,
    input [C_SLOT_5_AXIS_TUSER_WIDTH-1:0]    slot_5_axis_tuser,

    //SLOT 5 External Trigger
    input                                    slot_5_ext_trig,
    input                                    slot_5_ext_trig_stop,
  
    //SLOT 6 AXI MM Interface
    input                                    slot_6_axi_aclk,
    input                                    slot_6_axi_aresetn,
    input [C_SLOT_6_AXI_ID_WIDTH-1:0]        slot_6_axi_awid,
    input [C_SLOT_6_AXI_ADDR_WIDTH-1:0]      slot_6_axi_awaddr,
    input [2:0]                              slot_6_axi_awprot,
    input [7:0]                              slot_6_axi_awlen,
    input [2:0]                              slot_6_axi_awsize,
    input [1:0]                              slot_6_axi_awburst,
    input [3:0]                              slot_6_axi_awcache,
    input                                    slot_6_axi_awlock,
    input                                    slot_6_axi_awvalid,
    input                                    slot_6_axi_awready,
    input [C_SLOT_6_AXI_DATA_WIDTH-1:0]      slot_6_axi_wdata,
    input [C_SLOT_6_AXI_DATA_WIDTH/8-1:0]    slot_6_axi_wstrb,
    input                                    slot_6_axi_wlast,
    input                                    slot_6_axi_wvalid,
    input                                    slot_6_axi_wready,
    input [C_SLOT_6_AXI_ID_WIDTH-1:0]        slot_6_axi_bid,
    input [1:0]                              slot_6_axi_bresp,
    input                                    slot_6_axi_bvalid,
    input                                    slot_6_axi_bready,
    input [C_SLOT_6_AXI_ID_WIDTH-1:0]        slot_6_axi_arid,
    input [C_SLOT_6_AXI_ADDR_WIDTH-1:0]      slot_6_axi_araddr,
    input [7:0]                              slot_6_axi_arlen,
    input [2:0]                              slot_6_axi_arsize,
    input [1:0]                              slot_6_axi_arburst,
    input [3:0]                              slot_6_axi_arcache,
    input [2:0]                              slot_6_axi_arprot,
    input                                    slot_6_axi_arlock,
    input                                    slot_6_axi_arvalid,
    input                                    slot_6_axi_arready,
    input [C_SLOT_6_AXI_ID_WIDTH-1:0]        slot_6_axi_rid,
    input [C_SLOT_6_AXI_DATA_WIDTH-1:0]      slot_6_axi_rdata,
    input [1:0]                              slot_6_axi_rresp,
    input                                    slot_6_axi_rlast,
    input                                    slot_6_axi_rvalid,
    input                                    slot_6_axi_rready,
  
    //SLOT 6 AXI Streaming Interface
    input                                    slot_6_axis_aclk,
    input                                    slot_6_axis_aresetn,
    input                                    slot_6_axis_tvalid,
    input                                    slot_6_axis_tready,
    input [C_SLOT_6_AXIS_TDATA_WIDTH-1:0]    slot_6_axis_tdata,
    input [C_SLOT_6_AXIS_TDATA_WIDTH/8-1:0]  slot_6_axis_tstrb,
    input [C_SLOT_6_AXIS_TDATA_WIDTH/8-1:0]  slot_6_axis_tkeep,
    input                                    slot_6_axis_tlast,
    input [C_SLOT_6_AXIS_TID_WIDTH-1:0]      slot_6_axis_tid,
    input [C_SLOT_6_AXIS_TDEST_WIDTH-1:0]    slot_6_axis_tdest,
    input [C_SLOT_6_AXIS_TUSER_WIDTH-1:0]    slot_6_axis_tuser,

    //SLOT 6 External Trigger
    input                                    slot_6_ext_trig,
    input                                    slot_6_ext_trig_stop,
  
    //SLOT 7 AXI MM Interface
    input                                    slot_7_axi_aclk,
    input                                    slot_7_axi_aresetn,
    input [C_SLOT_7_AXI_ID_WIDTH-1:0]        slot_7_axi_awid,
    input [C_SLOT_7_AXI_ADDR_WIDTH-1:0]      slot_7_axi_awaddr,
    input [2:0]                              slot_7_axi_awprot,
    input [7:0]                              slot_7_axi_awlen,
    input [2:0]                              slot_7_axi_awsize,
    input [1:0]                              slot_7_axi_awburst,
    input [3:0]                              slot_7_axi_awcache,
    input                                    slot_7_axi_awlock,
    input                                    slot_7_axi_awvalid,
    input                                    slot_7_axi_awready,
    input [C_SLOT_7_AXI_DATA_WIDTH-1:0]      slot_7_axi_wdata,
    input [C_SLOT_7_AXI_DATA_WIDTH/8-1:0]    slot_7_axi_wstrb,
    input                                    slot_7_axi_wlast,
    input                                    slot_7_axi_wvalid,
    input                                    slot_7_axi_wready,
    input [C_SLOT_7_AXI_ID_WIDTH-1:0]        slot_7_axi_bid,
    input [1:0]                              slot_7_axi_bresp,
    input                                    slot_7_axi_bvalid,
    input                                    slot_7_axi_bready,
    input [C_SLOT_7_AXI_ID_WIDTH-1:0]        slot_7_axi_arid,
    input [C_SLOT_7_AXI_ADDR_WIDTH-1:0]      slot_7_axi_araddr,
    input [7:0]                              slot_7_axi_arlen,
    input [2:0]                              slot_7_axi_arsize,
    input [1:0]                              slot_7_axi_arburst,
    input [3:0]                              slot_7_axi_arcache,
    input [2:0]                              slot_7_axi_arprot,
    input                                    slot_7_axi_arlock,
    input                                    slot_7_axi_arvalid,
    input                                    slot_7_axi_arready,
    input  [C_SLOT_7_AXI_ID_WIDTH-1:0]       slot_7_axi_rid,
    input  [C_SLOT_7_AXI_DATA_WIDTH-1:0]     slot_7_axi_rdata,
    input  [1:0]                             slot_7_axi_rresp,
    input                                    slot_7_axi_rlast,
    input                                    slot_7_axi_rvalid,
    input                                    slot_7_axi_rready,
  
    //SLOT 7 AXI Streaming Interface
    input                                    slot_7_axis_aclk,
    input                                    slot_7_axis_aresetn,
    input                                    slot_7_axis_tvalid,
    input                                    slot_7_axis_tready,
    input [C_SLOT_7_AXIS_TDATA_WIDTH-1:0]    slot_7_axis_tdata,
    input [C_SLOT_7_AXIS_TDATA_WIDTH/8-1:0]  slot_7_axis_tstrb,
    input [C_SLOT_7_AXIS_TDATA_WIDTH/8-1:0]  slot_7_axis_tkeep,
    input                                    slot_7_axis_tlast,
    input [C_SLOT_7_AXIS_TID_WIDTH-1:0]      slot_7_axis_tid,
    input [C_SLOT_7_AXIS_TDEST_WIDTH-1:0]    slot_7_axis_tdest,
    input [C_SLOT_7_AXIS_TUSER_WIDTH-1:0]    slot_7_axis_tuser,
 
    //SLOT 7 External Trigger
    input                                    slot_7_ext_trig,
    input                                    slot_7_ext_trig_stop,
 
     // External Event 0
    input                                    ext_clk_0,
    input                                    ext_rstn_0,
    input                                    ext_event_0_cnt_start,
    input                                    ext_event_0_cnt_stop,
    input                                    ext_event_0,
  
     // External Event 1
    input                                    ext_clk_1,
    input                                    ext_rstn_1,
    input                                    ext_event_1_cnt_start,
    input                                    ext_event_1_cnt_stop,
    input                                    ext_event_1,

     // External Event 2
    input                                    ext_clk_2,
    input                                    ext_rstn_2,
    input                                    ext_event_2_cnt_start,
    input                                    ext_event_2_cnt_stop,
    input                                    ext_event_2,

     // External Event 3
    input                                    ext_clk_3,
    input                                    ext_rstn_3,
    input                                    ext_event_3_cnt_start,
    input                                    ext_event_3_cnt_stop,
    input                                    ext_event_3,

    // External Event 4
    input                                    ext_clk_4,
    input                                    ext_rstn_4,
    input                                    ext_event_4_cnt_start,
    input                                    ext_event_4_cnt_stop,
    input                                    ext_event_4,

    // External Event 5
    input                                    ext_clk_5,
    input                                    ext_rstn_5,
    input                                    ext_event_5_cnt_start,
    input                                    ext_event_5_cnt_stop,
    input                                    ext_event_5,

    // External Event 6
    input                                    ext_clk_6,
    input                                    ext_rstn_6,
    input                                    ext_event_6_cnt_start,
    input                                    ext_event_6_cnt_stop,
    input                                    ext_event_6,

    // External Event 7
    input                                    ext_clk_7,
    input                                    ext_rstn_7,
    input                                    ext_event_7_cnt_start,
    input                                    ext_event_7_cnt_stop,
    input                                    ext_event_7,
  
     // Capture and Reset events for metric counters
    input                                    capture_event,
    input                                    reset_event,
  
     // Core Clock and Reset signals
    input                                    core_aclk,
    input                                    core_aresetn,
 
     // Event Log streaming interface
    input                                    m_axis_aclk,
    input                                    m_axis_aresetn,
    output [C_FIFO_AXIS_TDATA_WIDTH-1:0]     m_axis_tdata,
    output [C_FIFO_AXIS_TDATA_WIDTH/8-1:0]   m_axis_tstrb,
    output                                   m_axis_tvalid,
    output [C_FIFO_AXIS_TID_WIDTH-1:0]       m_axis_tid,
    input                                    m_axis_tready,
    
     // Event Log 32b memorymap  interface
    input                                    s_axi_offld_aclk,
    input                                    s_axi_offld_aresetn,
    input [31:0]                             s_axi_offld_araddr ,
    input                                    s_axi_offld_arvalid,
    input [7:0]                              s_axi_offld_arlen  ,
    input [S_AXI_OFFLD_ID_WIDTH-1:0]         s_axi_offld_arid   ,    
    output                                   s_axi_offld_arready,
    input                                    s_axi_offld_rready ,
    output [31:0]                            s_axi_offld_rdata  ,
    output [1:0]                             s_axi_offld_rresp  ,
    output                                   s_axi_offld_rvalid ,
    output [S_AXI_OFFLD_ID_WIDTH-1:0]        s_axi_offld_rid    ,      
    output                                   s_axi_offld_rlast  ,      
     // Interrupt to the Processor
    output                                   interrupt,
    input 				                        trigger_in,
    output 				                        trigger_in_ack
);
  

   /*---------------------------------------------------------------------
   -----------------------Parameter declarations-------------------------
   ------------------------------------------------------------------------*/
  localparam RST_ACTIVE = 1'b0;
  localparam C_NUM_INTR_INPUTS = 13; 
  localparam C_SW_SYNC_DATA_WIDTH = 32; 
  localparam C_SLOT_N_FLAG_WIDTH = 7;
 
  localparam C_MON_FIFO_DWIDTH_S0 = (C_SLOT_0_AXI_PROTOCOL == "AXI4") 
             ?(C_SLOT_0_AXI_ID_WIDTH*4 +C_SLOT_0_AXI_ADDR_WIDTH*2 +(C_SLOT_0_AXI_DATA_WIDTH/8)+42)
                                    :((C_SLOT_0_AXIS_TDATA_WIDTH/8)*2 + C_SLOT_0_AXIS_TID_WIDTH
                                     + C_SLOT_0_AXIS_TDEST_WIDTH+C_SLOT_0_AXIS_TUSER_WIDTH+3);
  localparam C_MON_FIFO_DWIDTH_S1 = (C_SLOT_1_AXI_PROTOCOL == "AXI4") 
             ?(C_SLOT_1_AXI_ID_WIDTH*4 +C_SLOT_1_AXI_ADDR_WIDTH*2 +(C_SLOT_1_AXI_DATA_WIDTH/8)+42)
                                    :((C_SLOT_1_AXIS_TDATA_WIDTH/8)*2 + C_SLOT_1_AXIS_TID_WIDTH
                                    +C_SLOT_1_AXIS_TDEST_WIDTH+C_SLOT_1_AXIS_TUSER_WIDTH+3);
  localparam C_MON_FIFO_DWIDTH_S2 = (C_SLOT_2_AXI_PROTOCOL == "AXI4") 
             ?(C_SLOT_2_AXI_ID_WIDTH*4 +C_SLOT_2_AXI_ADDR_WIDTH*2 +(C_SLOT_2_AXI_DATA_WIDTH/8)+42)
                                    :((C_SLOT_2_AXIS_TDATA_WIDTH/8)*2 + C_SLOT_2_AXIS_TID_WIDTH
                                    +C_SLOT_2_AXIS_TDEST_WIDTH+C_SLOT_2_AXIS_TUSER_WIDTH+3);
  localparam C_MON_FIFO_DWIDTH_S3 = (C_SLOT_3_AXI_PROTOCOL == "AXI4") 
             ?C_SLOT_3_AXI_ID_WIDTH*4 +C_SLOT_3_AXI_ADDR_WIDTH*2 +(C_SLOT_3_AXI_DATA_WIDTH/8)+42
                                    :(C_SLOT_3_AXIS_TDATA_WIDTH/8)*2 + C_SLOT_3_AXIS_TID_WIDTH
                                    +C_SLOT_3_AXIS_TDEST_WIDTH + C_SLOT_3_AXIS_TUSER_WIDTH+3;
  localparam C_MON_FIFO_DWIDTH_S4 = (C_SLOT_4_AXI_PROTOCOL == "AXI4") 
            ?(C_SLOT_4_AXI_ID_WIDTH*4 +C_SLOT_4_AXI_ADDR_WIDTH*2 +(C_SLOT_4_AXI_DATA_WIDTH/8)+42)
                                    :((C_SLOT_4_AXIS_TDATA_WIDTH/8)*2 + C_SLOT_4_AXIS_TID_WIDTH
                                    + C_SLOT_4_AXIS_TDEST_WIDTH+C_SLOT_4_AXIS_TUSER_WIDTH+3);
  localparam C_MON_FIFO_DWIDTH_S5 = (C_SLOT_5_AXI_PROTOCOL == "AXI4") 
            ?(C_SLOT_5_AXI_ID_WIDTH*4 +C_SLOT_5_AXI_ADDR_WIDTH*2 +(C_SLOT_5_AXI_DATA_WIDTH/8)+42)
                                    :((C_SLOT_5_AXIS_TDATA_WIDTH/8)*2 + C_SLOT_5_AXIS_TID_WIDTH
                                    +C_SLOT_5_AXIS_TDEST_WIDTH+C_SLOT_5_AXIS_TUSER_WIDTH+3);
  localparam C_MON_FIFO_DWIDTH_S6 = (C_SLOT_6_AXI_PROTOCOL == "AXI4") 
           ?(C_SLOT_6_AXI_ID_WIDTH*4 +C_SLOT_6_AXI_ADDR_WIDTH*2 +(C_SLOT_6_AXI_DATA_WIDTH/8)+42)
                                    :((C_SLOT_6_AXIS_TDATA_WIDTH/8)*2 + C_SLOT_6_AXIS_TID_WIDTH
                                    +C_SLOT_6_AXIS_TDEST_WIDTH+C_SLOT_6_AXIS_TUSER_WIDTH+3);
  localparam C_MON_FIFO_DWIDTH_S7 = (C_SLOT_7_AXI_PROTOCOL == "AXI4") 
           ?C_SLOT_7_AXI_ID_WIDTH*4 +C_SLOT_7_AXI_ADDR_WIDTH*2 +(C_SLOT_7_AXI_DATA_WIDTH/8)+42
                                    :(C_SLOT_7_AXIS_TDATA_WIDTH/8)*2 + C_SLOT_7_AXIS_TID_WIDTH
                                    +C_SLOT_7_AXIS_TDEST_WIDTH + C_SLOT_7_AXIS_TUSER_WIDTH+3;
  
  //-- Flag widths for each monitor slot  
  localparam C_SLOT_0_FLAG_WIDTH = (C_SLOT_0_AXI_PROTOCOL == "AXI4") ? 7 : 2;
  localparam C_SLOT_1_FLAG_WIDTH = (C_SLOT_1_AXI_PROTOCOL == "AXI4") ? 7 : 2;
  localparam C_SLOT_2_FLAG_WIDTH = (C_SLOT_2_AXI_PROTOCOL == "AXI4") ? 7 : 2;
  localparam C_SLOT_3_FLAG_WIDTH = (C_SLOT_3_AXI_PROTOCOL == "AXI4") ? 7 : 2;
  localparam C_SLOT_4_FLAG_WIDTH = (C_SLOT_4_AXI_PROTOCOL == "AXI4") ? 7 : 2;
  localparam C_SLOT_5_FLAG_WIDTH = (C_SLOT_5_AXI_PROTOCOL == "AXI4") ? 7 : 2;
  localparam C_SLOT_6_FLAG_WIDTH = (C_SLOT_6_AXI_PROTOCOL == "AXI4") ? 7 : 2;
  localparam C_SLOT_7_FLAG_WIDTH = (C_SLOT_7_AXI_PROTOCOL == "AXI4") ? 7 : 2;

  //-- Log Data widths for each monitor slot  
   localparam C_SLOT_0_LOG_DATA_WIDTH = (C_SLOT_0_AXI_PROTOCOL == "AXI4")? ((C_EN_AXI_DEBUG) ? (C_SLOT_0_AXI_ADDR_WIDTH*2 +16+4+4) : ((4*C_SLOT_0_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN))): ((C_SLOT_0_AXIS_TID_WIDTH * C_SHOW_AXIS_TID) + (C_SLOT_0_AXIS_TDEST_WIDTH*C_SHOW_AXIS_TDEST) + (C_SLOT_0_AXIS_TUSER_WIDTH*C_SHOW_AXIS_TUSER));  
  localparam C_SLOT_1_LOG_DATA_WIDTH = (C_SLOT_0_AXI_PROTOCOL == "AXI4")? ((C_EN_AXI_DEBUG) ? (C_SLOT_1_AXI_ADDR_WIDTH*2 +16+4+4) : ((4*C_SLOT_1_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN))) : ((C_SLOT_1_AXIS_TID_WIDTH*C_SHOW_AXIS_TID) + (C_SLOT_1_AXIS_TDEST_WIDTH*C_SHOW_AXIS_TDEST) + (C_SLOT_1_AXIS_TUSER_WIDTH*C_SHOW_AXIS_TUSER));  
  localparam C_SLOT_2_LOG_DATA_WIDTH = (C_SLOT_0_AXI_PROTOCOL == "AXI4")? ((C_EN_AXI_DEBUG) ? (C_SLOT_2_AXI_ADDR_WIDTH*2 +16+4+4) : ((4*C_SLOT_2_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN))) : ((C_SLOT_2_AXIS_TID_WIDTH*C_SHOW_AXIS_TID) + (C_SLOT_2_AXIS_TDEST_WIDTH*C_SHOW_AXIS_TDEST) + (C_SLOT_2_AXIS_TUSER_WIDTH*C_SHOW_AXIS_TUSER));  
  localparam C_SLOT_3_LOG_DATA_WIDTH = (C_SLOT_0_AXI_PROTOCOL == "AXI4")? ((C_EN_AXI_DEBUG) ? (C_SLOT_3_AXI_ADDR_WIDTH*2 +16+4+4) : ((4*C_SLOT_3_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN))) : (C_SLOT_3_AXIS_TID_WIDTH*C_SHOW_AXIS_TID  + C_SLOT_3_AXIS_TDEST_WIDTH*C_SHOW_AXIS_TDEST + C_SLOT_3_AXIS_TUSER_WIDTH*C_SHOW_AXIS_TUSER);  
  localparam C_SLOT_4_LOG_DATA_WIDTH = (C_SLOT_0_AXI_PROTOCOL == "AXI4")? ((C_EN_AXI_DEBUG) ? (C_SLOT_4_AXI_ADDR_WIDTH*2 +16+4+4) : ((4*C_SLOT_4_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN))) : ((C_SLOT_4_AXIS_TID_WIDTH*C_SHOW_AXIS_TID)  + (C_SLOT_4_AXIS_TDEST_WIDTH*C_SHOW_AXIS_TDEST) + (C_SLOT_4_AXIS_TUSER_WIDTH*C_SHOW_AXIS_TUSER));  
  localparam C_SLOT_5_LOG_DATA_WIDTH = (C_SLOT_0_AXI_PROTOCOL == "AXI4")? ((C_EN_AXI_DEBUG) ? (C_SLOT_5_AXI_ADDR_WIDTH*2 +16+4+4) : ((4*C_SLOT_5_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN))) : ((C_SLOT_5_AXIS_TID_WIDTH*C_SHOW_AXIS_TID) + (C_SLOT_5_AXIS_TDEST_WIDTH*C_SHOW_AXIS_TDEST) +(C_SLOT_5_AXIS_TUSER_WIDTH*C_SHOW_AXIS_TUSER));  
  //localparam C_SLOT_6_LOG_DATA_WIDTH = (4*C_SLOT_6_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN);  
  //localparam C_SLOT_7_LOG_DATA_WIDTH = (4*C_SLOT_7_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN);  

//  localparam C_SLOT_0_LOG_DATA_WIDTH = (C_SLOT_0_AXI_PROTOCOL == "AXI4")?  
//                                       ((4*C_SLOT_0_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN)): 
//         ((C_SLOT_0_AXIS_TID_WIDTH * C_SHOW_AXIS_TID) + (C_SLOT_0_AXIS_TDEST_WIDTH*C_SHOW_AXIS_TDEST) + 
//         (C_SLOT_0_AXIS_TUSER_WIDTH*C_SHOW_AXIS_TUSER));
//                                       
//  localparam C_SLOT_1_LOG_DATA_WIDTH = (C_SLOT_1_AXI_PROTOCOL == "AXI4")? 
//                                       ((4*C_SLOT_1_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN)): 
//          ((C_SLOT_1_AXIS_TID_WIDTH*C_SHOW_AXIS_TID) + (C_SLOT_1_AXIS_TDEST_WIDTH*C_SHOW_AXIS_TDEST) + 
//          (C_SLOT_1_AXIS_TUSER_WIDTH*C_SHOW_AXIS_TUSER));
//
//  localparam C_SLOT_2_LOG_DATA_WIDTH = (C_SLOT_2_AXI_PROTOCOL == "AXI4")?  
//                                       ((4*C_SLOT_2_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN)):
//          ((C_SLOT_2_AXIS_TID_WIDTH*C_SHOW_AXIS_TID) + (C_SLOT_2_AXIS_TDEST_WIDTH*C_SHOW_AXIS_TDEST) + 
//          (C_SLOT_2_AXIS_TUSER_WIDTH*C_SHOW_AXIS_TUSER));
//
//  localparam C_SLOT_3_LOG_DATA_WIDTH = (C_SLOT_3_AXI_PROTOCOL == "AXI4")?  
//                                       ((4*C_SLOT_3_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN)):
//          (C_SLOT_3_AXIS_TID_WIDTH*C_SHOW_AXIS_TID  + C_SLOT_3_AXIS_TDEST_WIDTH*C_SHOW_AXIS_TDEST + 
//          C_SLOT_3_AXIS_TUSER_WIDTH*C_SHOW_AXIS_TUSER);
// 
//  localparam C_SLOT_4_LOG_DATA_WIDTH = (C_SLOT_4_AXI_PROTOCOL == "AXI4")?  
//                                       ((4*C_SLOT_4_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN)):
//         ((C_SLOT_4_AXIS_TID_WIDTH*C_SHOW_AXIS_TID)  + (C_SLOT_4_AXIS_TDEST_WIDTH*C_SHOW_AXIS_TDEST) + 
//         (C_SLOT_4_AXIS_TUSER_WIDTH*C_SHOW_AXIS_TUSER));
//
//  localparam C_SLOT_5_LOG_DATA_WIDTH = (C_SLOT_5_AXI_PROTOCOL == "AXI4")?  
//                                       ((4*C_SLOT_5_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN)):
//         ((C_SLOT_5_AXIS_TID_WIDTH*C_SHOW_AXIS_TID) + (C_SLOT_5_AXIS_TDEST_WIDTH*C_SHOW_AXIS_TDEST) + 
//         (C_SLOT_5_AXIS_TUSER_WIDTH*C_SHOW_AXIS_TUSER));
// 
 localparam C_SLOT_6_LOG_DATA_WIDTH = (C_SLOT_6_AXI_PROTOCOL == "AXI4")  
                                       ? ((4*C_SLOT_6_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN)):
         ((C_SLOT_6_AXIS_TID_WIDTH*C_SHOW_AXIS_TID)  + (C_SLOT_6_AXIS_TDEST_WIDTH*C_SHOW_AXIS_TDEST) + 
         (C_SLOT_6_AXIS_TUSER_WIDTH*C_SHOW_AXIS_TUSER));
                                        
 localparam C_SLOT_7_LOG_DATA_WIDTH = (C_SLOT_7_AXI_PROTOCOL == "AXI4")  
                                       ? ((4*C_SLOT_7_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN)):
         ((C_SLOT_7_AXIS_TID_WIDTH*C_SHOW_AXIS_TID)  + (C_SLOT_7_AXIS_TDEST_WIDTH*C_SHOW_AXIS_TDEST) + 
         (C_SLOT_7_AXIS_TUSER_WIDTH*C_SHOW_AXIS_TUSER));
 
  localparam C_SLOT_0_LOG_WIDTH = C_SLOT_0_LOG_DATA_WIDTH + C_SLOT_0_FLAG_WIDTH;
  localparam C_SLOT_1_LOG_WIDTH = C_SLOT_1_LOG_DATA_WIDTH + C_SLOT_1_FLAG_WIDTH;
  localparam C_SLOT_2_LOG_WIDTH = C_SLOT_2_LOG_DATA_WIDTH + C_SLOT_2_FLAG_WIDTH;
  localparam C_SLOT_3_LOG_WIDTH = C_SLOT_3_LOG_DATA_WIDTH + C_SLOT_3_FLAG_WIDTH;
  localparam C_SLOT_4_LOG_WIDTH = C_SLOT_4_LOG_DATA_WIDTH + C_SLOT_4_FLAG_WIDTH;
  localparam C_SLOT_5_LOG_WIDTH = C_SLOT_5_LOG_DATA_WIDTH + C_SLOT_5_FLAG_WIDTH;
  localparam C_SLOT_6_LOG_WIDTH = C_SLOT_6_LOG_DATA_WIDTH + C_SLOT_6_FLAG_WIDTH;
  localparam C_SLOT_7_LOG_WIDTH = C_SLOT_7_LOG_DATA_WIDTH + C_SLOT_7_FLAG_WIDTH;
  
  localparam C_MAX_OUTSTAND_DEPTH = 32;

   /*---------------------------------------------------------------------
   -----------------------wire/connection declarations-------------------------
   ------------------------------------------------------------------------*/
  wire  [(C_S_AXI_ADDR_WIDTH - 1):0]   Bus2IP_Addr          ;
  wire  [(C_S_AXI_DATA_WIDTH - 1):0]   Bus2IP_Data          ;
  wire  [(C_S_AXI_DATA_WIDTH/8 - 1):0] Bus2IP_BE            ;
  wire                                 Bus2IP_Burst         ;
  wire                                 Bus2IP_RdCE          ;
  wire                                 Bus2IP_WrCE          ;
  wire  [(C_S_AXI_DATA_WIDTH - 1):0]   IP2Bus_Data          ;
  wire                                 IP2Bus_DataValid     ;
  wire                                 IP2Bus_Error         ;
  wire  [C_GLOBAL_COUNT_WIDTH-1:0]     Global_Clk_Cnt       ;
  wire  [(C_METRICS_SAMPLE_COUNT_WIDTH - 1):0] Sample_Interval;    
  wire  [(C_METRICS_SAMPLE_COUNT_WIDTH - 1):0] Sample_Interval_Cnt;    
  wire                                 Interval_Cnt_En      ;
  wire                                 Interval_Cnt_Ld      ;
  wire                                 Sample_Interval_Cnt_Lapse      ;
  wire                                 Reset_On_Sample_Int_Lapse;
  wire                                 Global_Intr_En       ;
  wire                                 Intr_Reg_IER_Wr_En   ;
  wire                                 Intr_Reg_ISR_Wr_En   ;
  wire [(C_NUM_INTR_INPUTS - 1):0]     Intr_Reg_IER         ;   
  wire [(C_NUM_INTR_INPUTS - 1):0]     Intr_Reg_ISR         ;    
  wire                                 eventlog_rd_clk         ;    
  wire                                 eventlog_rd_rstn         ;    
  wire [31:0]                          eventlog_cur_cnt         ;    
  wire [7:0]                           Metric_Sel_0;    
  wire [7:0]                           Metric_Sel_1;    
  wire [7:0]                           Metric_Sel_2;    
  wire [7:0]                           Metric_Sel_3;    
  wire [7:0]                           Metric_Sel_4;    
  wire [7:0]                           Metric_Sel_5;    
  wire [7:0]                           Metric_Sel_6;    
  wire [7:0]                           Metric_Sel_7;    
  wire [7:0]                           Metric_Sel_8;    
  wire [7:0]                           Metric_Sel_9;    
  wire [31:0]                          Metric_Cnt_0;    
  wire [31:0]                          Metric_Cnt_1;    
  wire [31:0]                          Metric_Cnt_2;    
  wire [31:0]                          Metric_Cnt_3;    
  wire [31:0]                          Metric_Cnt_4;    
  wire [31:0]                          Metric_Cnt_5;    
  wire [31:0]                          Metric_Cnt_6;    
  wire [31:0]                          Metric_Cnt_7;    
  wire [31:0]                          Metric_Cnt_8;    
  wire [31:0]                          Metric_Cnt_9;    
  wire [31:0]                          Incrementer_0;    
  wire [31:0]                          Incrementer_1;    
  wire [31:0]                          Incrementer_2;    
  wire [31:0]                          Incrementer_3;    
  wire [31:0]                          Incrementer_4;    
  wire [31:0]                          Incrementer_5;    
  wire [31:0]                          Incrementer_6;    
  wire [31:0]                          Incrementer_7;    
  wire [31:0]                          Incrementer_8;    
  wire [31:0]                          Incrementer_9;    
  wire [31:0]                          Samp_Metric_Cnt_0;    
  wire [31:0]                          Samp_Metric_Cnt_1;    
  wire [31:0]                          Samp_Metric_Cnt_2;    
  wire [31:0]                          Samp_Metric_Cnt_3;    
  wire [31:0]                          Samp_Metric_Cnt_4;    
  wire [31:0]                          Samp_Metric_Cnt_5;    
  wire [31:0]                          Samp_Metric_Cnt_6;    
  wire [31:0]                          Samp_Metric_Cnt_7;    
  wire [31:0]                          Samp_Metric_Cnt_8;    
  wire [31:0]                          Samp_Metric_Cnt_9;    
  wire [31:0]                          Samp_Incrementer_0;    
  wire [31:0]                          Samp_Incrementer_1;    
  wire [31:0]                          Samp_Incrementer_2;    
  wire [31:0]                          Samp_Incrementer_3;    
  wire [31:0]                          Samp_Incrementer_4;    
  wire [31:0]                          Samp_Incrementer_5;    
  wire [31:0]                          Samp_Incrementer_6;    
  wire [31:0]                          Samp_Incrementer_7;    
  wire [31:0]                          Samp_Incrementer_8;    
  wire [31:0]                          Samp_Incrementer_9;    
  wire [31:0]                          Range_Reg_0;    
  wire [31:0]                          Range_Reg_1;    
  wire [31:0]                          Range_Reg_2;    
  wire [31:0]                          Range_Reg_3;    
  wire [31:0]                          Range_Reg_4;    
  wire [31:0]                          Range_Reg_5;    
  wire [31:0]                          Range_Reg_6;    
  wire [31:0]                          Range_Reg_7;    
  wire [31:0]                          Range_Reg_8;    
  wire [31:0]                          Range_Reg_9;    
  wire [6:0]                           Flag_Enable_Reg;    
  wire                                 SW_Data_Log_En;    
  wire [C_SW_SYNC_DATA_WIDTH-1:0]      SW_Data;    
  wire                                 SW_Data_Wr_En;    
  wire                                 Streaming_FIFO_Reset;
  wire                                 Event_Log_En;
  wire                                 Count_Event_Log_En;
  wire                                 Metrics_Cnt_En;
  wire                                 Metrics_Cnt_Reset;
  wire                                 Global_Clk_Cnt_OF    ;
  wire                                 Global_Clk_Cnt_En    ;
  wire                                 Global_Clk_Cnt_Reset ;
  wire  [10:0]                         Control_Bits_sync  ;
  wire [(C_NUM_INTR_INPUTS - 1):0]     Intr_In             ;    
  wire [(C_NUM_INTR_INPUTS - 1):0]     Intr_In_sync        ;    

  wire  [C_SLOT_0_LOG_WIDTH-1:0]       Slot_0_Log;
  wire  [C_SLOT_1_LOG_WIDTH-1:0]       Slot_1_Log;
  wire  [C_SLOT_2_LOG_WIDTH-1:0]       Slot_2_Log;
  wire  [C_SLOT_3_LOG_WIDTH-1:0]       Slot_3_Log;
  wire  [C_SLOT_4_LOG_WIDTH-1:0]       Slot_4_Log;
  wire  [C_SLOT_5_LOG_WIDTH-1:0]       Slot_5_Log;
  wire  [C_SLOT_6_LOG_WIDTH-1:0]       Slot_6_Log;
  wire  [C_SLOT_7_LOG_WIDTH-1:0]       Slot_7_Log;
  // Start and End point marked data
  wire 	  Slot_0_Log_En_Marked;
  wire [C_SLOT_0_LOG_WIDTH-1:0] Slot_0_Log_Marked;
  wire 	  Slot_1_Log_En_Marked;
  wire [C_SLOT_1_LOG_WIDTH-1:0] Slot_1_Log_Marked;
  wire 	  Slot_2_Log_En_Marked;
  wire [C_SLOT_2_LOG_WIDTH-1:0] Slot_2_Log_Marked;
  wire 	  Slot_3_Log_En_Marked;
  wire [C_SLOT_3_LOG_WIDTH-1:0] Slot_3_Log_Marked;
  wire 	  Slot_4_Log_En_Marked;
  wire [C_SLOT_4_LOG_WIDTH-1:0] Slot_4_Log_Marked;
  wire 	  Slot_5_Log_En_Marked;
  wire [C_SLOT_5_LOG_WIDTH-1:0] Slot_5_Log_Marked;

  // Streaming FIFO connections
  wire                                 Streaming_Fifo_Full   ;
  reg                                  Streaming_Fifo_Full_D1;
  wire                                 Streaming_Fifo_Full_Edge;
  wire                                 Streaming_Fifo_Empty  ;
  wire                                 Streaming_Fifo_Wr_En  ;
  wire  [C_FIFO_AXIS_TDATA_WIDTH-1:0]  Streaming_Fifo_Wr_Data;

  // Event Monitor Fifo connections
  wire [2:0]                           Ext_Event0_Data_In;
  wire [2:0]                           Ext_Event1_Data_In;
  wire [2:0]                           Ext_Event2_Data_In;
  wire [2:0]                           Ext_Event3_Data_In;
  wire [2:0]                           Ext_Event4_Data_In;
  wire [2:0]                           Ext_Event5_Data_In;
  wire [2:0]                           Ext_Event6_Data_In;
  wire [2:0]                           Ext_Event7_Data_In;
  wire [2:0]                           Ext_Event0_Sync_Data_Out;
  wire                                 Ext_Event0_Sync_Data_Valid;
  wire [2:0]                           Ext_Event1_Sync_Data_Out;
  wire                                 Ext_Event1_Sync_Data_Valid;
  wire [2:0]                           Ext_Event2_Sync_Data_Out;
  wire                                 Ext_Event2_Sync_Data_Valid;
  wire [2:0]                           Ext_Event3_Sync_Data_Out;
  wire                                 Ext_Event3_Sync_Data_Valid;
  wire [2:0]                           Ext_Event4_Sync_Data_Out;
  wire                                 Ext_Event4_Sync_Data_Valid;
  wire [2:0]                           Ext_Event5_Sync_Data_Out;
  wire                                 Ext_Event5_Sync_Data_Valid;
  wire [2:0]                           Ext_Event6_Sync_Data_Out;
  wire                                 Ext_Event6_Sync_Data_Valid;
  wire [2:0]                           Ext_Event7_Sync_Data_Out;
  wire                                 Ext_Event7_Sync_Data_Valid;
  
  wire                                 SLOT_0_clk;
  wire                                 SLOT_0_Arst_n;
  wire [C_MON_FIFO_DWIDTH_S0-1:0]      Slot_0_Data_In;
  wire [C_MON_FIFO_DWIDTH_S0-1:0]      Slot_0_Sync_Data_Out;
  wire                                 Slot_0_Sync_Data_Valid;
  wire                                 SLOT_1_clk;
  wire                                 SLOT_1_Arst_n;
  wire [C_MON_FIFO_DWIDTH_S1-1:0]      Slot_1_Data_In;
  wire [C_MON_FIFO_DWIDTH_S1-1:0]      Slot_1_Sync_Data_Out;
  wire                                 Slot_1_Sync_Data_Valid;
  wire                                 SLOT_2_clk;
  wire                                 SLOT_2_Arst_n;
  wire [C_MON_FIFO_DWIDTH_S2-1:0]      Slot_2_Data_In;
  wire [C_MON_FIFO_DWIDTH_S2-1:0]      Slot_2_Sync_Data_Out;
  wire                                 Slot_2_Sync_Data_Valid;
  wire                                 SLOT_3_clk;
  wire                                 SLOT_3_Arst_n;
  wire [C_MON_FIFO_DWIDTH_S3-1:0]      Slot_3_Data_In;
  wire [C_MON_FIFO_DWIDTH_S3-1:0]      Slot_3_Sync_Data_Out;
  wire                                 Slot_3_Sync_Data_Valid;
  wire                                 SLOT_4_clk;
  wire                                 SLOT_4_Arst_n;
  wire [C_MON_FIFO_DWIDTH_S4-1:0]      Slot_4_Data_In;
  wire [C_MON_FIFO_DWIDTH_S4-1:0]      Slot_4_Sync_Data_Out;
  wire                                 Slot_4_Sync_Data_Valid;
  wire                                 SLOT_5_clk;
  wire                                 SLOT_5_Arst_n;
  wire [C_MON_FIFO_DWIDTH_S5-1:0]      Slot_5_Data_In;
  wire [C_MON_FIFO_DWIDTH_S5-1:0]      Slot_5_Sync_Data_Out;
  wire                                 Slot_5_Sync_Data_Valid;
  wire                                 SLOT_6_clk;
  wire                                 SLOT_6_Arst_n;
  wire [C_MON_FIFO_DWIDTH_S6-1:0]      Slot_6_Data_In;
  wire [C_MON_FIFO_DWIDTH_S6-1:0]      Slot_6_Sync_Data_Out;
  wire                                 Slot_6_Sync_Data_Valid;
  wire                                 SLOT_7_clk;
  wire                                 SLOT_7_Arst_n;
  wire [C_MON_FIFO_DWIDTH_S7-1:0]      Slot_7_Data_In;
  wire [C_MON_FIFO_DWIDTH_S7-1:0]      Slot_7_Sync_Data_Out;
  wire                                 Slot_7_Sync_Data_Valid;
  //Metric counter connections 
  wire                                 Metrics_Cnt_En_sync       ; 
  wire                                 Metrics_Cnt_Reset_sync    ; 
  wire                                 Event_Log_En_sync         ; 
  wire                                 Global_Clk_Cnt_En_sync    ; 
  wire                                 Global_Clk_Cnt_Reset_sync ; 
  wire                                 Streaming_FIFO_Reset_sync ; 
  wire                                 Interval_Cnt_Ld_sync ; 
  wire                                 Interval_Cnt_En_sync ; 
  wire                                 Reset_On_Sample_Int_Lapse_sync ; 
  wire                                 Global_Clk_Cnt_Ovf_En_sync;
  wire                                 Sample_Metric_Cnt_Ovf_En_sync;

  // 8 monitor slots metric count enables

  wire [C_NUM_MONITOR_SLOTS-1:0]       Wtrans_Cnt_En;
  wire [C_NUM_MONITOR_SLOTS-1:0]       Rtrans_Cnt_En;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_Write_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_Write_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_Write_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_Write_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_Write_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_Write_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_Write_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_Write_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_Read_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_Read_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_Read_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_Read_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_Read_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_Read_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_Read_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_Read_Byte_Cnt;
  wire                                 S0_Read_Byte_Cnt_En;
  wire                                 S1_Read_Byte_Cnt_En;
  wire                                 S2_Read_Byte_Cnt_En;
  wire                                 S3_Read_Byte_Cnt_En;
  wire                                 S4_Read_Byte_Cnt_En;
  wire                                 S5_Read_Byte_Cnt_En;
  wire                                 S6_Read_Byte_Cnt_En;
  wire                                 S7_Read_Byte_Cnt_En;
  wire [C_NUM_MONITOR_SLOTS-1:0]       Write_Beat_Cnt_En;
  wire [C_NUM_MONITOR_SLOTS-1:0]       Read_Beat_Cnt_En;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_Write_Beat_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_Write_Beat_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_Write_Beat_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_Write_Beat_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_Write_Beat_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_Write_Beat_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_Write_Beat_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_Write_Beat_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_Slv_Wr_Idle_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_Slv_Wr_Idle_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_Slv_Wr_Idle_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_Slv_Wr_Idle_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_Slv_Wr_Idle_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_Slv_Wr_Idle_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_Slv_Wr_Idle_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_Slv_Wr_Idle_Cnt;
  wire [C_NUM_MONITOR_SLOTS-1:0]       Read_Latency_En;
  wire [C_NUM_MONITOR_SLOTS-1:0]       Write_Latency_En;
  wire [C_NUM_MONITOR_SLOTS-1:0]       Slv_Wr_Idle_Cnt_En;        
  wire [C_NUM_MONITOR_SLOTS-1:0]       Mst_Rd_Idle_Cnt_En;        
  wire [C_NUM_MONITOR_SLOTS-1:0]       Num_BValids_En;       
  wire [C_NUM_MONITOR_SLOTS-1:0]       Num_WLasts_En;             
  wire [C_NUM_MONITOR_SLOTS-1:0]       Num_RLasts_En;      
  //AXI Streaming metrics
  wire [C_NUM_MONITOR_SLOTS-1:0]       S_Transfer_Cnt_En;
  wire [C_NUM_MONITOR_SLOTS-1:0]       S_Packet_Cnt_En;  
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_S_Data_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_S_Data_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_S_Data_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_S_Data_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_S_Data_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_S_Data_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_S_Data_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_S_Data_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_S_Position_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_S_Position_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_S_Position_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_S_Position_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_S_Position_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_S_Position_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_S_Position_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_S_Position_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_S_Null_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_S_Null_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_S_Null_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_S_Null_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_S_Null_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_S_Null_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_S_Null_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_S_Null_Byte_Cnt;
  wire [C_NUM_MONITOR_SLOTS-1:0]       S_Slv_Idle_Cnt_En;
  wire [C_NUM_MONITOR_SLOTS-1:0]       S_Mst_Idle_Cnt_En;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_Slv_Idle_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_Slv_Idle_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_Slv_Idle_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_Slv_Idle_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_Slv_Idle_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_Slv_Idle_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_Slv_Idle_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_Slv_Idle_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_Max_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_Max_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_Max_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_Max_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_Max_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_Max_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_Max_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_Max_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_Min_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_Min_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_Min_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_Min_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_Min_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_Min_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_Min_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_Min_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_Max_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_Max_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_Max_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_Max_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_Max_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_Max_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_Max_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_Max_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_Min_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_Min_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_Min_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_Min_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_Min_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_Min_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_Min_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_Min_Read_Latency;

  //External Events
  wire [C_NUM_MONITOR_SLOTS-1:0]       External_Event_Cnt_En;
  wire [2:0]                           Ext_Event0_Flags;
  wire [2:0]                           Ext_Event1_Flags;
  wire [2:0]                           Ext_Event2_Flags;
  wire [2:0]                           Ext_Event3_Flags;
  wire [2:0]                           Ext_Event4_Flags;
  wire [2:0]                           Ext_Event5_Flags;
  wire [2:0]                           Ext_Event6_Flags;
  wire [2:0]                           Ext_Event7_Flags;
  wire [2:0]                           Ext_Event_Flag_En;
 
  // Accumulator signals
  wire                                 Acc_OF_0;    
  wire                                 Acc_OF_1;    
  wire                                 Acc_OF_2;    
  wire                                 Acc_OF_3;    
  wire                                 Acc_OF_4;    
  wire                                 Acc_OF_5;    
  wire                                 Acc_OF_6;    
  wire                                 Acc_OF_7;    
  wire                                 Acc_OF_8;    
  wire                                 Acc_OF_9;    
  // Incrementor signals
  wire                                 Incr_OF_0;    
  wire                                 Incr_OF_1;    
  wire                                 Incr_OF_2;    
  wire                                 Incr_OF_3;    
  wire                                 Incr_OF_4;    
  wire                                 Incr_OF_5;    
  wire                                 Incr_OF_6;    
  wire                                 Incr_OF_7;    
  wire                                 Incr_OF_8;    
  wire                                 Incr_OF_9;    
  wire                                 Use_Ext_Trig;
  wire                                 Use_Ext_Trig_sync;
  wire                                 Use_Ext_Trig_Log;
  wire                                 Use_Ext_Trig_Log_sync;
  wire                                 Global_Cnt_Event_Log_En; 
  wire                                 Sample_Cnt_Event_Log_En; 

  //Flag generator log enables
  wire                                 Slot_0_Log_En;
  wire                                 Slot_1_Log_En;
  wire                                 Slot_2_Log_En;
  wire                                 Slot_3_Log_En;
  wire                                 Slot_4_Log_En;
  wire                                 Slot_5_Log_En;
  wire                                 Slot_6_Log_En;
  wire                                 Slot_7_Log_En;

  // Latency ID register connections
  wire [15:0]                          Latency_WID;
  wire [15:0]                          Latency_RID;
  wire [15:0]                          WID_Mask;
  wire [15:0]                          RID_Mask;
  wire                                 En_Id_Based;
  wire                                 En_Id_Based_sync;
   /*-------------Generate Monitor fifo data input -------------------*/

  generate if(C_SLOT_0_AXI_PROTOCOL == "AXI4") begin :GEN_SLOT_0_AXI4
    assign SLOT_0_clk    = slot_0_axi_aclk;
    assign SLOT_0_Arst_n = slot_0_axi_aresetn;
    assign Slot_0_Data_In = {slot_0_axi_awid,slot_0_axi_awaddr,slot_0_axi_awlen,slot_0_axi_awsize,
                            slot_0_axi_awburst,slot_0_axi_awvalid,slot_0_axi_awready,
                            slot_0_axi_wstrb,slot_0_axi_wlast,slot_0_axi_wvalid,slot_0_axi_wready,
                            slot_0_axi_bid,slot_0_axi_bresp,slot_0_axi_bvalid,slot_0_axi_bready,
                            slot_0_axi_arid,slot_0_axi_araddr,slot_0_axi_arlen,slot_0_axi_arsize,
                            slot_0_axi_arburst,slot_0_axi_arvalid,slot_0_axi_arready,slot_0_axi_rid,
                            slot_0_axi_rresp,slot_0_axi_rlast,slot_0_axi_rvalid,slot_0_axi_rready};
  end 
  else if(C_SLOT_0_AXI_PROTOCOL == "AXI4S") begin :GEN_SLOT_0_AXI4S
    assign SLOT_0_clk    = slot_0_axis_aclk;
    assign SLOT_0_Arst_n = slot_0_axis_aresetn;
    assign Slot_0_Data_In = {slot_0_axis_tvalid,slot_0_axis_tready,slot_0_axis_tstrb,
                            slot_0_axis_tkeep,slot_0_axis_tlast,slot_0_axis_tid,
                            slot_0_axis_tdest,slot_0_axis_tuser}; 
  end
  endgenerate

  generate if(C_SLOT_1_AXI_PROTOCOL == "AXI4" && C_NUM_MONITOR_SLOTS > 1) begin :GEN_SLOT_1_AXI4
    assign SLOT_1_clk    = slot_1_axi_aclk;
    assign SLOT_1_Arst_n = slot_1_axi_aresetn;
    assign Slot_1_Data_In = {slot_1_axi_awid,slot_1_axi_awaddr,slot_1_axi_awlen,slot_1_axi_awsize,
                            slot_1_axi_awburst,slot_1_axi_awvalid,slot_1_axi_awready,
                            slot_1_axi_wstrb,slot_1_axi_wlast,slot_1_axi_wvalid,slot_1_axi_wready,
                            slot_1_axi_bid,slot_1_axi_bresp,slot_1_axi_bvalid,slot_1_axi_bready,
                            slot_1_axi_arid,slot_1_axi_araddr,slot_1_axi_arlen,slot_1_axi_arsize,
                            slot_1_axi_arburst,slot_1_axi_arvalid,slot_1_axi_arready,slot_1_axi_rid,
                            slot_1_axi_rresp,slot_1_axi_rlast,slot_1_axi_rvalid,slot_1_axi_rready};

  end
  else if(C_SLOT_1_AXI_PROTOCOL == "AXI4S" && C_NUM_MONITOR_SLOTS > 1) begin :GEN_SLOT_1_AXI4S
    assign SLOT_1_clk    = slot_1_axis_aclk;
    assign SLOT_1_Arst_n = slot_1_axis_aresetn;
    assign Slot_1_Data_In = {slot_1_axis_tvalid,slot_1_axis_tready,slot_1_axis_tstrb,
                            slot_1_axis_tkeep,slot_1_axis_tlast,slot_1_axis_tid,
                            slot_1_axis_tdest,slot_1_axis_tuser}; 
  end
  endgenerate

  generate if(C_SLOT_2_AXI_PROTOCOL == "AXI4" && C_NUM_MONITOR_SLOTS > 2) begin :GEN_SLOT_2_AXI4
    assign SLOT_2_clk    = slot_2_axi_aclk;
    assign SLOT_2_Arst_n = slot_2_axi_aresetn;
    assign Slot_2_Data_In = {slot_2_axi_awid,slot_2_axi_awaddr,slot_2_axi_awlen,slot_2_axi_awsize,
                            slot_2_axi_awburst,slot_2_axi_awvalid,slot_2_axi_awready,
                            slot_2_axi_wstrb,slot_2_axi_wlast,slot_2_axi_wvalid,slot_2_axi_wready,
                            slot_2_axi_bid,slot_2_axi_bresp,slot_2_axi_bvalid,slot_2_axi_bready,
                            slot_2_axi_arid,slot_2_axi_araddr,slot_2_axi_arlen,slot_2_axi_arsize,
                            slot_2_axi_arburst,slot_2_axi_arvalid,slot_2_axi_arready,slot_2_axi_rid,
                            slot_2_axi_rresp,slot_2_axi_rlast,slot_2_axi_rvalid,slot_2_axi_rready};
  end
  else if(C_SLOT_2_AXI_PROTOCOL == "AXI4S" && C_NUM_MONITOR_SLOTS > 2) begin :GEN_SLOT_2_AXI4S
    assign SLOT_2_clk    = slot_2_axis_aclk;
    assign SLOT_2_Arst_n = slot_2_axis_aresetn;
    assign Slot_2_Data_In = {slot_2_axis_tvalid,slot_2_axis_tready,slot_2_axis_tstrb,
                            slot_2_axis_tkeep,slot_2_axis_tlast,slot_2_axis_tid,
                            slot_2_axis_tdest,slot_2_axis_tuser};
  end
  endgenerate

  generate if(C_SLOT_3_AXI_PROTOCOL == "AXI4" && C_NUM_MONITOR_SLOTS > 3) begin :GEN_SLOT_3_AXI4
    assign SLOT_3_clk    = slot_3_axi_aclk;
    assign SLOT_3_Arst_n = slot_3_axi_aresetn;
    assign Slot_3_Data_In = {slot_3_axi_awid,slot_3_axi_awaddr,slot_3_axi_awlen,slot_3_axi_awsize,
                            slot_3_axi_awburst,slot_3_axi_awvalid,slot_3_axi_awready,
                            slot_3_axi_wstrb,slot_3_axi_wlast,slot_3_axi_wvalid,slot_3_axi_wready,
                            slot_3_axi_bid,slot_3_axi_bresp,slot_3_axi_bvalid,slot_3_axi_bready,
                            slot_3_axi_arid,slot_3_axi_araddr,slot_3_axi_arlen,slot_3_axi_arsize,
                            slot_3_axi_arburst,slot_3_axi_arvalid,slot_3_axi_arready,slot_3_axi_rid,
                            slot_3_axi_rresp,slot_3_axi_rlast,slot_3_axi_rvalid,slot_3_axi_rready};

  end
  else if(C_SLOT_3_AXI_PROTOCOL == "AXI4S" && C_NUM_MONITOR_SLOTS > 3) begin :GEN_SLOT_3_AXI4S
    assign SLOT_3_clk    = slot_3_axis_aclk;
    assign SLOT_3_Arst_n = slot_3_axis_aresetn;
    assign Slot_3_Data_In = {slot_3_axis_tvalid,slot_3_axis_tready,slot_3_axis_tstrb,
                            slot_3_axis_tkeep,slot_3_axis_tlast,slot_3_axis_tid,
                            slot_3_axis_tdest,slot_3_axis_tuser};
  end
  endgenerate

  generate if(C_SLOT_4_AXI_PROTOCOL == "AXI4" && C_NUM_MONITOR_SLOTS > 4) begin :GEN_SLOT_4_AXI4
    assign SLOT_4_clk    = slot_4_axi_aclk;
    assign SLOT_4_Arst_n = slot_4_axi_aresetn;
    assign Slot_4_Data_In = {slot_4_axi_awid,slot_4_axi_awaddr,slot_4_axi_awlen,slot_4_axi_awsize,
                            slot_4_axi_awburst,slot_4_axi_awvalid,slot_4_axi_awready,
                            slot_4_axi_wstrb,slot_4_axi_wlast,slot_4_axi_wvalid,slot_4_axi_wready,
                            slot_4_axi_bid,slot_4_axi_bresp,slot_4_axi_bvalid,slot_4_axi_bready,
                            slot_4_axi_arid,slot_4_axi_araddr,slot_4_axi_arlen,slot_4_axi_arsize,
                            slot_4_axi_arburst,slot_4_axi_arvalid,slot_4_axi_arready,slot_4_axi_rid,
                            slot_4_axi_rresp,slot_4_axi_rlast,slot_4_axi_rvalid,slot_4_axi_rready};
  end
  else if(C_SLOT_4_AXI_PROTOCOL == "AXI4S" && C_NUM_MONITOR_SLOTS > 4) begin :GEN_SLOT_4_AXI4S
    assign SLOT_4_clk    = slot_4_axis_aclk;
    assign SLOT_4_Arst_n = slot_4_axis_aresetn;
    assign Slot_4_Data_In = {slot_4_axis_tvalid,slot_4_axis_tready,slot_4_axis_tstrb,
                            slot_4_axis_tkeep,slot_4_axis_tlast,slot_4_axis_tid,
                            slot_4_axis_tdest,slot_4_axis_tuser};
  end
  endgenerate

  generate if(C_SLOT_5_AXI_PROTOCOL == "AXI4" && C_NUM_MONITOR_SLOTS > 5) begin :GEN_SLOT_5_AXI4
    assign SLOT_5_clk    = slot_5_axi_aclk;
    assign SLOT_5_Arst_n = slot_5_axi_aresetn;
    assign Slot_5_Data_In = {slot_5_axi_awid,slot_5_axi_awaddr,slot_5_axi_awlen,slot_5_axi_awsize,
                            slot_5_axi_awburst,slot_5_axi_awvalid,slot_5_axi_awready,
                            slot_5_axi_wstrb,slot_5_axi_wlast,slot_5_axi_wvalid,slot_5_axi_wready,
                            slot_5_axi_bid,slot_5_axi_bresp,slot_5_axi_bvalid,slot_5_axi_bready,
                            slot_5_axi_arid,slot_5_axi_araddr,slot_5_axi_arlen,slot_5_axi_arsize,
                            slot_5_axi_arburst,slot_5_axi_arvalid,slot_5_axi_arready,slot_5_axi_rid,
                            slot_5_axi_rresp,slot_5_axi_rlast,slot_5_axi_rvalid,slot_5_axi_rready};

  end
  else if(C_SLOT_5_AXI_PROTOCOL == "AXI4S" && C_NUM_MONITOR_SLOTS > 5) begin :GEN_SLOT_5_AXI4S
    assign SLOT_5_clk    = slot_5_axis_aclk;
    assign SLOT_5_Arst_n = slot_5_axis_aresetn;
    assign Slot_5_Data_In = {slot_5_axis_tvalid,slot_5_axis_tready,slot_5_axis_tstrb,
                            slot_5_axis_tkeep,slot_5_axis_tlast,slot_5_axis_tid,
                            slot_5_axis_tdest,slot_5_axis_tuser};
  end
  endgenerate

  generate if(C_SLOT_6_AXI_PROTOCOL == "AXI4" && C_NUM_MONITOR_SLOTS > 6) begin :GEN_SLOT_6_AXI4
    assign SLOT_6_clk    = slot_6_axi_aclk;
    assign SLOT_6_Arst_n = slot_6_axi_aresetn;
    assign Slot_6_Data_In = {slot_6_axi_awid,slot_6_axi_awaddr,slot_6_axi_awlen,slot_6_axi_awsize,
                            slot_6_axi_awburst,slot_6_axi_awvalid,slot_6_axi_awready,
                            slot_6_axi_wstrb,slot_6_axi_wlast,slot_6_axi_wvalid,slot_6_axi_wready,
                            slot_6_axi_bid,slot_6_axi_bresp,slot_6_axi_bvalid,slot_6_axi_bready,
                            slot_6_axi_arid,slot_6_axi_araddr,slot_6_axi_arlen,slot_6_axi_arsize,
                            slot_6_axi_arburst,slot_6_axi_arvalid,slot_6_axi_arready,slot_6_axi_rid,
                            slot_6_axi_rresp,slot_6_axi_rlast,slot_6_axi_rvalid,slot_6_axi_rready};

  end
  else if(C_SLOT_6_AXI_PROTOCOL == "AXI4S" && C_NUM_MONITOR_SLOTS > 6) begin :GEN_SLOT_6_AXI4S
    assign SLOT_6_clk    = slot_6_axis_aclk;
    assign SLOT_6_Arst_n = slot_6_axis_aresetn;
    assign Slot_6_Data_In = {slot_6_axis_tvalid,slot_6_axis_tready,slot_6_axis_tstrb,
                            slot_6_axis_tkeep,slot_6_axis_tlast,slot_6_axis_tid,
                            slot_6_axis_tdest,slot_6_axis_tuser};

  end
  endgenerate

  generate if(C_SLOT_7_AXI_PROTOCOL == "AXI4" && C_NUM_MONITOR_SLOTS > 7) begin :GEN_SLOT_7_AXI4
    assign SLOT_7_clk    = slot_7_axi_aclk;
    assign SLOT_7_Arst_n = slot_7_axi_aresetn;
    assign Slot_7_Data_In = {slot_7_axi_awid,slot_7_axi_awaddr,slot_7_axi_awlen,slot_7_axi_awsize,
                            slot_7_axi_awburst,slot_7_axi_awvalid,slot_7_axi_awready,
                            slot_7_axi_wstrb,slot_7_axi_wlast,slot_7_axi_wvalid,slot_7_axi_wready,
                            slot_7_axi_bid,slot_7_axi_bresp,slot_7_axi_bvalid,slot_7_axi_bready,
                            slot_7_axi_arid,slot_7_axi_araddr,slot_7_axi_arlen,slot_7_axi_arsize,
                            slot_7_axi_arburst,slot_7_axi_arvalid,slot_7_axi_arready,slot_7_axi_rid,
                            slot_7_axi_rresp,slot_7_axi_rlast,slot_7_axi_rvalid,slot_7_axi_rready};


  end
  else if(C_SLOT_7_AXI_PROTOCOL == "AXI4S" && C_NUM_MONITOR_SLOTS > 7) begin :GEN_SLOT_7_AXI4S
    assign SLOT_7_clk    = slot_7_axis_aclk;
    assign SLOT_7_Arst_n = slot_7_axis_aresetn;
    assign Slot_7_Data_In = {slot_7_axis_tvalid,slot_7_axis_tready,slot_7_axis_tstrb,
                            slot_7_axis_tkeep,slot_7_axis_tlast,slot_7_axis_tid,
                            slot_7_axis_tdest,slot_7_axis_tuser};

  end
  endgenerate




   /*----------------------------------------------------------------------
   ------------------- Submodule instantiations-----------------------------
   -----------------------------------------------------------------------*/ 

   // AXI Lite Interface module

   axi_perf_mon_v5_0_12_axi_interface
   #(
         .C_FAMILY                (C_FAMILY               ), 
         .C_S_AXI_PROTOCOL        (C_S_AXI_PROTOCOL       ),
         .C_S_AXI_ADDR_WIDTH      (C_S_AXI_ADDR_WIDTH     ),
         .C_S_AXI_DATA_WIDTH      (C_S_AXI_DATA_WIDTH     ),
         .C_S_AXI_ID_WIDTH        (C_S_AXI_ID_WIDTH       ),
         .C_SUPPORT_ID_REFLECTION (C_SUPPORT_ID_REFLECTION) 
     ) axi_interface_inst
     (
         .S_AXI_ACLK          (s_axi_aclk ),       
         .S_AXI_ARESETN       (s_axi_aresetn),
         .S_AXI_AWADDR        (s_axi_awaddr),
         .S_AXI_AWVALID       (s_axi_awvalid),
         .S_AXI_AWID          (s_axi_awid),
         .S_AXI_AWREADY       (s_axi_awready),
         .S_AXI_WDATA         (s_axi_wdata),
         .S_AXI_WSTRB         (s_axi_wstrb),
         .S_AXI_WVALID        (s_axi_wvalid), 
         .S_AXI_WREADY        (s_axi_wready), 
         .S_AXI_BRESP         (s_axi_bresp),
         .S_AXI_BVALID        (s_axi_bvalid),
         .S_AXI_BID           (s_axi_bid),
         .S_AXI_BREADY        (s_axi_bready), 
         .S_AXI_ARADDR        (s_axi_araddr),
         .S_AXI_ARVALID       (s_axi_arvalid),
         .S_AXI_ARID          (s_axi_arid),
         .S_AXI_ARREADY       (s_axi_arready), 
         .S_AXI_RDATA         (s_axi_rdata  ), 
         .S_AXI_RRESP         (s_axi_rresp  ),
         .S_AXI_RVALID        (s_axi_rvalid ),
         .S_AXI_RID           (s_axi_rid),
         .S_AXI_RREADY        (s_axi_rready ),
         .Bus2IP_Addr         (Bus2IP_Addr  ),
         .Bus2IP_Data         (Bus2IP_Data  ),
         .Bus2IP_BE           (Bus2IP_BE    ),
         .Bus2IP_Burst        (Bus2IP_Burst ), 
         .Bus2IP_RdCE         (Bus2IP_RdCE  ), 
         .Bus2IP_WrCE         (Bus2IP_WrCE  ),
         .IP2Bus_Data         (IP2Bus_Data  ), 
         .IP2Bus_DataValid    (IP2Bus_DataValid),
         .IP2Bus_Error        (IP2Bus_Error )
      );
  generate if (C_LOG_DATA_OFFLD == 0 ) begin : LOG_DATA_OFFLOAD_STREAM
    assign eventlog_rd_clk = m_axis_aclk;
    assign eventlog_rd_rstn = m_axis_aresetn;
  end
  endgenerate
  generate if (C_LOG_DATA_OFFLD == 1 ) begin : LOG_DATA_OFFLOAD_MEMORY
    assign eventlog_rd_clk = s_axi_offld_aclk;
    assign eventlog_rd_rstn = s_axi_offld_aresetn;
  end
  endgenerate
  // Register module instance
   axi_perf_mon_v5_0_12_register_module
   #(
         .C_FAMILY                    (C_FAMILY),
         .C_S_AXI_ADDR_WIDTH          (C_S_AXI_ADDR_WIDTH),
         .C_S_AXI_DATA_WIDTH          (C_S_AXI_DATA_WIDTH),
         .C_NUM_MONITOR_SLOTS         (C_NUM_MONITOR_SLOTS), 
         .C_NUM_OF_COUNTERS           (C_NUM_OF_COUNTERS), 
         .C_NUM_INTR_INPUTS           (C_NUM_INTR_INPUTS),
         .C_ENABLE_EVENT_COUNT        (C_ENABLE_EVENT_COUNT),
         .C_ENABLE_EVENT_LOG          (C_ENABLE_EVENT_LOG),
         .C_METRICS_SAMPLE_COUNT_WIDTH(C_METRICS_SAMPLE_COUNT_WIDTH),
         .C_GLOBAL_COUNT_WIDTH        (C_GLOBAL_COUNT_WIDTH),
         .C_SW_SYNC_DATA_WIDTH        (C_SW_SYNC_DATA_WIDTH),
         .C_AXIS_DWIDTH_ROUND_TO_32   (C_AXIS_DWIDTH_ROUND_TO_32),
         .C_AXI4LITE_CORE_CLK_ASYNC   (C_AXI4LITE_CORE_CLK_ASYNC)
    ) register_module_inst
    (
         .S_AXI_ACLK           (s_axi_aclk),
         .S_AXI_ARESETN        (s_axi_aresetn),
         .Bus2IP_Addr          (Bus2IP_Addr),
         .Bus2IP_Data          (Bus2IP_Data),
         .Bus2IP_BE            (Bus2IP_BE),
         .Bus2IP_Burst         (Bus2IP_Burst),
         .Bus2IP_RdCE          (Bus2IP_RdCE)  ,
         .Bus2IP_WrCE          (Bus2IP_WrCE),
         .IP2Bus_Data          (IP2Bus_Data) ,
         .IP2Bus_DataValid     (IP2Bus_DataValid),
         .IP2Bus_Error         (IP2Bus_Error),
         .CORE_ACLK            (core_aclk   ),
         .CORE_ARESETN         (core_aresetn ),
         .Global_Clk_Cnt       (Global_Clk_Cnt) ,
         .Metric_Cnt_0         (Metric_Cnt_0  ) ,
         .Metric_Cnt_1         (Metric_Cnt_1  ) ,
         .Metric_Cnt_2         (Metric_Cnt_2  ) ,
         .Metric_Cnt_3         (Metric_Cnt_3  ) ,
         .Metric_Cnt_4         (Metric_Cnt_4  ) ,
         .Metric_Cnt_5         (Metric_Cnt_5  ) ,
         .Metric_Cnt_6         (Metric_Cnt_6  ) ,
         .Metric_Cnt_7         (Metric_Cnt_7  ) ,
         .Metric_Cnt_8         (Metric_Cnt_8  ) ,
         .Metric_Cnt_9         (Metric_Cnt_9  ) ,
         .Incrementer_0        (Incrementer_0  ) ,
         .Incrementer_1        (Incrementer_1  ) ,
         .Incrementer_2        (Incrementer_2  ) ,
         .Incrementer_3        (Incrementer_3  ) ,
         .Incrementer_4        (Incrementer_4  ) ,
         .Incrementer_5        (Incrementer_5  ) ,
         .Incrementer_6        (Incrementer_6  ) ,
         .Incrementer_7        (Incrementer_7  ) ,
         .Incrementer_8        (Incrementer_8  ) ,
         .Incrementer_9        (Incrementer_9  ) ,
         .Samp_Metric_Cnt_0    (Samp_Metric_Cnt_0  ) ,
         .Samp_Metric_Cnt_1    (Samp_Metric_Cnt_1  ) ,
         .Samp_Metric_Cnt_2    (Samp_Metric_Cnt_2  ) ,
         .Samp_Metric_Cnt_3    (Samp_Metric_Cnt_3  ) ,
         .Samp_Metric_Cnt_4    (Samp_Metric_Cnt_4  ) ,
         .Samp_Metric_Cnt_5    (Samp_Metric_Cnt_5  ) ,
         .Samp_Metric_Cnt_6    (Samp_Metric_Cnt_6  ) ,
         .Samp_Metric_Cnt_7    (Samp_Metric_Cnt_7  ) ,
         .Samp_Metric_Cnt_8    (Samp_Metric_Cnt_8  ) ,
         .Samp_Metric_Cnt_9    (Samp_Metric_Cnt_9  ) ,
         .Samp_Incrementer_0   (Samp_Incrementer_0  ) ,
         .Samp_Incrementer_1   (Samp_Incrementer_1  ) ,
         .Samp_Incrementer_2   (Samp_Incrementer_2  ) ,
         .Samp_Incrementer_3   (Samp_Incrementer_3  ) ,
         .Samp_Incrementer_4   (Samp_Incrementer_4  ) ,
         .Samp_Incrementer_5   (Samp_Incrementer_5  ) ,
         .Samp_Incrementer_6   (Samp_Incrementer_6  ) ,
         .Samp_Incrementer_7   (Samp_Incrementer_7  ) ,
         .Samp_Incrementer_8   (Samp_Incrementer_8  ) ,
         .Samp_Incrementer_9   (Samp_Incrementer_9  ) ,
         .Sample_Interval      (Sample_Interval  ),
         .Interval_Cnt_En      (Interval_Cnt_En  ),
         .Interval_Cnt_Ld      (Interval_Cnt_Ld  ),
         .Reset_On_Sample_Int_Lapse(Reset_On_Sample_Int_Lapse),
         .Global_Intr_En       (Global_Intr_En   ),
         .Intr_Reg_IER_Wr_En   (Intr_Reg_IER_Wr_En ),
         .Intr_Reg_ISR_Wr_En   (Intr_Reg_ISR_Wr_En ),
         .Intr_Reg_IER         (Intr_Reg_IER     ),
         .Intr_Reg_ISR         (Intr_Reg_ISR     ),
         .eventlog_rd_clk      (eventlog_rd_clk  ),
         .eventlog_rd_rstn     (eventlog_rd_rstn ),
         .eventlog_cur_cnt     (eventlog_cur_cnt ),
         .Metric_Sel_0         (Metric_Sel_0     ),
         .Metric_Sel_1         (Metric_Sel_1     ),
         .Metric_Sel_2         (Metric_Sel_2     ),
         .Metric_Sel_3         (Metric_Sel_3     ),
         .Metric_Sel_4         (Metric_Sel_4     ),
         .Metric_Sel_5         (Metric_Sel_5     ),
         .Metric_Sel_6         (Metric_Sel_6     ),
         .Metric_Sel_7         (Metric_Sel_7     ),
         .Metric_Sel_8         (Metric_Sel_8     ),
         .Metric_Sel_9         (Metric_Sel_9     ),
         .Range_Reg_0          (Range_Reg_0      ),
         .Range_Reg_1          (Range_Reg_1      ),
         .Range_Reg_2          (Range_Reg_2      ),
         .Range_Reg_3          (Range_Reg_3      ),
         .Range_Reg_4          (Range_Reg_4      ),
         .Range_Reg_5          (Range_Reg_5      ),
         .Range_Reg_6          (Range_Reg_6      ),
         .Range_Reg_7          (Range_Reg_7      ),
         .Range_Reg_8          (Range_Reg_8      ),
         .Range_Reg_9          (Range_Reg_9      ),
         .Flag_Enable_Reg      (Flag_Enable_Reg  ),
         .SW_Data_Log_En       (SW_Data_Log_En   ),
         .Ext_Event_Flag_En    (Ext_Event_Flag_En),
         .SW_Data              (SW_Data          ),
         .SW_Data_Wr_En        (SW_Data_Wr_En    ),
         .Global_Clk_Cnt_En    (Global_Clk_Cnt_En) ,
         .Global_Clk_Cnt_Reset (Global_Clk_Cnt_Reset),
         .Streaming_FIFO_Reset (Streaming_FIFO_Reset),
         .Event_Log_En         (Event_Log_En     ),
         .Metrics_Cnt_En       (Metrics_Cnt_En   ),
         .Metrics_Cnt_Reset    (Metrics_Cnt_Reset),
         .Use_Ext_Trigger      (Use_Ext_Trig     ),
         .Use_Ext_Trigger_Log  (Use_Ext_Trig_Log ),
         .Global_Clk_Cnt_Ovf_En(Global_Clk_Cnt_Ovf_En),
         .Sample_Metric_Cnt_Ovf_En(Sample_Metric_Cnt_Ovf_En),
         .Count_Event_Log_En   (Count_Event_Log_En),
         .Latency_WID          (Latency_WID),
         .Latency_RID          (Latency_RID),
         .En_Id_Based          (En_Id_Based),
         .Lat_Sample_Reg       (Lat_Sample_Reg),
         .WID_Mask             (WID_Mask),
         .RID_Mask             (RID_Mask),
         .Wr_Lat_Start         (Wr_Lat_Start), //0 Address Issue 1 Address acceptance
         .Wr_Lat_End           (Wr_Lat_End), //1 First write   0 Last write  
         .Rd_Lat_Start         (Rd_Lat_Start), //0 Address Issue 1 Address acceptance 
         .Rd_Lat_End           (Rd_Lat_End)  //1 First Read    0 Last Read
       );

   
   generate    
   if (C_ENABLE_EVENT_COUNT == 1 && C_ENABLE_EVENT_LOG == 1) begin : GEN_CROSS_PROBE_GLOBAL
   //Event logging enable generation when global clock counter overflow
   reg Global_Cnt_Event_Log_En_i;

   always @(posedge core_aclk) begin
       if (core_aresetn == RST_ACTIVE) begin
           Global_Cnt_Event_Log_En_i <= 1'b0;
       end
       else begin
           if(Global_Clk_Cnt_Ovf_En_sync == 1'b0) begin //User control to enable 
             Global_Cnt_Event_Log_En_i <= 1'b0;
           end
           else if(Global_Clk_Cnt_OF == 1'b1) begin     //Counter overflow
             Global_Cnt_Event_Log_En_i <= 1'b1;
           end
       end
   end
       assign Global_Cnt_Event_Log_En = Global_Cnt_Event_Log_En_i;
   end
   else begin: GEN_NO_CROSS_PROBE_GLOBAL 
      assign Global_Cnt_Event_Log_En = 1'b0;
   end
   endgenerate


   //Event logging enable generation when sample metric counter lapse 
   generate    
   if (C_ENABLE_EVENT_COUNT == 1 && C_ENABLE_EVENT_LOG == 1) begin : GEN_CROSS_PROBE_SAMPLE
   reg Sample_Cnt_Event_Log_En_i;
   always @(posedge core_aclk) begin
       if (core_aresetn == RST_ACTIVE) begin
           Sample_Cnt_Event_Log_En_i <= 1'b0;
       end
       else begin
           if(Sample_Metric_Cnt_Ovf_En_sync == 1'b0) begin //User control to enable 
             Sample_Cnt_Event_Log_En_i <= 1'b0;
           end
           else if(Sample_Interval_Cnt_Lapse == 1'b1) begin //Counter overflow
             Sample_Cnt_Event_Log_En_i <= 1'b1;
           end
       end
   end
      assign Sample_Cnt_Event_Log_En = Sample_Cnt_Event_Log_En_i;
   end
   else begin: GEN_NO_CROSS_PROBE_SAMPLE
      assign Sample_Cnt_Event_Log_En = 1'b0;
   end

   endgenerate
   //-- Inputs to interrupt module

    assign Intr_In = { Acc_OF_9, Acc_OF_8, Acc_OF_7, Acc_OF_6, Acc_OF_5,
                       Acc_OF_4, Acc_OF_3, Acc_OF_2, Acc_OF_1, Acc_OF_0,
                       Streaming_Fifo_Full_Edge, Sample_Interval_Cnt_Lapse, Global_Clk_Cnt_OF};

    // synchronizing the inputs to interrupt module
    generate
    if((C_AXI4LITE_CORE_CLK_ASYNC == 1)) begin :GEN_INTR_ASYNC
        axi_perf_mon_v5_0_12_intr_sync
           #(
                 .C_FAMILY            (C_FAMILY),
                 .C_DWIDTH            (C_NUM_INTR_INPUTS) 
            ) intr_sync_module_inst
            (
                 .clk_1               (core_aclk),
                 .rst_1_n             (core_aresetn), 
                 .DATA_IN             (Intr_In),
                 .clk_2               (s_axi_aclk),
                 .rst_2_n             (s_axi_aresetn), 
                 .SYNC_DATA_OUT       (Intr_In_sync)
            );
    end
    else begin :GEN_INTR_SYNC
        assign Intr_In_sync = Intr_In;
    end
    endgenerate
       

    // Interrupt Module instance

    wire [C_NUM_INTR_INPUTS-1:0] Wr_Data = Bus2IP_Data[C_NUM_INTR_INPUTS-1:0];

    axi_perf_mon_v5_0_12_interrupt_module 
    #(
         .C_FAMILY             (C_FAMILY         ),
         .C_NUM_INTR_INPUTS    (C_NUM_INTR_INPUTS)
     ) interrupt_module_inst
     (
         .clk                  (s_axi_aclk        ),
         .rst_n                (s_axi_aresetn     ),
         .Intr                 (Intr_In_sync      ),
         .Interrupt_Enable     (Global_Intr_En    ),
         .IER_Wr_En            (Intr_Reg_IER_Wr_En),                
         .ISR_Wr_En            (Intr_Reg_ISR_Wr_En),
         .Wr_Data              (Wr_Data           ),
         .IER                  (Intr_Reg_IER      ), 
         .ISR                  (Intr_Reg_ISR      ), 
         .Interrupt            (interrupt         )
      );

    //assigning global clock count enable ane reset signals to bus

    //-- Control Bits
    wire [10:0] Control_Bits = {Use_Ext_Trig_Log,Use_Ext_Trig,Sample_Metric_Cnt_Ovf_En,Global_Clk_Cnt_Ovf_En, 
                               Streaming_FIFO_Reset,En_Id_Based,
                               Global_Clk_Cnt_Reset, Global_Clk_Cnt_En,Event_Log_En,
                               Metrics_Cnt_Reset, Metrics_Cnt_En };
 
    generate    
    if (C_AXI4LITE_CORE_CLK_ASYNC == 1) begin : GEN_CONTROL_SYNC
        //-- Synchronizing Control bits to core clk  
        //-- Double Flop synchronization
        axi_perf_mon_v5_0_12_cdc_sync
        #(
           .c_cdc_type      (1             ),   
           .c_flop_input    (0             ),  
           .c_reset_state   (1             ),  
           .c_single_bit    (0             ),  
           .c_vector_width  (11            ),  
           .c_mtbf_stages   (4             )  
         )control_sig_cdc_sync 
         (
           .prmry_aclk      (s_axi_aclk          ),
           .prmry_rst_n     (s_axi_aresetn       ),
           .prmry_in        (1'b0                ),
           .prmry_vect_in   (Control_Bits        ),
           .scndry_aclk     (core_aclk           ),
           .scndry_rst_n    (core_aresetn        ),
           .prmry_ack       (                    ),
           .scndry_out      (                    ),
           .scndry_vect_out (Control_Bits_sync   ) 
          );

        assign Metrics_Cnt_En_sync           = Control_Bits_sync[0];
        assign Metrics_Cnt_Reset_sync        = Control_Bits_sync[1];
        assign Event_Log_En_sync             = Control_Bits_sync[2] | Count_Event_Log_En |
                                               Global_Cnt_Event_Log_En | Sample_Cnt_Event_Log_En;
        assign Global_Clk_Cnt_En_sync        = Control_Bits_sync[3];
        assign Global_Clk_Cnt_Reset_sync     = Control_Bits_sync[4];
        assign En_Id_Based_sync              = Control_Bits_sync[5];
        assign Streaming_FIFO_Reset_sync     = Control_Bits_sync[6];
        assign Global_Clk_Cnt_Ovf_En_sync    = Control_Bits_sync[7];
        assign Sample_Metric_Cnt_Ovf_En_sync = Control_Bits_sync[8];
        assign Use_Ext_Trig_sync             = Control_Bits_sync[9];
        assign Use_Ext_Trig_Log_sync         = Control_Bits_sync[10];

    end 
    else begin : GEN_CONTROL_NO_SYNC
        assign Metrics_Cnt_En_sync           = Control_Bits[0];
        assign Metrics_Cnt_Reset_sync        = Control_Bits[1];
        assign Event_Log_En_sync             = Control_Bits[2] | Count_Event_Log_En |
                                               Global_Cnt_Event_Log_En | Sample_Cnt_Event_Log_En;
        assign Global_Clk_Cnt_En_sync        = Control_Bits[3];
        assign Global_Clk_Cnt_Reset_sync     = Control_Bits[4];
        assign En_Id_Based_sync              = Control_Bits[5];
        assign Streaming_FIFO_Reset_sync     = Control_Bits[6];
        assign Global_Clk_Cnt_Ovf_En_sync    = Control_Bits[7];
        assign Sample_Metric_Cnt_Ovf_En_sync = Control_Bits[8];
        assign Use_Ext_Trig_sync             = Control_Bits[9];
        assign Use_Ext_Trig_Log_sync         = Control_Bits[10];
    end 
    endgenerate 

   wire trigger_in_sync;

   reg 	trigger_in_ack_r;

   wire 	trigger_in_d4;

//synchoronize the input trigger_in signal with level shifter
        axi_perf_mon_v5_0_12_cdc_sync
        #(
           .c_cdc_type      (1             ),   
           .c_flop_input    (0             ),  
           .c_reset_state   (1             ),  
           .c_single_bit    (1             ),  
           .c_vector_width  (1             ),  
           .c_mtbf_stages   (4             )  
         ) trigger_sig_cdc_sync 
         (
           .prmry_aclk      (1'b1                ),
           .prmry_rst_n     (1'b1                ),
           .prmry_in        (trigger_in          ),
           .prmry_vect_in   (1'b0                ),
           .scndry_aclk     (core_aclk           ),
           .scndry_rst_n    (core_aresetn        ),
           .prmry_ack       (                    ),
           .scndry_out      (trigger_in_d4       ),
           .scndry_vect_out (                    ) 
          );
// always @ (posedge core_aclk ) begin
//     if (core_aresetn == RST_ACTIVE)
//       begin
//	  trigger_in_d1 <=0;
//	  trigger_in_d2<=0;
//	  trigger_in_d3<=0;
//	  trigger_in_d4<=0;
//       end
//     else
//       begin
//	  trigger_in_d1 <= trigger_in;
//	  trigger_in_d2 <= trigger_in_d1;
//	  trigger_in_d3 <= trigger_in_d2;
//	  trigger_in_d4 <= trigger_in_d3;
//       end
//   end
   
   assign trigger_in_sync = trigger_in_d4;

 
//generate trigger_ack hand-shaking signal
  always @(posedge core_aclk) begin
      if (core_aresetn == RST_ACTIVE)
      	trigger_in_ack_r <=0;
      else begin
      	if (trigger_in_sync)
	         trigger_in_ack_r <= 1'b1;
      	else
	         trigger_in_ack_r <=1'b0;
    end
  end
   assign trigger_in_ack = trigger_in_ack_r;

//generate trigger signal for the controlling of internal components. Also use Metric_Cnt_En_sync signal as enable signal and Metrics_Cnt_Reset_sync as reset signal
   
   reg trigger,trigger1;
   always @ (posedge core_aclk) begin
			   
       if (core_aresetn == RST_ACTIVE) begin
	     trigger <=0;
	     trigger1 <=0;
        end else begin
	    trigger <= trigger1;
      if (trigger_in_sync && Metrics_Cnt_En_sync && !Metrics_Cnt_Reset_sync)
	     trigger1 <=1'b1;
    	else if (!trigger_in_sync && Metrics_Cnt_En_sync && !Metrics_Cnt_Reset_sync)
	     trigger1 <= trigger1;
      else
	    trigger1 <=0;
   end	
   end

    // Global Clock Counter 

     axi_perf_mon_v5_0_12_glbl_clk_cnt
      #(
         .C_FAMILY             (C_FAMILY),
         .C_GLOBAL_COUNT_WIDTH (C_GLOBAL_COUNT_WIDTH),
	 .COUNTER_LOAD_VALUE   (COUNTER_LOAD_VALUE)
       ) global_clock_counter_inst
       (
         .clk                  (core_aclk   ),
         .rst_n                (core_aresetn),
         .Global_Clk_Cnt_En    (Global_Clk_Cnt_En_sync),
         .Global_Clk_Cnt_Reset (Global_Clk_Cnt_Reset_sync),
         .Global_Clk_Cnt       (Global_Clk_Cnt),
         .Global_Clk_Cnt_OF    (Global_Clk_Cnt_OF)
       );


     //-- Slot 0
     
     // Monitor FIFO instantiations
     axi_perf_mon_v5_0_12_mon_fifo
     #(
       .C_FAMILY                  (C_FAMILY),
       .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),  
       .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S0),
       .C_FIFO_ENABLE             (C_SLOT_0_FIFO_ENABLE) 
      ) mon_fifo_inst_0
      (
       .Mon_clk                   (SLOT_0_clk),
       .Mon_rst_n                 (SLOT_0_Arst_n),
       .Data_In                   (Slot_0_Data_In),
       //.mon_en                    (Metrics_Cnt_En_sync),
       .CORE_ACLK                 (core_aclk),
       .CORE_ARESETN              (core_aresetn),
       .Sync_Data_Out             (Slot_0_Sync_Data_Out),
       .Sync_Data_Valid           (Slot_0_Sync_Data_Valid)
      );

    generate    
    if (C_ENABLE_EVENT_LOG == 1) begin : GEN_FLAGS0
    //Flag Generator instantiation for slot0
     axi_perf_mon_v5_0_12_flags_gen
     #(
       .C_FAMILY                  (C_FAMILY),
       .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S0), 
       .C_LOG_WIDTH               (C_SLOT_0_LOG_WIDTH),
       .C_FLAG_WIDTH              (C_SLOT_0_FLAG_WIDTH), 
       .C_AXI_ADDR_WIDTH          (C_SLOT_0_AXI_ADDR_WIDTH), 
       .C_AXI_DATA_WIDTH          (C_SLOT_0_AXI_DATA_WIDTH), 
       .C_AXI_ID_WIDTH            (C_SLOT_0_AXI_ID_WIDTH), 
       .C_AXI_PROTOCOL            (C_SLOT_0_AXI_PROTOCOL), 
       .C_AXIS_TDATA_WIDTH        (C_SLOT_0_AXIS_TDATA_WIDTH), 
       .C_AXIS_TID_WIDTH          (C_SLOT_0_AXIS_TID_WIDTH), 
       .C_AXIS_TDEST_WIDTH        (C_SLOT_0_AXIS_TDEST_WIDTH), 
       .C_AXIS_TUSER_WIDTH        (C_SLOT_0_AXIS_TUSER_WIDTH),
       .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
       .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
       .C_SHOW_AXIS_TID           (C_SHOW_AXIS_TID),
       .C_SHOW_AXIS_TUSER         (C_SHOW_AXIS_TUSER),
       .C_SHOW_AXIS_TDEST         (C_SHOW_AXIS_TDEST), 
       .C_EN_AXI_DEBUG               (C_EN_AXI_DEBUG) 
      ) flags_generator_inst_0
      (
       .clk                       (core_aclk),
       .rst_n                     (core_aresetn),
       .Data_In                   (Slot_0_Sync_Data_Out),
       .Data_Valid                (Slot_0_Sync_Data_Valid), 
       .Flag_Enable_Reg           (Flag_Enable_Reg),
       .Ext_Trig                  (slot_0_ext_trig),
       .Ext_Trig_Stop             (slot_0_ext_trig_stop),
       .Use_Ext_Trig_Log          (Use_Ext_Trig_Log_sync),                 
       .Log_Data                  (Slot_0_Log),
       .Log_En                    (Slot_0_Log_En),
       .Ext_Data_in               (Ext_Event0_Sync_Data_Out),
       .Ext_Data_Valid            (Ext_Event0_Sync_Data_Valid),
       .Ext_Event_Flag_En         (Ext_Event_Flag_En),
       .Ext_Event_Flags           (Ext_Event0_Flags)
      );
    end 
    else begin : GEN_NO_FLAGS0
       assign Slot_0_Log = 0;
       assign Slot_0_Log_En = 1'b0;
       assign Ext_Event0_Flags = 0;
    end 
    endgenerate 

     // Metric calculator instance for slot0
     axi_perf_mon_v5_0_12_metric_calc 
    #(
      .C_AXIID                   (C_SLOT_0_AXI_ID_WIDTH    ),
      .C_AXIADDR                 (C_SLOT_0_AXI_ADDR_WIDTH  ),
      .C_AXIDATA                 (C_SLOT_0_AXI_DATA_WIDTH  ),
      .C_AXISDATA                (C_SLOT_0_AXIS_TDATA_WIDTH),
      .C_AXISID                  (C_SLOT_0_AXIS_TID_WIDTH  ),
      .C_AXISDEST                (C_SLOT_0_AXIS_TDEST_WIDTH),
      .C_AXISUSER                (C_SLOT_0_AXIS_TUSER_WIDTH),
      .C_OUTSTAND_DEPTH          (C_MAX_OUTSTAND_DEPTH),
      .C_METRIC_COUNT_WIDTH      (C_METRIC_COUNT_WIDTH),
      .C_MON_FIFO_WIDTH          (C_MON_FIFO_DWIDTH_S0),
      .C_AXI_PROTOCOL            (C_SLOT_0_AXI_PROTOCOL),
      .C_AXI_SUB_PROTOCOL        (C_SLOT_0_AXI_SUB_PROTOCOL)
     ) metric_calc_inst0
     (
      .clk                       (core_aclk ),
      .rst_n                     (core_aresetn),
      .Data_In                   (Slot_0_Sync_Data_Out),
      .Data_Valid                (Slot_0_Sync_Data_Valid), 
      .Metrics_Cnt_En            (Metrics_Cnt_En_sync),
      .Metrics_Cnt_Reset         (Metrics_Cnt_Reset_sync),
      .Use_Ext_Trig              (Use_Ext_Trig_sync),
      .Ext_Trig                  (slot_0_ext_trig),
      .Ext_Trig_Stop             (slot_0_ext_trig_stop),
      .Latency_WID               (Latency_WID),
      .Latency_RID               (Latency_RID),
      .WID_Mask                  (WID_Mask),
      .RID_Mask                  (RID_Mask),
      .En_Id_Based               (En_Id_Based_sync),  
      .Wr_Lat_Start              (Wr_Lat_Start    ),  //0 Address Issue 1 Address acceptance
      .Wr_Lat_End                (Wr_Lat_End      ),  //1 First write   0 Last write  
      .Rd_Lat_Start              (Rd_Lat_Start    ),  //0 Address Issue 1 Address acceptance 
      .Rd_Lat_End                (Rd_Lat_End      ),  //1 First Read    0 Last Read
      .Wtrans_Cnt_En             (Wtrans_Cnt_En[0]),
      .Rtrans_Cnt_En             (Rtrans_Cnt_En[0]),
      .Write_Byte_Cnt            (S0_Write_Byte_Cnt),
      .Read_Byte_Cnt             (S0_Read_Byte_Cnt),
      .Read_Byte_Cnt_En          (S0_Read_Byte_Cnt_En),
      .Write_Beat_Cnt_En         (Write_Beat_Cnt_En[0]),
      .Read_Beat_Cnt_En          (Read_Beat_Cnt_En[0]),
      .Read_Latency              (S0_Read_Latency),
      .Write_Latency             (S0_Write_Latency),
      .Write_Beat_Cnt            (S0_Write_Beat_Cnt),
      .Slv_Wr_Idle_Cnt           (S0_Slv_Wr_Idle_Cnt),
      .Read_Latency_En           (Read_Latency_En[0]),    
      .Write_Latency_En          (Write_Latency_En[0]),   
      .Slv_Wr_Idle_Cnt_En        (Slv_Wr_Idle_Cnt_En[0]), 
      .Mst_Rd_Idle_Cnt_En        (Mst_Rd_Idle_Cnt_En[0]), 
      .Num_BValids_En            (Num_BValids_En[0]),     
      .Num_WLasts_En             (Num_WLasts_En[0]),      
      .Num_RLasts_En             (Num_RLasts_En[0]),      
      .S_Transfer_Cnt_En         (S_Transfer_Cnt_En[0]),
      .S_Packet_Cnt_En           (S_Packet_Cnt_En[0]),  
      .S_Data_Byte_Cnt           (S0_S_Data_Byte_Cnt),
      .S_Position_Byte_Cnt       (S0_S_Position_Byte_Cnt),
      .S_Null_Byte_Cnt           (S0_S_Null_Byte_Cnt),
      .S_Slv_Idle_Cnt_En         (S_Slv_Idle_Cnt_En[0]),
      .S_Mst_Idle_Cnt_En         (S_Mst_Idle_Cnt_En[0]),
      .Max_Write_Latency         (S0_Max_Write_Latency),                   
      .Min_Write_Latency         (S0_Min_Write_Latency),                   
      .Max_Read_Latency          (S0_Max_Read_Latency),                   
      .Min_Read_Latency          (S0_Min_Read_Latency) 
    );

    assign Ext_Event0_Data_In = {ext_event_0_cnt_start,ext_event_0_cnt_stop,ext_event_0};
       
     // External Event0 through monitor FIFO
     axi_perf_mon_v5_0_12_mon_fifo
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
           .C_MON_FIFO_DATA_WIDTH     (3),
           .C_FIFO_ENABLE             (C_EXT_EVENT0_FIFO_ENABLE) 
          ) mon_fifo_ext_event0_inst
          (
           .Mon_clk                   (ext_clk_0),
           .Mon_rst_n                 (ext_rstn_0),
           .Data_In                   (Ext_Event0_Data_In),
           //.mon_en                    (Metrics_Cnt_En_sync),
           .CORE_ACLK                 (core_aclk),
           .CORE_ARESETN              (core_aresetn),
           .Sync_Data_Out             (Ext_Event0_Sync_Data_Out),
           .Sync_Data_Valid           (Ext_Event0_Sync_Data_Valid)
          );

     // External Event0 count enable generation module
      axi_perf_mon_v5_0_12_ext_calc ext_calc_inst0  
         (
           .clk                    (core_aclk),        
           .rst_n                  (core_aresetn),     
           .Ext_Event              (Ext_Event0_Sync_Data_Out[0]),
           .Ext_Event_Start        (Ext_Event0_Sync_Data_Out[2]),
           .Ext_Event_Stop         (Ext_Event0_Sync_Data_Out[1]),
           .Ext_Event_Valid        (Ext_Event0_Sync_Data_Valid ),
           .Metrics_Cnt_En         (Metrics_Cnt_En_sync),
           .Metrics_Cnt_Reset      (Metrics_Cnt_Reset_sync),
           .External_Event_Cnt_En  (External_Event_Cnt_En[0])
         );
  generate if(C_ENABLE_EVENT_LOG == 1 && C_EN_TRIGGER == 1) begin : GEN_POST_TRIGGER
//Aligning start and end events of transactions
       axi_perf_mon_v5_0_12_postTriggerMarker 
	    #(
			   // Parameters
			.C_FAMILY                  (C_FAMILY),
         .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S0), 
         .C_LOG_WIDTH               (C_SLOT_0_LOG_WIDTH),
         .C_FLAG_WIDTH              (C_SLOT_N_FLAG_WIDTH), 
         .C_AXI_ADDR_WIDTH          (C_SLOT_0_AXI_ADDR_WIDTH), 
         .C_AXI_DATA_WIDTH          (C_SLOT_0_AXI_DATA_WIDTH), 
         .C_AXI_ID_WIDTH            (C_SLOT_0_AXI_ID_WIDTH), 
         .C_AXI_PROTOCOL            (C_SLOT_0_AXI_PROTOCOL), 
         .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS)
      )
		triggerMarker_slot0 (
			    // Outputs
			    .Log_Data_Marked	(Slot_0_Log_Marked),
			    .Log_en_out		(Slot_0_Log_En_Marked),
			    // Inputs
			    .clk		  (core_aclk),
			    .rst_n	  (stream_fifo_rst_n),
			    .trigger  (trigger),
			    .reStart  (Metrics_Cnt_Reset_sync),
			    .Log_Data (Slot_0_Log),
			    .Log_En	  (Slot_0_Log_En)
			    );

     end
      else if(C_ENABLE_EVENT_LOG == 1 && C_EN_TRIGGER == 0) begin :GEN_NO_POST_TRIGGER
      assign Slot_0_Log_Marked = Slot_0_Log;
      assign Slot_0_Log_En_Marked = Slot_0_Log_En;
      end
      endgenerate
 
     //-- Slot 1
     generate
     if((C_NUM_MONITOR_SLOTS > 1)) begin :GEN_SLOT1 

         axi_perf_mon_v5_0_12_mon_fifo
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
           .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S1),
           .C_FIFO_ENABLE             (C_SLOT_1_FIFO_ENABLE) 
          ) mon_fifo_inst_1
          (
           .Mon_clk                   (SLOT_1_clk),
           .Mon_rst_n                 (SLOT_1_Arst_n),
           .Data_In                   (Slot_1_Data_In),
           //.mon_en                    (Metrics_Cnt_En_sync),
           .CORE_ACLK                 (core_aclk),
           .CORE_ARESETN              (core_aresetn),
           .Sync_Data_Out             (Slot_1_Sync_Data_Out),
           .Sync_Data_Valid           (Slot_1_Sync_Data_Valid)
          );

          assign Ext_Event1_Data_In = {ext_event_1_cnt_start,ext_event_1_cnt_stop,ext_event_1};
     
          // External Event1 through monitor FIFO
          axi_perf_mon_v5_0_12_mon_fifo
             #(
               .C_FAMILY                  (C_FAMILY),
               .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
               .C_MON_FIFO_DATA_WIDTH     (3),
               .C_FIFO_ENABLE             (C_EXT_EVENT1_FIFO_ENABLE) 
              ) mon_fifo_ext_event1_inst
              (
               .Mon_clk                   (ext_clk_1),
               .Mon_rst_n                 (ext_rstn_1),
               .Data_In                   (Ext_Event1_Data_In),
               //.mon_en                    (Metrics_Cnt_En_sync),
               .CORE_ACLK                 (core_aclk),
               .CORE_ARESETN              (core_aresetn),
               .Sync_Data_Out             (Ext_Event1_Sync_Data_Out),
               .Sync_Data_Valid           (Ext_Event1_Sync_Data_Valid)
              );

         // External Event1 count enable generation module
         axi_perf_mon_v5_0_12_ext_calc ext_calc_inst1  
            (
              .clk                    (core_aclk),        
              .rst_n                  (core_aresetn),     
              .Ext_Event              (Ext_Event1_Sync_Data_Out[0]),
              .Ext_Event_Start        (Ext_Event1_Sync_Data_Out[2]),
              .Ext_Event_Stop         (Ext_Event1_Sync_Data_Out[1]),
              .Ext_Event_Valid        (Ext_Event1_Sync_Data_Valid ),
              .Metrics_Cnt_En         (Metrics_Cnt_En_sync),
              .Metrics_Cnt_Reset      (Metrics_Cnt_Reset_sync),
              .External_Event_Cnt_En  (External_Event_Cnt_En[1])
            );

          // Metric calculator instance for slot1
          axi_perf_mon_v5_0_12_metric_calc 
          #(
            .C_AXIID                   (C_SLOT_1_AXI_ID_WIDTH    ),
            .C_AXIADDR                 (C_SLOT_1_AXI_ADDR_WIDTH  ),
            .C_AXIDATA                 (C_SLOT_1_AXI_DATA_WIDTH  ),
            .C_AXISDATA                (C_SLOT_1_AXIS_TDATA_WIDTH),
            .C_AXISID                  (C_SLOT_1_AXIS_TID_WIDTH  ),
            .C_AXISDEST                (C_SLOT_1_AXIS_TDEST_WIDTH),
            .C_AXISUSER                (C_SLOT_1_AXIS_TUSER_WIDTH),
            .C_OUTSTAND_DEPTH          (C_MAX_OUTSTAND_DEPTH),
            .C_METRIC_COUNT_WIDTH      (C_METRIC_COUNT_WIDTH),
            .C_MON_FIFO_WIDTH          (C_MON_FIFO_DWIDTH_S1),
            .C_AXI_PROTOCOL            (C_SLOT_1_AXI_PROTOCOL),
            .C_AXI_SUB_PROTOCOL        (C_SLOT_1_AXI_SUB_PROTOCOL)
          ) metric_calc_inst1
          (
            .clk                       (core_aclk ),
            .rst_n                     (core_aresetn),
            .Data_In                   (Slot_1_Sync_Data_Out),
            .Data_Valid                (Slot_1_Sync_Data_Valid), 
            .Metrics_Cnt_En            (Metrics_Cnt_En_sync),
            .Metrics_Cnt_Reset         (Metrics_Cnt_Reset_sync),
            .Use_Ext_Trig              (Use_Ext_Trig_sync),
            .Ext_Trig                  (slot_1_ext_trig),
            .Ext_Trig_Stop             (slot_1_ext_trig_stop),
            .Latency_WID               (Latency_WID),
            .Latency_RID               (Latency_RID),
            .WID_Mask                  (WID_Mask),
            .RID_Mask                  (RID_Mask),
            .En_Id_Based               (En_Id_Based_sync),
            .Wr_Lat_Start              (Wr_Lat_Start    ),  //0 Address Issue 1 Address acceptance
            .Wr_Lat_End                (Wr_Lat_End      ),  //1 First write   0 Last write  
            .Rd_Lat_Start              (Rd_Lat_Start    ),  //0 Address Issue 1 Address acceptance 
            .Rd_Lat_End                (Rd_Lat_End      ),  //1 First Read    0 Last Read
            .Wtrans_Cnt_En             (Wtrans_Cnt_En[1]),
            .Rtrans_Cnt_En             (Rtrans_Cnt_En[1]),
            .Write_Byte_Cnt            (S1_Write_Byte_Cnt),
            .Read_Byte_Cnt             (S1_Read_Byte_Cnt),
            .Read_Byte_Cnt_En          (S1_Read_Byte_Cnt_En),
            .Write_Beat_Cnt_En         (Write_Beat_Cnt_En[1]),
            .Read_Beat_Cnt_En          (Read_Beat_Cnt_En[1]),
            .Read_Latency              (S1_Read_Latency),
            .Write_Latency             (S1_Write_Latency),
            .Write_Beat_Cnt            (S1_Write_Beat_Cnt),
            .Slv_Wr_Idle_Cnt           (S1_Slv_Wr_Idle_Cnt),
            .Read_Latency_En           (Read_Latency_En[1]),    
            .Write_Latency_En          (Write_Latency_En[1]),   
            .Slv_Wr_Idle_Cnt_En        (Slv_Wr_Idle_Cnt_En[1]), 
            .Mst_Rd_Idle_Cnt_En        (Mst_Rd_Idle_Cnt_En[1]), 
            .Num_BValids_En            (Num_BValids_En[1]),     
            .Num_WLasts_En             (Num_WLasts_En[1]),      
            .Num_RLasts_En             (Num_RLasts_En[1]),      
            .S_Transfer_Cnt_En         (S_Transfer_Cnt_En[1]),
            .S_Packet_Cnt_En           (S_Packet_Cnt_En[1]),  
            .S_Data_Byte_Cnt           (S1_S_Data_Byte_Cnt),
            .S_Position_Byte_Cnt       (S1_S_Position_Byte_Cnt),
            .S_Null_Byte_Cnt           (S1_S_Null_Byte_Cnt),
            .S_Slv_Idle_Cnt_En         (S_Slv_Idle_Cnt_En[1]),
            .S_Mst_Idle_Cnt_En         (S_Mst_Idle_Cnt_En[1]),
            .Max_Write_Latency         (S1_Max_Write_Latency),                   
            .Min_Write_Latency         (S1_Min_Write_Latency),                   
            .Max_Read_Latency          (S1_Max_Read_Latency),                   
            .Min_Read_Latency          (S1_Min_Read_Latency)
          );
     end
     else begin :GEN_NO_SLOT1
         assign S1_Write_Beat_Cnt = 0;
         assign S1_Slv_Wr_Idle_Cnt = 0;
         assign Slot_1_Sync_Data_Out = 0;
         assign S1_Write_Byte_Cnt    = 0;
         assign S1_Read_Byte_Cnt     = 0;
         assign S1_Read_Latency      = 0;
         assign S1_Write_Latency     = 0;
         assign S1_S_Data_Byte_Cnt   = 0;
         assign S1_S_Position_Byte_Cnt = 0;
         assign S1_S_Null_Byte_Cnt     = 0;
         assign Ext_Event1_Sync_Data_Out = 0;
         assign Ext_Event1_Sync_Data_Valid = 0;
         assign S1_Max_Write_Latency  = 0;                  
         assign S1_Min_Write_Latency  = 0;               
         assign S1_Max_Read_Latency   = 0;               
         assign S1_Min_Read_Latency   = 0;
     end
     endgenerate 

    generate    
    if (C_ENABLE_EVENT_LOG == 1 && C_NUM_MONITOR_SLOTS > 1) begin : GEN_FLAGS1

       //Flag Generator instantiation for slot1
         axi_perf_mon_v5_0_12_flags_gen
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S1), 
           .C_LOG_WIDTH               (C_SLOT_1_LOG_WIDTH),
           .C_FLAG_WIDTH              (C_SLOT_1_FLAG_WIDTH), 
           .C_AXI_ADDR_WIDTH          (C_SLOT_1_AXI_ADDR_WIDTH), 
           .C_AXI_DATA_WIDTH          (C_SLOT_1_AXI_DATA_WIDTH), 
           .C_AXI_ID_WIDTH            (C_SLOT_1_AXI_ID_WIDTH), 
           .C_AXI_PROTOCOL            (C_SLOT_1_AXI_PROTOCOL), 
           .C_AXIS_TDATA_WIDTH        (C_SLOT_1_AXIS_TDATA_WIDTH), 
           .C_AXIS_TID_WIDTH          (C_SLOT_1_AXIS_TID_WIDTH), 
           .C_AXIS_TDEST_WIDTH        (C_SLOT_1_AXIS_TDEST_WIDTH), 
           .C_AXIS_TUSER_WIDTH        (C_SLOT_1_AXIS_TUSER_WIDTH),
           .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
           .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
           .C_SHOW_AXIS_TID           (C_SHOW_AXIS_TID),
           .C_SHOW_AXIS_TUSER         (C_SHOW_AXIS_TUSER),
           .C_SHOW_AXIS_TDEST         (C_SHOW_AXIS_TDEST), 
           .C_EN_AXI_DEBUG               (C_EN_AXI_DEBUG) 
          ) flags_generator_inst_1
          (
           .clk                       (core_aclk),
           .rst_n                     (core_aresetn),
           .Data_In                   (Slot_1_Sync_Data_Out),
           .Data_Valid                (Slot_1_Sync_Data_Valid), 
           .Flag_Enable_Reg           (Flag_Enable_Reg),
           .Log_Data                  (Slot_1_Log),
           .Log_En                    (Slot_1_Log_En),
           .Ext_Trig                  (slot_1_ext_trig),
           .Ext_Trig_Stop             (slot_1_ext_trig_stop),
           .Use_Ext_Trig_Log          (Use_Ext_Trig_Log_sync),                
           .Ext_Data_in               (Ext_Event1_Sync_Data_Out),
           .Ext_Data_Valid            (Ext_Event1_Sync_Data_Valid),
           .Ext_Event_Flag_En         (Ext_Event_Flag_En),
           .Ext_Event_Flags           (Ext_Event1_Flags)
          );
    end 
    else begin : GEN_NO_FLAGS1
       assign Slot_1_Log = 0;
       assign Slot_1_Log_En = 1'b0;
       assign Ext_Event1_Flags = 0;
    end 
    endgenerate 
 generate if(C_NUM_MONITOR_SLOTS > 1 && C_ENABLE_EVENT_LOG == 1 && C_EN_TRIGGER == 1) begin : GEN_S1_POST_TRIGGER
//Aligning start and end events of transactions
       axi_perf_mon_v5_0_12_postTriggerMarker 
	    #(
			   // Parameters
			.C_FAMILY                  (C_FAMILY),
         .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S1), 
         .C_LOG_WIDTH               (C_SLOT_1_LOG_WIDTH),
         .C_FLAG_WIDTH              (C_SLOT_N_FLAG_WIDTH), 
         .C_AXI_ADDR_WIDTH          (C_SLOT_1_AXI_ADDR_WIDTH), 
         .C_AXI_DATA_WIDTH          (C_SLOT_1_AXI_DATA_WIDTH), 
         .C_AXI_ID_WIDTH            (C_SLOT_1_AXI_ID_WIDTH), 
         .C_AXI_PROTOCOL            (C_SLOT_1_AXI_PROTOCOL), 
         .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS)
      )
		triggerMarker_slot1 (
			    // Outputs
			    .Log_Data_Marked	(Slot_1_Log_Marked),
			    .Log_en_out		(Slot_1_Log_En_Marked),
			    // Inputs
			    .clk		  (core_aclk),
			    .rst_n	  (stream_fifo_rst_n),
			    .trigger  (trigger),
			    .reStart  (Metrics_Cnt_Reset_sync),
			    .Log_Data (Slot_1_Log),
			    .Log_En	  (Slot_1_Log_En)
			    );

     end
      else if((C_ENABLE_EVENT_LOG == 1 && C_EN_TRIGGER == 0) || C_NUM_MONITOR_SLOTS < 2 ) begin :GEN_S1_NO_POST_TRIGGER
      assign Slot_1_Log_Marked = Slot_1_Log;
      assign Slot_1_Log_En_Marked = Slot_1_Log_En;
      end
      endgenerate

     //-- Slot 2
     generate
     if((C_NUM_MONITOR_SLOTS > 2)) begin :GEN_SLOT2

         axi_perf_mon_v5_0_12_mon_fifo
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
           .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S2),
           .C_FIFO_ENABLE             (C_SLOT_2_FIFO_ENABLE) 
          ) mon_fifo_inst_2
          (
           .Mon_clk                   (SLOT_2_clk),
           .Mon_rst_n                 (SLOT_2_Arst_n),
           .Data_In                   (Slot_2_Data_In),
           //.mon_en                    (Metrics_Cnt_En_sync),
           .CORE_ACLK                 (core_aclk),
           .CORE_ARESETN              (core_aresetn),
           .Sync_Data_Out             (Slot_2_Sync_Data_Out),
           .Sync_Data_Valid           (Slot_2_Sync_Data_Valid)
          );

          assign Ext_Event2_Data_In = {ext_event_2_cnt_start,ext_event_2_cnt_stop,ext_event_2};
     
          // External Event1 through monitor FIFO
          axi_perf_mon_v5_0_12_mon_fifo
             #(
               .C_FAMILY                  (C_FAMILY),
               .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
               .C_MON_FIFO_DATA_WIDTH     (3),
               .C_FIFO_ENABLE             (C_EXT_EVENT2_FIFO_ENABLE) 
              ) mon_fifo_ext_event2_inst
              (
               .Mon_clk                   (ext_clk_2),
               .Mon_rst_n                 (ext_rstn_2),
               .Data_In                   (Ext_Event2_Data_In),
               //.mon_en                    (Metrics_Cnt_En_sync),
               .CORE_ACLK                 (core_aclk),
               .CORE_ARESETN              (core_aresetn),
               .Sync_Data_Out             (Ext_Event2_Sync_Data_Out),
               .Sync_Data_Valid           (Ext_Event2_Sync_Data_Valid)
              );

         
         // External Event2 count enable generation module
         axi_perf_mon_v5_0_12_ext_calc ext_calc_inst2  
            (
              .clk                    (core_aclk),        
              .rst_n                  (core_aresetn),     
              .Ext_Event              (Ext_Event2_Sync_Data_Out[0]),
              .Ext_Event_Start        (Ext_Event2_Sync_Data_Out[2]),
              .Ext_Event_Stop         (Ext_Event2_Sync_Data_Out[1]),
              .Ext_Event_Valid        (Ext_Event2_Sync_Data_Valid ),
              .Metrics_Cnt_En         (Metrics_Cnt_En_sync),
              .Metrics_Cnt_Reset      (Metrics_Cnt_Reset_sync),
              .External_Event_Cnt_En  (External_Event_Cnt_En[2])
            );

          // Metric calculator instance for slot2
          axi_perf_mon_v5_0_12_metric_calc 
            #(
              .C_AXIID                (C_SLOT_2_AXI_ID_WIDTH    ),
              .C_AXIADDR              (C_SLOT_2_AXI_ADDR_WIDTH  ),
              .C_AXIDATA              (C_SLOT_2_AXI_DATA_WIDTH  ),
              .C_AXISDATA             (C_SLOT_2_AXIS_TDATA_WIDTH),
              .C_AXISID               (C_SLOT_2_AXIS_TID_WIDTH  ),
              .C_AXISDEST             (C_SLOT_2_AXIS_TDEST_WIDTH),
              .C_AXISUSER             (C_SLOT_2_AXIS_TUSER_WIDTH),
              .C_OUTSTAND_DEPTH       (C_MAX_OUTSTAND_DEPTH),
              .C_METRIC_COUNT_WIDTH   (C_METRIC_COUNT_WIDTH),
              .C_MON_FIFO_WIDTH       (C_MON_FIFO_DWIDTH_S2),
              .C_AXI_PROTOCOL         (C_SLOT_2_AXI_PROTOCOL),
              .C_AXI_SUB_PROTOCOL     (C_SLOT_2_AXI_SUB_PROTOCOL)
            ) metric_calc_inst2
            (
              .clk                    (core_aclk ),
              .rst_n                  (core_aresetn),
              .Data_In                (Slot_2_Sync_Data_Out),
              .Data_Valid             (Slot_2_Sync_Data_Valid), 
              .Metrics_Cnt_En         (Metrics_Cnt_En_sync),
              .Metrics_Cnt_Reset      (Metrics_Cnt_Reset_sync),
              .Use_Ext_Trig           (Use_Ext_Trig_sync),
              .Ext_Trig               (slot_2_ext_trig),
              .Ext_Trig_Stop          (slot_2_ext_trig_stop),
              .Latency_WID            (Latency_WID),
              .Latency_RID            (Latency_RID),
              .WID_Mask               (WID_Mask),
              .RID_Mask               (RID_Mask),
              .En_Id_Based            (En_Id_Based_sync),  
              .Wr_Lat_Start           (Wr_Lat_Start),  //0 Address Issue 1 Address acceptance
              .Wr_Lat_End             (Wr_Lat_End),    //1 First write   0 Last write  
              .Rd_Lat_Start           (Rd_Lat_Start),  //0 Address Issue 1 Address acceptance 
              .Rd_Lat_End             (Rd_Lat_End),    //1 First Read    0 Last Read
              .Wtrans_Cnt_En          (Wtrans_Cnt_En[2]),
              .Rtrans_Cnt_En          (Rtrans_Cnt_En[2]),
              .Write_Byte_Cnt         (S2_Write_Byte_Cnt),
              .Read_Byte_Cnt          (S2_Read_Byte_Cnt),
              .Read_Byte_Cnt_En       (S2_Read_Byte_Cnt_En),
              .Write_Beat_Cnt_En      (Write_Beat_Cnt_En[2]),
              .Read_Beat_Cnt_En       (Read_Beat_Cnt_En[2]),
              .Read_Latency           (S2_Read_Latency),
              .Write_Latency          (S2_Write_Latency),
              .Write_Beat_Cnt         (S2_Write_Beat_Cnt),
              .Slv_Wr_Idle_Cnt        (S2_Slv_Wr_Idle_Cnt),
              .Read_Latency_En        (Read_Latency_En[2]),    
              .Write_Latency_En       (Write_Latency_En[2]),   
              .Slv_Wr_Idle_Cnt_En     (Slv_Wr_Idle_Cnt_En[2]), 
              .Mst_Rd_Idle_Cnt_En     (Mst_Rd_Idle_Cnt_En[2]), 
              .Num_BValids_En         (Num_BValids_En[2]),     
              .Num_WLasts_En          (Num_WLasts_En[2]),      
              .Num_RLasts_En          (Num_RLasts_En[2]),      
              .S_Transfer_Cnt_En      (S_Transfer_Cnt_En[2]),
              .S_Packet_Cnt_En        (S_Packet_Cnt_En[2]),  
              .S_Data_Byte_Cnt        (S2_S_Data_Byte_Cnt),
              .S_Position_Byte_Cnt    (S2_S_Position_Byte_Cnt),
              .S_Null_Byte_Cnt        (S2_S_Null_Byte_Cnt),
              .S_Slv_Idle_Cnt_En      (S_Slv_Idle_Cnt_En[2]),
              .S_Mst_Idle_Cnt_En      (S_Mst_Idle_Cnt_En[2]),
              .Max_Write_Latency      (S2_Max_Write_Latency),                   
              .Min_Write_Latency      (S2_Min_Write_Latency),                   
              .Max_Read_Latency       (S2_Max_Read_Latency),                   
              .Min_Read_Latency       (S2_Min_Read_Latency)
            );
     end
     else begin :GEN_NO_SLOT2
         assign S2_Write_Beat_Cnt = 0;
         assign S2_Slv_Wr_Idle_Cnt = 0;
         assign Slot_2_Sync_Data_Out = 0;
         assign S2_Write_Byte_Cnt    = 0;
         assign S2_Read_Byte_Cnt     = 0;
         assign S2_Read_Latency      = 0;
         assign S2_Write_Latency     = 0;
         assign S2_S_Data_Byte_Cnt   = 0;
         assign S2_S_Position_Byte_Cnt = 0;
         assign S2_S_Null_Byte_Cnt     = 0;
         assign Ext_Event2_Sync_Data_Out = 0;
         assign Ext_Event2_Sync_Data_Valid = 0;
         assign S2_Max_Write_Latency  = 0;                  
         assign S2_Min_Write_Latency  = 0;               
         assign S2_Max_Read_Latency   = 0;               
         assign S2_Min_Read_Latency   = 0;
     end
     endgenerate 

    generate    
    if (C_ENABLE_EVENT_LOG == 1 && C_NUM_MONITOR_SLOTS > 2) begin : GEN_FLAGS2
       //Flag Generator instantiation for slot2
         axi_perf_mon_v5_0_12_flags_gen
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S2), 
           .C_LOG_WIDTH               (C_SLOT_2_LOG_WIDTH),
           .C_FLAG_WIDTH              (C_SLOT_2_FLAG_WIDTH), 
           .C_AXI_ADDR_WIDTH          (C_SLOT_2_AXI_ADDR_WIDTH), 
           .C_AXI_DATA_WIDTH          (C_SLOT_2_AXI_DATA_WIDTH), 
           .C_AXI_ID_WIDTH            (C_SLOT_2_AXI_ID_WIDTH), 
           .C_AXI_PROTOCOL            (C_SLOT_2_AXI_PROTOCOL), 
           .C_AXIS_TDATA_WIDTH        (C_SLOT_2_AXIS_TDATA_WIDTH), 
           .C_AXIS_TID_WIDTH          (C_SLOT_2_AXIS_TID_WIDTH), 
           .C_AXIS_TDEST_WIDTH        (C_SLOT_2_AXIS_TDEST_WIDTH), 
           .C_AXIS_TUSER_WIDTH        (C_SLOT_2_AXIS_TUSER_WIDTH),
           .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
           .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
           .C_SHOW_AXIS_TID           (C_SHOW_AXIS_TID),
           .C_SHOW_AXIS_TUSER         (C_SHOW_AXIS_TUSER),
           .C_SHOW_AXIS_TDEST         (C_SHOW_AXIS_TDEST), 
           .C_EN_AXI_DEBUG               (C_EN_AXI_DEBUG) 
          ) flags_generator_inst_2
          (
           .clk                       (core_aclk),
           .rst_n                     (core_aresetn),
           .Data_In                   (Slot_2_Sync_Data_Out),
           .Data_Valid                (Slot_2_Sync_Data_Valid), 
           .Flag_Enable_Reg           (Flag_Enable_Reg),
           .Ext_Trig                  (slot_2_ext_trig),
           .Ext_Trig_Stop             (slot_2_ext_trig_stop),
           .Use_Ext_Trig_Log          (Use_Ext_Trig_Log_sync),                
           .Log_Data                  (Slot_2_Log),
           .Log_En                    (Slot_2_Log_En),
           .Ext_Data_in               (Ext_Event2_Sync_Data_Out),
           .Ext_Data_Valid            (Ext_Event2_Sync_Data_Valid),
           .Ext_Event_Flag_En         (Ext_Event_Flag_En),
           .Ext_Event_Flags           (Ext_Event2_Flags)
          );

    end 
    else begin : GEN_NO_FLAGS2
       assign Slot_2_Log = 0;
       assign Slot_2_Log_En = 1'b0;
       assign Ext_Event2_Flags = 0;
    end 
    endgenerate
generate if(C_NUM_MONITOR_SLOTS > 2 && C_ENABLE_EVENT_LOG == 1 && C_EN_TRIGGER == 1) begin : GEN_S2_POST_TRIGGER
//Aligning start and end events of transactions
       axi_perf_mon_v5_0_12_postTriggerMarker 
	    #(
			   // Parameters
			.C_FAMILY                  (C_FAMILY),
         .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S2), 
         .C_LOG_WIDTH               (C_SLOT_2_LOG_WIDTH),
         .C_FLAG_WIDTH              (C_SLOT_N_FLAG_WIDTH), 
         .C_AXI_ADDR_WIDTH          (C_SLOT_2_AXI_ADDR_WIDTH), 
         .C_AXI_DATA_WIDTH          (C_SLOT_2_AXI_DATA_WIDTH), 
         .C_AXI_ID_WIDTH            (C_SLOT_2_AXI_ID_WIDTH), 
         .C_AXI_PROTOCOL            (C_SLOT_2_AXI_PROTOCOL), 
         .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS)
      )
		triggerMarker_slot2 (
			    // Outputs
			    .Log_Data_Marked	(Slot_2_Log_Marked),
			    .Log_en_out		(Slot_2_Log_En_Marked),
			    // Inputs
			    .clk		  (core_aclk),
			    .rst_n	  (stream_fifo_rst_n),
			    .trigger  (trigger),
			    .reStart  (Metrics_Cnt_Reset_sync),
			    .Log_Data (Slot_2_Log),
			    .Log_En	  (Slot_2_Log_En)
			    );

     end
      else if((C_ENABLE_EVENT_LOG == 1 && C_EN_TRIGGER == 0) || C_NUM_MONITOR_SLOTS < 3) begin :GEN_S2_NO_POST_TRIGGER
      assign Slot_2_Log_Marked = Slot_2_Log;
      assign Slot_2_Log_En_Marked = Slot_2_Log_En;
      end
      endgenerate

     //-- Slot 3
     generate
     if((C_NUM_MONITOR_SLOTS > 3)) begin :GEN_SLOT3

         axi_perf_mon_v5_0_12_mon_fifo
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
           .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S3),
           .C_FIFO_ENABLE             (C_SLOT_3_FIFO_ENABLE) 
          ) mon_fifo_inst_3
          (
           .Mon_clk                   (SLOT_3_clk),
           .Mon_rst_n                 (SLOT_3_Arst_n),
           .Data_In                   (Slot_3_Data_In),
           //.mon_en                    (Metrics_Cnt_En_sync),
           .CORE_ACLK                 (core_aclk),
           .CORE_ARESETN              (core_aresetn),
           .Sync_Data_Out             (Slot_3_Sync_Data_Out),
           .Sync_Data_Valid           (Slot_3_Sync_Data_Valid)
          );

          assign Ext_Event3_Data_In = {ext_event_3_cnt_start,ext_event_3_cnt_stop,ext_event_3};
     
          // External Event1 through monitor FIFO
          axi_perf_mon_v5_0_12_mon_fifo
             #(
               .C_FAMILY                  (C_FAMILY),
               .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
               .C_MON_FIFO_DATA_WIDTH     (3),
               .C_FIFO_ENABLE             (C_EXT_EVENT3_FIFO_ENABLE) 
              ) mon_fifo_ext_event3_inst
              (
               .Mon_clk                   (ext_clk_3),
               .Mon_rst_n                 (ext_rstn_3),
               .Data_In                   (Ext_Event3_Data_In),
               //.mon_en                    (Metrics_Cnt_En_sync),
               .CORE_ACLK                 (core_aclk),
               .CORE_ARESETN              (core_aresetn),
               .Sync_Data_Out             (Ext_Event3_Sync_Data_Out),
               .Sync_Data_Valid           (Ext_Event3_Sync_Data_Valid)
              );

         // External Event3 count enable generation module
         axi_perf_mon_v5_0_12_ext_calc ext_calc_inst3  
            (
              .clk                    (core_aclk),        
              .rst_n                  (core_aresetn),     
              .Ext_Event              (Ext_Event3_Sync_Data_Out[0]),
              .Ext_Event_Start        (Ext_Event3_Sync_Data_Out[2]),
              .Ext_Event_Stop         (Ext_Event3_Sync_Data_Out[1]),
              .Ext_Event_Valid        (Ext_Event3_Sync_Data_Valid ),
              .Metrics_Cnt_En         (Metrics_Cnt_En_sync),
              .Metrics_Cnt_Reset      (Metrics_Cnt_Reset_sync),
              .External_Event_Cnt_En  (External_Event_Cnt_En[3])
            );

          // Metric calculator instance for slot3
          axi_perf_mon_v5_0_12_metric_calc 
         #(
           .C_AXIID                   (C_SLOT_3_AXI_ID_WIDTH    ),
           .C_AXIADDR                 (C_SLOT_3_AXI_ADDR_WIDTH  ),
           .C_AXIDATA                 (C_SLOT_3_AXI_DATA_WIDTH  ),
           .C_AXISDATA                (C_SLOT_3_AXIS_TDATA_WIDTH),
           .C_AXISID                  (C_SLOT_3_AXIS_TID_WIDTH  ),
           .C_AXISDEST                (C_SLOT_3_AXIS_TDEST_WIDTH),
           .C_AXISUSER                (C_SLOT_3_AXIS_TUSER_WIDTH),
           .C_OUTSTAND_DEPTH          (C_MAX_OUTSTAND_DEPTH),
           .C_METRIC_COUNT_WIDTH      (C_METRIC_COUNT_WIDTH),
           .C_MON_FIFO_WIDTH          (C_MON_FIFO_DWIDTH_S3),
           .C_AXI_PROTOCOL            (C_SLOT_3_AXI_PROTOCOL),
           .C_AXI_SUB_PROTOCOL        (C_SLOT_3_AXI_SUB_PROTOCOL)
         ) metric_calc_inst3
         (
           .clk                       (core_aclk ),
           .rst_n                     (core_aresetn),
           .Data_In                   (Slot_3_Sync_Data_Out),
           .Data_Valid                (Slot_3_Sync_Data_Valid), 
           .Metrics_Cnt_En            (Metrics_Cnt_En_sync),
           .Metrics_Cnt_Reset         (Metrics_Cnt_Reset_sync),
           .Use_Ext_Trig              (Use_Ext_Trig_sync),
           .Ext_Trig                  (slot_3_ext_trig),
           .Ext_Trig_Stop             (slot_3_ext_trig_stop),
           .Latency_WID               (Latency_WID),
           .Latency_RID               (Latency_RID),
           .WID_Mask                  (WID_Mask),
           .RID_Mask                  (RID_Mask),
           .En_Id_Based               (En_Id_Based_sync),  
           .Wr_Lat_Start              (Wr_Lat_Start    ),  //0 Address Issue 1 Address acceptance
           .Wr_Lat_End                (Wr_Lat_End      ),  //1 First write   0 Last write  
           .Rd_Lat_Start              (Rd_Lat_Start    ),  //0 Address Issue 1 Address acceptance 
           .Rd_Lat_End                (Rd_Lat_End      ),  //1 First Read    0 Last Read
           .Wtrans_Cnt_En             (Wtrans_Cnt_En[3]),
           .Rtrans_Cnt_En             (Rtrans_Cnt_En[3]),
           .Write_Byte_Cnt            (S3_Write_Byte_Cnt),
           .Read_Byte_Cnt             (S3_Read_Byte_Cnt),
           .Read_Byte_Cnt_En          (S3_Read_Byte_Cnt_En),
           .Write_Beat_Cnt_En         (Write_Beat_Cnt_En[3]),
           .Read_Beat_Cnt_En          (Read_Beat_Cnt_En[3]),
           .Read_Latency              (S3_Read_Latency),
           .Write_Latency             (S3_Write_Latency),
           .Write_Beat_Cnt            (S3_Write_Beat_Cnt),
           .Slv_Wr_Idle_Cnt           (S3_Slv_Wr_Idle_Cnt),
           .Read_Latency_En           (Read_Latency_En[3]),    
           .Write_Latency_En          (Write_Latency_En[3]),   
           .Slv_Wr_Idle_Cnt_En        (Slv_Wr_Idle_Cnt_En[3]), 
           .Mst_Rd_Idle_Cnt_En        (Mst_Rd_Idle_Cnt_En[3]), 
           .Num_BValids_En            (Num_BValids_En[3]),     
           .Num_WLasts_En             (Num_WLasts_En[3]),      
           .Num_RLasts_En             (Num_RLasts_En[3]),      
           .S_Transfer_Cnt_En         (S_Transfer_Cnt_En[3]),
           .S_Packet_Cnt_En           (S_Packet_Cnt_En[3]),  
           .S_Data_Byte_Cnt           (S3_S_Data_Byte_Cnt),
           .S_Position_Byte_Cnt       (S3_S_Position_Byte_Cnt),
           .S_Null_Byte_Cnt           (S3_S_Null_Byte_Cnt),
           .S_Slv_Idle_Cnt_En         (S_Slv_Idle_Cnt_En[3]),
           .S_Mst_Idle_Cnt_En         (S_Mst_Idle_Cnt_En[3]),
           .Max_Write_Latency         (S3_Max_Write_Latency),                   
           .Min_Write_Latency         (S3_Min_Write_Latency),                   
           .Max_Read_Latency          (S3_Max_Read_Latency),                   
           .Min_Read_Latency          (S3_Min_Read_Latency)
         );
     end
     else begin :GEN_NO_SLOT3
         assign S3_Write_Beat_Cnt = 0;
         assign S3_Slv_Wr_Idle_Cnt = 0;
         assign Slot_3_Sync_Data_Out = 0;
         assign S3_Write_Byte_Cnt    = 0;
         assign S3_Read_Byte_Cnt     = 0;
         assign S3_Read_Latency      = 0;
         assign S3_Write_Latency     = 0;
         assign S3_S_Data_Byte_Cnt   = 0;
         assign S3_S_Position_Byte_Cnt = 0;
         assign S3_S_Null_Byte_Cnt     = 0;
         assign Ext_Event3_Sync_Data_Out = 0;
         assign Ext_Event3_Sync_Data_Valid = 0;
         assign S3_Max_Write_Latency  = 0;                  
         assign S3_Min_Write_Latency  = 0;               
         assign S3_Max_Read_Latency   = 0;               
         assign S3_Min_Read_Latency   = 0;
     end
     endgenerate 

    generate    
    if (C_ENABLE_EVENT_LOG == 1 && C_NUM_MONITOR_SLOTS > 3) begin : GEN_FLAGS3
       //Flag Generator instantiation for slot3
         axi_perf_mon_v5_0_12_flags_gen
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S3), 
           .C_LOG_WIDTH               (C_SLOT_3_LOG_WIDTH),
           .C_FLAG_WIDTH              (C_SLOT_3_FLAG_WIDTH), 
           .C_AXI_ADDR_WIDTH          (C_SLOT_3_AXI_ADDR_WIDTH), 
           .C_AXI_DATA_WIDTH          (C_SLOT_3_AXI_DATA_WIDTH), 
           .C_AXI_ID_WIDTH            (C_SLOT_3_AXI_ID_WIDTH), 
           .C_AXI_PROTOCOL            (C_SLOT_3_AXI_PROTOCOL), 
           .C_AXIS_TDATA_WIDTH        (C_SLOT_3_AXIS_TDATA_WIDTH), 
           .C_AXIS_TID_WIDTH          (C_SLOT_3_AXIS_TID_WIDTH), 
           .C_AXIS_TDEST_WIDTH        (C_SLOT_3_AXIS_TDEST_WIDTH), 
           .C_AXIS_TUSER_WIDTH        (C_SLOT_3_AXIS_TUSER_WIDTH),
           .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
           .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
           .C_SHOW_AXIS_TID           (C_SHOW_AXIS_TID),
           .C_SHOW_AXIS_TUSER         (C_SHOW_AXIS_TUSER),
           .C_SHOW_AXIS_TDEST         (C_SHOW_AXIS_TDEST), 
           .C_EN_AXI_DEBUG               (C_EN_AXI_DEBUG) 
          ) flags_generator_inst_3
          (
           .clk                       (core_aclk),
           .rst_n                     (core_aresetn),
           .Data_In                   (Slot_3_Sync_Data_Out),
           .Data_Valid                (Slot_3_Sync_Data_Valid), 
           .Flag_Enable_Reg           (Flag_Enable_Reg),
           .Ext_Trig                  (slot_3_ext_trig),
           .Ext_Trig_Stop             (slot_3_ext_trig_stop),
           .Use_Ext_Trig_Log          (Use_Ext_Trig_Log_sync),                
           .Log_Data                  (Slot_3_Log),
           .Log_En                    (Slot_3_Log_En),
           .Ext_Data_in               (Ext_Event3_Sync_Data_Out),
           .Ext_Data_Valid            (Ext_Event3_Sync_Data_Valid),
           .Ext_Event_Flag_En         (Ext_Event_Flag_En),
           .Ext_Event_Flags           (Ext_Event3_Flags)
          );
    end 
    else begin : GEN_NO_FLAGS3
       assign Slot_3_Log = 0;
       assign Slot_3_Log_En = 1'b0;
       assign Ext_Event3_Flags = 0;
    end 
    endgenerate
 generate if(C_NUM_MONITOR_SLOTS > 3 && C_ENABLE_EVENT_LOG == 1 && C_EN_TRIGGER == 1) begin : GEN_S3_POST_TRIGGER
//Aligning start and end events of transactions
       axi_perf_mon_v5_0_12_postTriggerMarker 
	    #(
			   // Parameters
			.C_FAMILY                  (C_FAMILY),
         .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S3), 
         .C_LOG_WIDTH               (C_SLOT_3_LOG_WIDTH),
         .C_FLAG_WIDTH              (C_SLOT_N_FLAG_WIDTH), 
         .C_AXI_ADDR_WIDTH          (C_SLOT_3_AXI_ADDR_WIDTH), 
         .C_AXI_DATA_WIDTH          (C_SLOT_3_AXI_DATA_WIDTH), 
         .C_AXI_ID_WIDTH            (C_SLOT_3_AXI_ID_WIDTH), 
         .C_AXI_PROTOCOL            (C_SLOT_3_AXI_PROTOCOL), 
         .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS)
      )
		triggerMarker_slot3 (
			    // Outputs
			    .Log_Data_Marked	(Slot_3_Log_Marked),
			    .Log_en_out		(Slot_3_Log_En_Marked),
			    // Inputs
			    .clk		  (core_aclk),
			    .rst_n	  (stream_fifo_rst_n),
			    .trigger  (trigger),
			    .reStart  (Metrics_Cnt_Reset_sync),
			    .Log_Data (Slot_3_Log),
			    .Log_En	  (Slot_3_Log_En)
			    );

     end
      else if((C_ENABLE_EVENT_LOG == 1 && C_EN_TRIGGER == 0) || C_NUM_MONITOR_SLOTS < 4) begin :GEN_S3_NO_POST_TRIGGER
      assign Slot_3_Log_Marked = Slot_3_Log;
      assign Slot_3_Log_En_Marked = Slot_3_Log_En;
      end
      endgenerate

     //-- Slot 4
     generate
     if((C_NUM_MONITOR_SLOTS > 4)) begin :GEN_SLOT4

         axi_perf_mon_v5_0_12_mon_fifo
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
           .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S4),
           .C_FIFO_ENABLE             (C_SLOT_4_FIFO_ENABLE) 
          ) mon_fifo_inst_4
          (
           .Mon_clk                   (SLOT_4_clk),
           .Mon_rst_n                 (SLOT_4_Arst_n),
           .Data_In                   (Slot_4_Data_In),
           //.mon_en                    (Metrics_Cnt_En_sync),
           .CORE_ACLK                 (core_aclk),
           .CORE_ARESETN              (core_aresetn),
           .Sync_Data_Out             (Slot_4_Sync_Data_Out),
           .Sync_Data_Valid           (Slot_4_Sync_Data_Valid)
          );

          assign Ext_Event4_Data_In = {ext_event_4_cnt_start,ext_event_4_cnt_stop,ext_event_4};
     
          // External Event1 through monitor FIFO
          axi_perf_mon_v5_0_12_mon_fifo
             #(
               .C_FAMILY                  (C_FAMILY),
               .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
               .C_MON_FIFO_DATA_WIDTH     (3),
               .C_FIFO_ENABLE             (C_EXT_EVENT4_FIFO_ENABLE) 
              ) mon_fifo_ext_event4_inst
              (
               .Mon_clk                   (ext_clk_4),
               .Mon_rst_n                 (ext_rstn_4),
               .Data_In                   (Ext_Event4_Data_In),
               //.mon_en                    (Metrics_Cnt_En_sync),
               .CORE_ACLK                 (core_aclk),
               .CORE_ARESETN              (core_aresetn),
               .Sync_Data_Out             (Ext_Event4_Sync_Data_Out),
               .Sync_Data_Valid           (Ext_Event4_Sync_Data_Valid)
              );


          // External Event4 count enable generation module
         axi_perf_mon_v5_0_12_ext_calc ext_calc_inst4  
            (
              .clk                    (core_aclk),        
              .rst_n                  (core_aresetn),     
              .Ext_Event              (Ext_Event4_Sync_Data_Out[0]),
              .Ext_Event_Start        (Ext_Event4_Sync_Data_Out[2]),
              .Ext_Event_Stop         (Ext_Event4_Sync_Data_Out[1]),
              .Ext_Event_Valid        (Ext_Event4_Sync_Data_Valid ),
              .Metrics_Cnt_En         (Metrics_Cnt_En_sync),
              .Metrics_Cnt_Reset      (Metrics_Cnt_Reset_sync),
              .External_Event_Cnt_En  (External_Event_Cnt_En[4])
            );

         // Metric calculator instance for slot4
          axi_perf_mon_v5_0_12_metric_calc 
             #(
            .C_AXIID                   (C_SLOT_4_AXI_ID_WIDTH    ),
            .C_AXIADDR                 (C_SLOT_4_AXI_ADDR_WIDTH  ),
            .C_AXIDATA                 (C_SLOT_4_AXI_DATA_WIDTH  ),
            .C_AXISDATA                (C_SLOT_4_AXIS_TDATA_WIDTH),
            .C_AXISID                  (C_SLOT_4_AXIS_TID_WIDTH  ),
            .C_AXISDEST                (C_SLOT_4_AXIS_TDEST_WIDTH),
            .C_AXISUSER                (C_SLOT_4_AXIS_TUSER_WIDTH),
            .C_OUTSTAND_DEPTH          (C_MAX_OUTSTAND_DEPTH),
            .C_METRIC_COUNT_WIDTH      (C_METRIC_COUNT_WIDTH),
            .C_MON_FIFO_WIDTH          (C_MON_FIFO_DWIDTH_S4),
            .C_AXI_PROTOCOL            (C_SLOT_4_AXI_PROTOCOL),
            .C_AXI_SUB_PROTOCOL        (C_SLOT_4_AXI_SUB_PROTOCOL)
             ) metric_calc_inst4
          (
            .clk                       (core_aclk ),
            .rst_n                     (core_aresetn),
            .Data_In                   (Slot_4_Sync_Data_Out),
            .Data_Valid                (Slot_4_Sync_Data_Valid), 
            .Metrics_Cnt_En            (Metrics_Cnt_En_sync),
            .Metrics_Cnt_Reset         (Metrics_Cnt_Reset_sync),
            .Use_Ext_Trig              (Use_Ext_Trig_sync),
            .Ext_Trig                  (slot_4_ext_trig),
            .Ext_Trig_Stop             (slot_4_ext_trig_stop),
            .Latency_WID               (Latency_WID),
            .Latency_RID               (Latency_RID),
            .WID_Mask                  (WID_Mask),
            .RID_Mask                  (RID_Mask),
            .En_Id_Based               (En_Id_Based_sync),  
            .Wr_Lat_Start              (Wr_Lat_Start    ),  //0 Address Issue 1 Address acceptance
            .Wr_Lat_End                (Wr_Lat_End      ),  //1 First write   0 Last write  
            .Rd_Lat_Start              (Rd_Lat_Start    ),  //0 Address Issue 1 Address acceptance 
            .Rd_Lat_End                (Rd_Lat_End      ),  //1 First Read    0 Last Read
            .Wtrans_Cnt_En             (Wtrans_Cnt_En[4]),
            .Rtrans_Cnt_En             (Rtrans_Cnt_En[4]),
            .Write_Byte_Cnt            (S4_Write_Byte_Cnt),
            .Read_Byte_Cnt             (S4_Read_Byte_Cnt),
            .Read_Byte_Cnt_En          (S4_Read_Byte_Cnt_En),
            .Write_Beat_Cnt_En         (Write_Beat_Cnt_En[4]),
            .Read_Beat_Cnt_En          (Read_Beat_Cnt_En[4]),
            .Read_Latency              (S4_Read_Latency),
            .Write_Latency             (S4_Write_Latency),
            .Write_Beat_Cnt            (S4_Write_Beat_Cnt),
            .Slv_Wr_Idle_Cnt           (S4_Slv_Wr_Idle_Cnt),
            .Read_Latency_En           (Read_Latency_En[4]),    
            .Write_Latency_En          (Write_Latency_En[4]),   
            .Slv_Wr_Idle_Cnt_En        (Slv_Wr_Idle_Cnt_En[4]), 
            .Mst_Rd_Idle_Cnt_En        (Mst_Rd_Idle_Cnt_En[4]), 
            .Num_BValids_En            (Num_BValids_En[4]),     
            .Num_WLasts_En             (Num_WLasts_En[4]),      
            .Num_RLasts_En             (Num_RLasts_En[4]),      
            .S_Transfer_Cnt_En         (S_Transfer_Cnt_En[4]),
            .S_Packet_Cnt_En           (S_Packet_Cnt_En[4]),  
            .S_Data_Byte_Cnt           (S4_S_Data_Byte_Cnt),
            .S_Position_Byte_Cnt       (S4_S_Position_Byte_Cnt),
            .S_Null_Byte_Cnt           (S4_S_Null_Byte_Cnt),
            .S_Slv_Idle_Cnt_En         (S_Slv_Idle_Cnt_En[4]),
            .S_Mst_Idle_Cnt_En         (S_Mst_Idle_Cnt_En[4]),
            .Max_Write_Latency         (S4_Max_Write_Latency),                   
            .Min_Write_Latency         (S4_Min_Write_Latency),                   
            .Max_Read_Latency          (S4_Max_Read_Latency),                   
            .Min_Read_Latency          (S4_Min_Read_Latency)
          );
     end
     else begin :GEN_NO_SLOT4
         assign S4_Write_Beat_Cnt = 0;
         assign S4_Slv_Wr_Idle_Cnt = 0;
         assign Slot_4_Sync_Data_Out = 0;
         assign S4_Write_Byte_Cnt    = 0;
         assign S4_Read_Byte_Cnt     = 0;
         assign S4_Read_Latency      = 0;
         assign S4_Write_Latency     = 0;
         assign S4_S_Data_Byte_Cnt   = 0;
         assign S4_S_Position_Byte_Cnt = 0;
         assign S4_S_Null_Byte_Cnt     = 0;
         assign Ext_Event4_Sync_Data_Out = 0;
         assign Ext_Event4_Sync_Data_Valid = 0;
         assign S4_Max_Write_Latency  = 0;                  
         assign S4_Min_Write_Latency  = 0;               
         assign S4_Max_Read_Latency   = 0;               
         assign S4_Min_Read_Latency   = 0;
     end
     endgenerate 

    generate    
    if (C_ENABLE_EVENT_LOG == 1 && C_NUM_MONITOR_SLOTS > 4) begin : GEN_FLAGS4
                //Flag Generator instantiation for slot4
         axi_perf_mon_v5_0_12_flags_gen
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S4), 
           .C_LOG_WIDTH               (C_SLOT_4_LOG_WIDTH),
           .C_FLAG_WIDTH              (C_SLOT_4_FLAG_WIDTH), 
           .C_AXI_ADDR_WIDTH          (C_SLOT_4_AXI_ADDR_WIDTH), 
           .C_AXI_DATA_WIDTH          (C_SLOT_4_AXI_DATA_WIDTH), 
           .C_AXI_ID_WIDTH            (C_SLOT_4_AXI_ID_WIDTH), 
           .C_AXI_PROTOCOL            (C_SLOT_4_AXI_PROTOCOL), 
           .C_AXIS_TDATA_WIDTH        (C_SLOT_4_AXIS_TDATA_WIDTH), 
           .C_AXIS_TID_WIDTH          (C_SLOT_4_AXIS_TID_WIDTH), 
           .C_AXIS_TDEST_WIDTH        (C_SLOT_4_AXIS_TDEST_WIDTH), 
           .C_AXIS_TUSER_WIDTH        (C_SLOT_4_AXIS_TUSER_WIDTH),
           .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
           .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
           .C_SHOW_AXIS_TID           (C_SHOW_AXIS_TID),
           .C_SHOW_AXIS_TUSER         (C_SHOW_AXIS_TUSER),
           .C_SHOW_AXIS_TDEST         (C_SHOW_AXIS_TDEST), 
           .C_EN_AXI_DEBUG               (C_EN_AXI_DEBUG) 
          ) flags_generator_inst_4
          (
           .clk                       (core_aclk),
           .rst_n                     (core_aresetn),
           .Data_In                   (Slot_4_Sync_Data_Out),
           .Data_Valid                (Slot_4_Sync_Data_Valid), 
           .Flag_Enable_Reg           (Flag_Enable_Reg),
           .Ext_Trig                  (slot_4_ext_trig),
           .Ext_Trig_Stop             (slot_4_ext_trig_stop),
           .Use_Ext_Trig_Log          (Use_Ext_Trig_Log_sync),                
           .Log_Data                  (Slot_4_Log),
           .Log_En                    (Slot_4_Log_En),
           .Ext_Data_in               (Ext_Event4_Sync_Data_Out),
           .Ext_Data_Valid            (Ext_Event4_Sync_Data_Valid),
           .Ext_Event_Flag_En         (Ext_Event_Flag_En),
           .Ext_Event_Flags           (Ext_Event4_Flags)
          );

    end 
    else begin : GEN_NO_FLAGS4
       assign Slot_4_Log = 0;
       assign Slot_4_Log_En = 1'b0;
       assign Ext_Event4_Flags = 0;
    end 
    endgenerate
 generate if(C_NUM_MONITOR_SLOTS > 4 && C_ENABLE_EVENT_LOG == 1 && C_EN_TRIGGER == 1) begin : GEN_S4_POST_TRIGGER
//Aligning start and end events of transactions
       axi_perf_mon_v5_0_12_postTriggerMarker 
	    #(
			   // Parameters
			.C_FAMILY                  (C_FAMILY),
         .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S4), 
         .C_LOG_WIDTH               (C_SLOT_4_LOG_WIDTH),
         .C_FLAG_WIDTH              (C_SLOT_N_FLAG_WIDTH), 
         .C_AXI_ADDR_WIDTH          (C_SLOT_4_AXI_ADDR_WIDTH), 
         .C_AXI_DATA_WIDTH          (C_SLOT_4_AXI_DATA_WIDTH), 
         .C_AXI_ID_WIDTH            (C_SLOT_4_AXI_ID_WIDTH), 
         .C_AXI_PROTOCOL            (C_SLOT_4_AXI_PROTOCOL), 
         .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS)
      )
		triggerMarker_slot4 (
			    // Outputs
			    .Log_Data_Marked	(Slot_4_Log_Marked),
			    .Log_en_out		(Slot_4_Log_En_Marked),
			    // Inputs
			    .clk		  (core_aclk),
			    .rst_n	  (stream_fifo_rst_n),
			    .trigger  (trigger),
			    .reStart  (Metrics_Cnt_Reset_sync),
			    .Log_Data (Slot_4_Log),
			    .Log_En	  (Slot_4_Log_En)
			    );

     end
      else if((C_ENABLE_EVENT_LOG == 1 && C_EN_TRIGGER == 0) || C_NUM_MONITOR_SLOTS < 5) begin :GEN_S4_NO_POST_TRIGGER
      assign Slot_4_Log_Marked = Slot_4_Log;
      assign Slot_4_Log_En_Marked = Slot_4_Log_En;
      end
      endgenerate
     //-- Slot 5
     generate
     if((C_NUM_MONITOR_SLOTS > 5)) begin :GEN_SLOT5

         axi_perf_mon_v5_0_12_mon_fifo
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
           .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S5),
           .C_FIFO_ENABLE             (C_SLOT_5_FIFO_ENABLE) 
          ) mon_fifo_inst_5
          (
           .Mon_clk                   (SLOT_5_clk),
           .Mon_rst_n                 (SLOT_5_Arst_n),
           .Data_In                   (Slot_5_Data_In),
           //.mon_en                    (Metrics_Cnt_En_sync),
           .CORE_ACLK                 (core_aclk),
           .CORE_ARESETN              (core_aresetn),
           .Sync_Data_Out             (Slot_5_Sync_Data_Out),
           .Sync_Data_Valid           (Slot_5_Sync_Data_Valid)
          );
         
        assign Ext_Event5_Data_In = {ext_event_5_cnt_start,ext_event_5_cnt_stop,ext_event_5};
     
         // External Event1 through monitor FIFO
         axi_perf_mon_v5_0_12_mon_fifo
             #(
               .C_FAMILY                  (C_FAMILY),
               .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
               .C_MON_FIFO_DATA_WIDTH     (3),
               .C_FIFO_ENABLE             (C_EXT_EVENT5_FIFO_ENABLE) 
              ) mon_fifo_ext_event5_inst
              (
               .Mon_clk                   (ext_clk_5),
               .Mon_rst_n                 (ext_rstn_5),
               .Data_In                   (Ext_Event5_Data_In),
               //.mon_en                    (Metrics_Cnt_En_sync),
               .CORE_ACLK                 (core_aclk),
               .CORE_ARESETN              (core_aresetn),
               .Sync_Data_Out             (Ext_Event5_Sync_Data_Out),
               .Sync_Data_Valid           (Ext_Event5_Sync_Data_Valid)
              );

         // External Event5 count enable generation module
         axi_perf_mon_v5_0_12_ext_calc ext_calc_inst5  
            (
              .clk                    (core_aclk),        
              .rst_n                  (core_aresetn),     
              .Ext_Event              (Ext_Event5_Sync_Data_Out[0]),
              .Ext_Event_Start        (Ext_Event5_Sync_Data_Out[2]),
              .Ext_Event_Stop         (Ext_Event5_Sync_Data_Out[1]),
              .Ext_Event_Valid        (Ext_Event5_Sync_Data_Valid ),
              .Metrics_Cnt_En         (Metrics_Cnt_En_sync),
              .Metrics_Cnt_Reset      (Metrics_Cnt_Reset_sync),
              .External_Event_Cnt_En  (External_Event_Cnt_En[5])
            );

         // Metric calculator instance for slot5
          axi_perf_mon_v5_0_12_metric_calc 
          #(
            .C_AXIID                   (C_SLOT_5_AXI_ID_WIDTH    ),
            .C_AXIADDR                 (C_SLOT_5_AXI_ADDR_WIDTH  ),
            .C_AXIDATA                 (C_SLOT_5_AXI_DATA_WIDTH  ),
            .C_AXISDATA                (C_SLOT_5_AXIS_TDATA_WIDTH),
            .C_AXISID                  (C_SLOT_5_AXIS_TID_WIDTH  ),
            .C_AXISDEST                (C_SLOT_5_AXIS_TDEST_WIDTH),
            .C_AXISUSER                (C_SLOT_5_AXIS_TUSER_WIDTH),
            .C_OUTSTAND_DEPTH          (C_MAX_OUTSTAND_DEPTH),
            .C_METRIC_COUNT_WIDTH      (C_METRIC_COUNT_WIDTH),
            .C_MON_FIFO_WIDTH          (C_MON_FIFO_DWIDTH_S5),
            .C_AXI_PROTOCOL            (C_SLOT_5_AXI_PROTOCOL),
            .C_AXI_SUB_PROTOCOL        (C_SLOT_5_AXI_SUB_PROTOCOL)
          ) metric_calc_inst5
          (
            .clk                       (core_aclk ),
            .rst_n                     (core_aresetn),
            .Data_In                   (Slot_5_Sync_Data_Out),
            .Data_Valid                (Slot_5_Sync_Data_Valid), 
            .Metrics_Cnt_En            (Metrics_Cnt_En_sync),
            .Metrics_Cnt_Reset         (Metrics_Cnt_Reset_sync),
            .Use_Ext_Trig              (Use_Ext_Trig_sync),
            .Ext_Trig                  (slot_5_ext_trig),
            .Ext_Trig_Stop             (slot_5_ext_trig_stop),
            .Latency_WID               (Latency_WID),
            .Latency_RID               (Latency_RID),
            .WID_Mask                  (WID_Mask),
            .RID_Mask                  (RID_Mask),
            .En_Id_Based               (En_Id_Based_sync),  
            .Wr_Lat_Start              (Wr_Lat_Start),  //0 Address Issue 1 Address acceptance
            .Wr_Lat_End                (Wr_Lat_End),  //1 First write   0 Last write  
            .Rd_Lat_Start              (Rd_Lat_Start),  //0 Address Issue 1 Address acceptance 
            .Rd_Lat_End                (Rd_Lat_End),  //1 First Read    0 Last Read
            .Wtrans_Cnt_En             (Wtrans_Cnt_En[5]),
            .Rtrans_Cnt_En             (Rtrans_Cnt_En[5]),
            .Write_Byte_Cnt            (S5_Write_Byte_Cnt),
            .Read_Byte_Cnt             (S5_Read_Byte_Cnt),
            .Read_Byte_Cnt_En          (S5_Read_Byte_Cnt_En),
            .Write_Beat_Cnt_En         (Write_Beat_Cnt_En[5]),
            .Read_Beat_Cnt_En          (Read_Beat_Cnt_En[5]),
            .Read_Latency              (S5_Read_Latency),
            .Write_Latency             (S5_Write_Latency),
            .Write_Beat_Cnt            (S5_Write_Beat_Cnt),
            .Slv_Wr_Idle_Cnt           (S5_Slv_Wr_Idle_Cnt),
            .Read_Latency_En           (Read_Latency_En[5]),    
            .Write_Latency_En          (Write_Latency_En[5]),   
            .Slv_Wr_Idle_Cnt_En        (Slv_Wr_Idle_Cnt_En[5]), 
            .Mst_Rd_Idle_Cnt_En        (Mst_Rd_Idle_Cnt_En[5]), 
            .Num_BValids_En            (Num_BValids_En[5]),     
            .Num_WLasts_En             (Num_WLasts_En[5]),      
            .Num_RLasts_En             (Num_RLasts_En[5]),      
            .S_Transfer_Cnt_En         (S_Transfer_Cnt_En[5]),
            .S_Packet_Cnt_En           (S_Packet_Cnt_En[5]),  
            .S_Data_Byte_Cnt           (S5_S_Data_Byte_Cnt),
            .S_Position_Byte_Cnt       (S5_S_Position_Byte_Cnt),
            .S_Null_Byte_Cnt           (S5_S_Null_Byte_Cnt),
            .S_Slv_Idle_Cnt_En         (S_Slv_Idle_Cnt_En[5]),
            .S_Mst_Idle_Cnt_En         (S_Mst_Idle_Cnt_En[5]),
            .Max_Write_Latency         (S5_Max_Write_Latency),                   
            .Min_Write_Latency         (S5_Min_Write_Latency),                   
            .Max_Read_Latency          (S5_Max_Read_Latency),                   
            .Min_Read_Latency          (S5_Min_Read_Latency)
          );
     end
     else begin :GEN_NO_SLOT5
         assign S5_Write_Beat_Cnt = 0;
         assign S5_Slv_Wr_Idle_Cnt = 0;
         assign Slot_5_Sync_Data_Out = 0;
         assign S5_Write_Byte_Cnt    = 0;
         assign S5_Read_Byte_Cnt     = 0;
         assign S5_Read_Latency      = 0;
         assign S5_Write_Latency     = 0;
         assign S5_S_Data_Byte_Cnt   = 0;
         assign S5_S_Position_Byte_Cnt = 0;
         assign S5_S_Null_Byte_Cnt     = 0;
         assign Ext_Event5_Sync_Data_Out = 0;
         assign Ext_Event5_Sync_Data_Valid = 0;
         assign S5_Max_Write_Latency  = 0;                  
         assign S5_Min_Write_Latency  = 0;               
         assign S5_Max_Read_Latency   = 0;               
         assign S5_Min_Read_Latency   = 0;
     end
     endgenerate 


    generate    
    if (C_ENABLE_EVENT_LOG == 1 && C_NUM_MONITOR_SLOTS > 5) begin : GEN_FLAGS5
         //Flag Generator instantiation for slot5
         axi_perf_mon_v5_0_12_flags_gen
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S5), 
           .C_LOG_WIDTH               (C_SLOT_5_LOG_WIDTH),
           .C_FLAG_WIDTH              (C_SLOT_5_FLAG_WIDTH), 
           .C_AXI_ADDR_WIDTH          (C_SLOT_5_AXI_ADDR_WIDTH), 
           .C_AXI_DATA_WIDTH          (C_SLOT_5_AXI_DATA_WIDTH), 
           .C_AXI_ID_WIDTH            (C_SLOT_5_AXI_ID_WIDTH), 
           .C_AXI_PROTOCOL            (C_SLOT_5_AXI_PROTOCOL), 
           .C_AXIS_TDATA_WIDTH        (C_SLOT_5_AXIS_TDATA_WIDTH), 
           .C_AXIS_TID_WIDTH          (C_SLOT_5_AXIS_TID_WIDTH), 
           .C_AXIS_TDEST_WIDTH        (C_SLOT_5_AXIS_TDEST_WIDTH), 
           .C_AXIS_TUSER_WIDTH        (C_SLOT_5_AXIS_TUSER_WIDTH),
           .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
           .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
           .C_SHOW_AXIS_TID           (C_SHOW_AXIS_TID),
           .C_SHOW_AXIS_TUSER         (C_SHOW_AXIS_TUSER),
           .C_SHOW_AXIS_TDEST         (C_SHOW_AXIS_TDEST), 
           .C_EN_AXI_DEBUG               (C_EN_AXI_DEBUG) 
          ) flags_generator_inst_5
          (
           .clk                       (core_aclk),
           .rst_n                     (core_aresetn),
           .Data_In                   (Slot_5_Sync_Data_Out),
           .Data_Valid                (Slot_5_Sync_Data_Valid), 
           .Flag_Enable_Reg           (Flag_Enable_Reg),
           .Ext_Trig                  (slot_5_ext_trig),
           .Ext_Trig_Stop             (slot_5_ext_trig_stop),
           .Use_Ext_Trig_Log          (Use_Ext_Trig_Log_sync),                 
           .Log_Data                  (Slot_5_Log),
           .Log_En                    (Slot_5_Log_En),
           .Ext_Data_in               (Ext_Event5_Sync_Data_Out),
           .Ext_Data_Valid            (Ext_Event5_Sync_Data_Valid),
           .Ext_Event_Flag_En         (Ext_Event_Flag_En),
           .Ext_Event_Flags           (Ext_Event5_Flags)
          );

    end 
    else begin : GEN_NO_FLAGS5
       assign Slot_5_Log = 0;
       assign Slot_5_Log_En = 1'b0;
       assign Ext_Event5_Flags = 0;
    end 
    endgenerate
generate if(C_NUM_MONITOR_SLOTS > 5 && C_ENABLE_EVENT_LOG == 1 && C_EN_TRIGGER == 1) begin : GEN_S5_POST_TRIGGER
//Aligning start and end events of transactions
       axi_perf_mon_v5_0_12_postTriggerMarker 
	    #(
			   // Parameters
			.C_FAMILY                  (C_FAMILY),
         .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S5), 
         .C_LOG_WIDTH               (C_SLOT_5_LOG_WIDTH),
         .C_FLAG_WIDTH              (C_SLOT_N_FLAG_WIDTH), 
         .C_AXI_ADDR_WIDTH          (C_SLOT_5_AXI_ADDR_WIDTH), 
         .C_AXI_DATA_WIDTH          (C_SLOT_5_AXI_DATA_WIDTH), 
         .C_AXI_ID_WIDTH            (C_SLOT_5_AXI_ID_WIDTH), 
         .C_AXI_PROTOCOL            (C_SLOT_5_AXI_PROTOCOL), 
         .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS)
      )
		triggerMarker_slot5 (
			    // Outputs
			    .Log_Data_Marked	(Slot_5_Log_Marked),
			    .Log_en_out		(Slot_5_Log_En_Marked),
			    // Inputs
			    .clk		  (core_aclk),
			    .rst_n	  (stream_fifo_rst_n),
			    .trigger  (trigger),
			    .reStart  (Metrics_Cnt_Reset_sync),
			    .Log_Data (Slot_5_Log),
			    .Log_En	  (Slot_5_Log_En)
			    );

     end
      else if((C_ENABLE_EVENT_LOG == 1 && C_EN_TRIGGER == 0) || C_NUM_MONITOR_SLOTS < 6) begin :GEN_S5_NO_POST_TRIGGER
      assign Slot_5_Log_Marked = Slot_5_Log;
      assign Slot_5_Log_En_Marked = Slot_5_Log_En;
      end
      endgenerate

     //-- Slot 6
     generate
     if((C_NUM_MONITOR_SLOTS > 6)) begin :GEN_SLOT6

         axi_perf_mon_v5_0_12_mon_fifo
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
           .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S6),
           .C_FIFO_ENABLE             (C_SLOT_6_FIFO_ENABLE) 
          ) mon_fifo_inst_6
          (
           .Mon_clk                   (SLOT_6_clk),
           .Mon_rst_n                 (SLOT_6_Arst_n),
           .Data_In                   (Slot_6_Data_In),
           //.mon_en                    (Metrics_Cnt_En_sync),
           .CORE_ACLK                 (core_aclk),
           .CORE_ARESETN              (core_aresetn),
           .Sync_Data_Out             (Slot_6_Sync_Data_Out),
           .Sync_Data_Valid           (Slot_6_Sync_Data_Valid)
          );

          assign Ext_Event6_Data_In = {ext_event_6_cnt_start,ext_event_6_cnt_stop,ext_event_6};
     
          // External Event1 through monitor FIFO
          axi_perf_mon_v5_0_12_mon_fifo
             #(
               .C_FAMILY                  (C_FAMILY),
               .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
               .C_MON_FIFO_DATA_WIDTH     (3),
               .C_FIFO_ENABLE             (C_EXT_EVENT6_FIFO_ENABLE) 
              ) mon_fifo_ext_event6_inst
              (
               .Mon_clk                   (ext_clk_6),
               .Mon_rst_n                 (ext_rstn_6),
               .Data_In                   (Ext_Event6_Data_In),
               //.mon_en                    (Metrics_Cnt_En_sync),
               .CORE_ACLK                 (core_aclk),
               .CORE_ARESETN              (core_aresetn),
               .Sync_Data_Out             (Ext_Event6_Sync_Data_Out),
               .Sync_Data_Valid           (Ext_Event6_Sync_Data_Valid)
              );

        
         // External Event6 count enable generation module
         axi_perf_mon_v5_0_12_ext_calc ext_calc_inst6  
            (
              .clk                    (core_aclk),        
              .rst_n                  (core_aresetn),     
              .Ext_Event              (Ext_Event6_Sync_Data_Out[0]),
              .Ext_Event_Start        (Ext_Event6_Sync_Data_Out[2]),
              .Ext_Event_Stop         (Ext_Event6_Sync_Data_Out[1]),
              .Ext_Event_Valid        (Ext_Event6_Sync_Data_Valid ),
              .Metrics_Cnt_En         (Metrics_Cnt_En_sync),
              .Metrics_Cnt_Reset      (Metrics_Cnt_Reset_sync),
              .External_Event_Cnt_En  (External_Event_Cnt_En[6])
            );

         // Metric calculator instance for slot6
         axi_perf_mon_v5_0_12_metric_calc 
          #(
            .C_AXIID                   (C_SLOT_6_AXI_ID_WIDTH    ),
            .C_AXIADDR                 (C_SLOT_6_AXI_ADDR_WIDTH  ),
            .C_AXIDATA                 (C_SLOT_6_AXI_DATA_WIDTH  ),
            .C_AXISDATA                (C_SLOT_6_AXIS_TDATA_WIDTH),
            .C_AXISID                  (C_SLOT_6_AXIS_TID_WIDTH  ),
            .C_AXISDEST                (C_SLOT_6_AXIS_TDEST_WIDTH),
            .C_AXISUSER                (C_SLOT_6_AXIS_TUSER_WIDTH),
            .C_OUTSTAND_DEPTH          (C_MAX_OUTSTAND_DEPTH),
            .C_METRIC_COUNT_WIDTH      (C_METRIC_COUNT_WIDTH),
            .C_MON_FIFO_WIDTH          (C_MON_FIFO_DWIDTH_S6),
            .C_AXI_PROTOCOL            (C_SLOT_6_AXI_PROTOCOL),
            .C_AXI_SUB_PROTOCOL        (C_SLOT_6_AXI_SUB_PROTOCOL)
          ) metric_calc_inst6
          (
            .clk                       (core_aclk ),
            .rst_n                     (core_aresetn),
            .Data_In                   (Slot_6_Sync_Data_Out),
            .Data_Valid                (Slot_6_Sync_Data_Valid), 
            .Metrics_Cnt_En            (Metrics_Cnt_En_sync),
            .Metrics_Cnt_Reset         (Metrics_Cnt_Reset_sync),
            .Use_Ext_Trig              (Use_Ext_Trig_sync),
            .Ext_Trig                  (slot_6_ext_trig),
            .Ext_Trig_Stop             (slot_6_ext_trig_stop),
            .Latency_WID               (Latency_WID),
            .Latency_RID               (Latency_RID),
            .WID_Mask                  (WID_Mask),
            .RID_Mask                  (RID_Mask),
            .En_Id_Based               (En_Id_Based_sync),  
            .Wr_Lat_Start              (Wr_Lat_Start    ),  //0 Address Issue 1 Address acceptance
            .Wr_Lat_End                (Wr_Lat_End),  //1 First write   0 Last write  
            .Rd_Lat_Start              (Rd_Lat_Start),  //0 Address Issue 1 Address acceptance 
            .Rd_Lat_End                (Rd_Lat_End),  //1 First Read    0 Last Read
            .Wtrans_Cnt_En             (Wtrans_Cnt_En[6]),
            .Rtrans_Cnt_En             (Rtrans_Cnt_En[6]),
            .Write_Byte_Cnt            (S6_Write_Byte_Cnt),
            .Read_Byte_Cnt             (S6_Read_Byte_Cnt),
            .Read_Byte_Cnt_En          (S6_Read_Byte_Cnt_En),
            .Write_Beat_Cnt_En         (Write_Beat_Cnt_En[6]),
            .Read_Beat_Cnt_En          (Read_Beat_Cnt_En[6]),
            .Read_Latency              (S6_Read_Latency),
            .Write_Latency             (S6_Write_Latency),
            .Write_Beat_Cnt            (S6_Write_Beat_Cnt),
            .Slv_Wr_Idle_Cnt           (S6_Slv_Wr_Idle_Cnt),
            .Read_Latency_En           (Read_Latency_En[6]),    
            .Write_Latency_En          (Write_Latency_En[6]),   
            .Slv_Wr_Idle_Cnt_En        (Slv_Wr_Idle_Cnt_En[6]), 
            .Mst_Rd_Idle_Cnt_En        (Mst_Rd_Idle_Cnt_En[6]), 
            .Num_BValids_En            (Num_BValids_En[6]),     
            .Num_WLasts_En             (Num_WLasts_En[6]),      
            .Num_RLasts_En             (Num_RLasts_En[6]),      
            .S_Transfer_Cnt_En         (S_Transfer_Cnt_En[6]),
            .S_Packet_Cnt_En           (S_Packet_Cnt_En[6]),  
            .S_Data_Byte_Cnt           (S6_S_Data_Byte_Cnt),
            .S_Position_Byte_Cnt       (S6_S_Position_Byte_Cnt),
            .S_Null_Byte_Cnt           (S6_S_Null_Byte_Cnt),
            .S_Slv_Idle_Cnt_En         (S_Slv_Idle_Cnt_En[6]),
            .S_Mst_Idle_Cnt_En         (S_Mst_Idle_Cnt_En[6]),
            .Max_Write_Latency         (S6_Max_Write_Latency),                   
            .Min_Write_Latency         (S6_Min_Write_Latency),                   
            .Max_Read_Latency          (S6_Max_Read_Latency),                   
            .Min_Read_Latency          (S6_Min_Read_Latency)
          );
     end
     else begin :GEN_NO_SLOT6
         assign S6_Write_Beat_Cnt = 0;
         assign S6_Slv_Wr_Idle_Cnt = 0;
         assign Slot_6_Sync_Data_Out = 0;
         assign S6_Write_Byte_Cnt    = 0;
         assign S6_Read_Byte_Cnt     = 0;
         assign S6_Read_Latency      = 0;
         assign S6_Write_Latency     = 0;
         assign S6_S_Data_Byte_Cnt   = 0;
         assign S6_S_Position_Byte_Cnt = 0;
         assign S6_S_Null_Byte_Cnt     = 0;
         assign Ext_Event6_Sync_Data_Out = 0;
         assign Ext_Event6_Sync_Data_Valid = 0;
         assign S6_Max_Write_Latency  = 0;                  
         assign S6_Min_Write_Latency  = 0;               
         assign S6_Max_Read_Latency   = 0;               
         assign S6_Min_Read_Latency   = 0;
     end
     endgenerate 

    generate    
    if (C_ENABLE_EVENT_LOG == 1 && C_NUM_MONITOR_SLOTS > 6) begin : GEN_FLAGS6
         //Flag Generator instantiation for slot6
         axi_perf_mon_v5_0_12_flags_gen
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S6), 
           .C_LOG_WIDTH               (C_SLOT_6_LOG_WIDTH),
           .C_FLAG_WIDTH              (C_SLOT_6_FLAG_WIDTH), 
           .C_AXI_ADDR_WIDTH          (C_SLOT_6_AXI_ADDR_WIDTH), 
           .C_AXI_DATA_WIDTH          (C_SLOT_6_AXI_DATA_WIDTH), 
           .C_AXI_ID_WIDTH            (C_SLOT_6_AXI_ID_WIDTH), 
           .C_AXI_PROTOCOL            (C_SLOT_6_AXI_PROTOCOL), 
           .C_AXIS_TDATA_WIDTH        (C_SLOT_6_AXIS_TDATA_WIDTH), 
           .C_AXIS_TID_WIDTH          (C_SLOT_6_AXIS_TID_WIDTH), 
           .C_AXIS_TDEST_WIDTH        (C_SLOT_6_AXIS_TDEST_WIDTH), 
           .C_AXIS_TUSER_WIDTH        (C_SLOT_6_AXIS_TUSER_WIDTH),
           .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
           .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
           .C_SHOW_AXIS_TID           (C_SHOW_AXIS_TID),
           .C_SHOW_AXIS_TUSER         (C_SHOW_AXIS_TUSER),
           .C_SHOW_AXIS_TDEST         (C_SHOW_AXIS_TDEST), 
           .C_EN_AXI_DEBUG               (C_EN_AXI_DEBUG) 
          ) flags_generator_inst_6
          (
           .clk                       (core_aclk),
           .rst_n                     (core_aresetn),
           .Data_In                   (Slot_6_Sync_Data_Out),
           .Data_Valid                (Slot_6_Sync_Data_Valid), 
           .Flag_Enable_Reg           (Flag_Enable_Reg),
           .Ext_Trig                  (slot_6_ext_trig),
           .Ext_Trig_Stop             (slot_6_ext_trig_stop),
           .Use_Ext_Trig_Log          (Use_Ext_Trig_Log_sync),                
           .Log_Data                  (Slot_6_Log),
           .Log_En                    (Slot_6_Log_En),
           .Ext_Data_in               (Ext_Event6_Sync_Data_Out),
           .Ext_Data_Valid            (Ext_Event6_Sync_Data_Valid),
           .Ext_Event_Flag_En         (Ext_Event_Flag_En),
           .Ext_Event_Flags           (Ext_Event6_Flags)
          );

    end 
    else begin : GEN_NO_FLAGS6
       assign Slot_6_Log = 0;
       assign Slot_6_Log_En = 1'b0;
       assign Ext_Event6_Flags = 0;
    end 
    endgenerate

     //-- Slot 7
     generate
     if((C_NUM_MONITOR_SLOTS > 7)) begin :GEN_SLOT7

         axi_perf_mon_v5_0_12_mon_fifo
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
           .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S7),
           .C_FIFO_ENABLE             (C_SLOT_7_FIFO_ENABLE) 
          ) mon_fifo_inst_7
          (
           .Mon_clk                   (SLOT_7_clk),
           .Mon_rst_n                 (SLOT_7_Arst_n),
           .Data_In                   (Slot_7_Data_In),
           //.mon_en                    (Metrics_Cnt_En_sync),
           .CORE_ACLK                 (core_aclk),
           .CORE_ARESETN              (core_aresetn),
           .Sync_Data_Out             (Slot_7_Sync_Data_Out),
           .Sync_Data_Valid           (Slot_7_Sync_Data_Valid)
          );
         
          assign Ext_Event7_Data_In = {ext_event_7_cnt_start,ext_event_7_cnt_stop,ext_event_7};
     
          // External Event1 through monitor FIFO
          axi_perf_mon_v5_0_12_mon_fifo
             #(
               .C_FAMILY                  (C_FAMILY),
               .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
               .C_MON_FIFO_DATA_WIDTH     (3),
               .C_FIFO_ENABLE             (C_EXT_EVENT7_FIFO_ENABLE) 
              ) mon_fifo_ext_event7_inst
              (
               .Mon_clk                   (ext_clk_7),
               .Mon_rst_n                 (ext_rstn_7),
               .Data_In                   (Ext_Event7_Data_In),
               //.mon_en                    (Metrics_Cnt_En_sync),
               .CORE_ACLK                 (core_aclk),
               .CORE_ARESETN              (core_aresetn),
               .Sync_Data_Out             (Ext_Event7_Sync_Data_Out),
               .Sync_Data_Valid           (Ext_Event7_Sync_Data_Valid)
              );

         // External Event7 count enable generation module
         axi_perf_mon_v5_0_12_ext_calc ext_calc_inst7  
            (
              .clk                    (core_aclk),        
              .rst_n                  (core_aresetn),     
              .Ext_Event              (Ext_Event7_Sync_Data_Out[0]),
              .Ext_Event_Start        (Ext_Event7_Sync_Data_Out[2]),
              .Ext_Event_Stop         (Ext_Event7_Sync_Data_Out[1]),
              .Ext_Event_Valid        (Ext_Event7_Sync_Data_Valid ),
              .Metrics_Cnt_En         (Metrics_Cnt_En_sync),
              .Metrics_Cnt_Reset      (Metrics_Cnt_Reset_sync),
              .External_Event_Cnt_En  (External_Event_Cnt_En[7])
            );

          // Metric calculator instance for slot7
          axi_perf_mon_v5_0_12_metric_calc 
           #(
             .C_AXIID                   (C_SLOT_7_AXI_ID_WIDTH    ),
             .C_AXIADDR                 (C_SLOT_7_AXI_ADDR_WIDTH  ),
             .C_AXIDATA                 (C_SLOT_7_AXI_DATA_WIDTH  ),
             .C_AXISDATA                (C_SLOT_7_AXIS_TDATA_WIDTH),
             .C_AXISID                  (C_SLOT_7_AXIS_TID_WIDTH  ),
             .C_AXISDEST                (C_SLOT_7_AXIS_TDEST_WIDTH),
             .C_AXISUSER                (C_SLOT_7_AXIS_TUSER_WIDTH),
             .C_OUTSTAND_DEPTH          (C_MAX_OUTSTAND_DEPTH),
             .C_METRIC_COUNT_WIDTH      (C_METRIC_COUNT_WIDTH),
             .C_MON_FIFO_WIDTH          (C_MON_FIFO_DWIDTH_S7),
             .C_AXI_PROTOCOL            (C_SLOT_7_AXI_PROTOCOL),
             .C_AXI_SUB_PROTOCOL        (C_SLOT_7_AXI_SUB_PROTOCOL)
           ) metric_calc_inst7
           (
             .clk                       (core_aclk ),
             .rst_n                     (core_aresetn),
             .Data_In                   (Slot_7_Sync_Data_Out),
             .Data_Valid                (Slot_7_Sync_Data_Valid), 
             .Metrics_Cnt_En            (Metrics_Cnt_En_sync),
             .Metrics_Cnt_Reset         (Metrics_Cnt_Reset_sync),
             .Use_Ext_Trig              (Use_Ext_Trig_sync),
             .Ext_Trig                  (slot_7_ext_trig),
             .Ext_Trig_Stop             (slot_7_ext_trig_stop),
             .Latency_WID               (Latency_WID),
             .Latency_RID               (Latency_RID),
             .WID_Mask                  (WID_Mask),
             .RID_Mask                  (RID_Mask),
             .En_Id_Based               (En_Id_Based_sync),  
             .Wr_Lat_Start              (Wr_Lat_Start),  //0 Address Issue 1 Address acceptance
             .Wr_Lat_End                (Wr_Lat_End),  //1 First write   0 Last write  
             .Rd_Lat_Start              (Rd_Lat_Start),  //0 Address Issue 1 Address acceptance 
             .Rd_Lat_End                (Rd_Lat_End),  //1 First Read    0 Last Read
             .Wtrans_Cnt_En             (Wtrans_Cnt_En[7]),
             .Rtrans_Cnt_En             (Rtrans_Cnt_En[7]),
             .Write_Byte_Cnt            (S7_Write_Byte_Cnt),
             .Read_Byte_Cnt             (S7_Read_Byte_Cnt),
             .Read_Byte_Cnt_En          (S7_Read_Byte_Cnt_En),
             .Write_Beat_Cnt_En         (Write_Beat_Cnt_En[7]),
             .Read_Beat_Cnt_En          (Read_Beat_Cnt_En[7]),
             .Read_Latency              (S7_Read_Latency),
             .Write_Latency             (S7_Write_Latency),
             .Write_Beat_Cnt            (S7_Write_Beat_Cnt),
             .Slv_Wr_Idle_Cnt           (S7_Slv_Wr_Idle_Cnt),
             .Read_Latency_En           (Read_Latency_En[7]),    
             .Write_Latency_En          (Write_Latency_En[7]),   
             .Slv_Wr_Idle_Cnt_En        (Slv_Wr_Idle_Cnt_En[7]), 
             .Mst_Rd_Idle_Cnt_En        (Mst_Rd_Idle_Cnt_En[7]), 
             .Num_BValids_En            (Num_BValids_En[7]),     
             .Num_WLasts_En             (Num_WLasts_En[7]),      
             .Num_RLasts_En             (Num_RLasts_En[7]),      
             .S_Transfer_Cnt_En         (S_Transfer_Cnt_En[7]),
             .S_Packet_Cnt_En           (S_Packet_Cnt_En[7]),  
             .S_Data_Byte_Cnt           (S7_S_Data_Byte_Cnt),
             .S_Position_Byte_Cnt       (S7_S_Position_Byte_Cnt),
             .S_Null_Byte_Cnt           (S7_S_Null_Byte_Cnt),
             .S_Slv_Idle_Cnt_En         (S_Slv_Idle_Cnt_En[7]),
             .S_Mst_Idle_Cnt_En         (S_Mst_Idle_Cnt_En[7]),
             .Max_Write_Latency         (S7_Max_Write_Latency),                   
             .Min_Write_Latency         (S7_Min_Write_Latency),                   
             .Max_Read_Latency          (S7_Max_Read_Latency),                   
             .Min_Read_Latency          (S7_Min_Read_Latency)
           );
     end
     else begin :GEN_NO_SLOT7
         assign S7_Write_Beat_Cnt = 0;
         assign S7_Slv_Wr_Idle_Cnt = 0;
         assign Slot_7_Sync_Data_Out = 0;
         assign S7_Write_Byte_Cnt    = 0;
         assign S7_Read_Byte_Cnt     = 0;
         assign S7_Read_Latency      = 0;
         assign S7_Write_Latency     = 0;
         assign S7_S_Data_Byte_Cnt   = 0;
         assign S7_S_Position_Byte_Cnt = 0;
         assign S7_S_Null_Byte_Cnt     = 0;
         assign Ext_Event7_Sync_Data_Out = 0;
         assign Ext_Event7_Sync_Data_Valid = 0;
         assign External_Event7_Cnt_En = 0;
         assign S7_Max_Write_Latency  = 0;                  
         assign S7_Min_Write_Latency  = 0;               
         assign S7_Max_Read_Latency   = 0;               
         assign S7_Min_Read_Latency   = 0;
     end
     endgenerate 
     
    generate    
    if (C_ENABLE_EVENT_LOG == 1 && C_NUM_MONITOR_SLOTS > 7) begin : GEN_FLAGS7
        //Flag Generator instantiation for slot7
         axi_perf_mon_v5_0_12_flags_gen
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S7), 
           .C_LOG_WIDTH               (C_SLOT_7_LOG_WIDTH),
           .C_FLAG_WIDTH              (C_SLOT_7_FLAG_WIDTH), 
           .C_AXI_ADDR_WIDTH          (C_SLOT_7_AXI_ADDR_WIDTH), 
           .C_AXI_DATA_WIDTH          (C_SLOT_7_AXI_DATA_WIDTH), 
           .C_AXI_ID_WIDTH            (C_SLOT_7_AXI_ID_WIDTH), 
           .C_AXI_PROTOCOL            (C_SLOT_7_AXI_PROTOCOL), 
           .C_AXIS_TDATA_WIDTH        (C_SLOT_7_AXIS_TDATA_WIDTH), 
           .C_AXIS_TID_WIDTH          (C_SLOT_7_AXIS_TID_WIDTH), 
           .C_AXIS_TDEST_WIDTH        (C_SLOT_7_AXIS_TDEST_WIDTH), 
           .C_AXIS_TUSER_WIDTH        (C_SLOT_7_AXIS_TUSER_WIDTH),
           .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
           .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
           .C_SHOW_AXIS_TID           (C_SHOW_AXIS_TID),
           .C_SHOW_AXIS_TUSER         (C_SHOW_AXIS_TUSER),
           .C_SHOW_AXIS_TDEST         (C_SHOW_AXIS_TDEST), 
           .C_EN_AXI_DEBUG               (C_EN_AXI_DEBUG) 
          ) flags_generator_inst_7
          (
           .clk                       (core_aclk),
           .rst_n                     (core_aresetn),
           .Data_In                   (Slot_7_Sync_Data_Out),
           .Data_Valid                (Slot_7_Sync_Data_Valid), 
           .Flag_Enable_Reg           (Flag_Enable_Reg),
           .Ext_Trig                  (slot_7_ext_trig),
           .Ext_Trig_Stop             (slot_7_ext_trig_stop),
           .Use_Ext_Trig_Log          (Use_Ext_Trig_Log_sync),                 
           .Log_Data                  (Slot_7_Log),
           .Log_En                    (Slot_7_Log_En),
           .Ext_Data_in               (Ext_Event7_Sync_Data_Out),
           .Ext_Data_Valid            (Ext_Event7_Sync_Data_Valid),
           .Ext_Event_Flag_En         (Ext_Event_Flag_En),
           .Ext_Event_Flags           (Ext_Event7_Flags)
          );

    end 
    else begin : GEN_NO_FLAGS7
       assign Slot_7_Log = 0;
       assign Slot_7_Log_En = 1'b0;
       assign Ext_Event7_Flags = 0;
    end 
    endgenerate       

     //-- Streaming FIFO and its write logic 
     generate
     if((C_ENABLE_EVENT_LOG == 1)) begin :GEN_EVENT_LOG

         axi_perf_mon_v5_0_12_strm_fifo_wr_logic
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_NUM_MONITOR_SLOTS       (C_NUM_MONITOR_SLOTS),
           .C_SW_SYNC_DATA_WIDTH      (C_SW_SYNC_DATA_WIDTH),
           .C_SLOT_0_LOG_WIDTH        (C_SLOT_0_LOG_WIDTH), 
           .C_SLOT_1_LOG_WIDTH        (C_SLOT_1_LOG_WIDTH), 
           .C_SLOT_2_LOG_WIDTH        (C_SLOT_2_LOG_WIDTH), 
           .C_SLOT_3_LOG_WIDTH        (C_SLOT_3_LOG_WIDTH), 
           .C_SLOT_4_LOG_WIDTH        (C_SLOT_4_LOG_WIDTH), 
           .C_SLOT_5_LOG_WIDTH        (C_SLOT_5_LOG_WIDTH), 
           .C_SLOT_6_LOG_WIDTH        (C_SLOT_6_LOG_WIDTH), 
           .C_SLOT_7_LOG_WIDTH        (C_SLOT_7_LOG_WIDTH), 
           .C_FIFO_AXIS_TDATA_WIDTH   (C_FIFO_AXIS_TDATA_WIDTH), 
           .C_EN_AXI_DEBUG            (C_EN_AXI_DEBUG),
           .C_EN_TRIGGER              (C_EN_TRIGGER)
          ) streaming_fifo_write_logic_inst
          (
           .clk                       (core_aclk),
           .rst_n                     (core_aresetn),
           .Event_Log_En              (Event_Log_En_sync),
           .Slot_0_Log                (Slot_0_Log_Marked),
           .Slot_0_Log_En             (Slot_0_Log_En_Marked),
           .Slot_1_Log                (Slot_1_Log_Marked),
           .Slot_1_Log_En             (Slot_1_Log_En_Marked),
           .Slot_2_Log                (Slot_2_Log_Marked),
           .Slot_2_Log_En             (Slot_2_Log_En_Marked),
           .Slot_3_Log                (Slot_3_Log_Marked),
           .Slot_3_Log_En             (Slot_3_Log_En_Marked),
           .Slot_4_Log                (Slot_4_Log_Marked),
           .Slot_4_Log_En             (Slot_4_Log_En_Marked),
           .Slot_5_Log                (Slot_5_Log_Marked),
           .Slot_5_Log_En             (Slot_5_Log_En_Marked),
           .Slot_6_Log                (Slot_6_Log),
           .Slot_6_Log_En             (Slot_6_Log_En),
           .Slot_7_Log                (Slot_7_Log),
           .Slot_7_Log_En             (Slot_7_Log_En),
           .SW_Data_Log_En            (SW_Data_Log_En ),
           .SW_Data                   (SW_Data        ),
           .SW_Data_Wr_En             (SW_Data_Wr_En  ),
           .Ext_Event0_Flags          (Ext_Event0_Flags),
           .Ext_Event1_Flags          (Ext_Event1_Flags),
           .Ext_Event2_Flags          (Ext_Event2_Flags),
           .Ext_Event3_Flags          (Ext_Event3_Flags),
           .Ext_Event4_Flags          (Ext_Event4_Flags),
           .Ext_Event5_Flags          (Ext_Event5_Flags),
           .Ext_Event6_Flags          (Ext_Event6_Flags),
           .Ext_Event7_Flags          (Ext_Event7_Flags),
           .Fifo_Full                 (Streaming_Fifo_Full   ),
           .Fifo_Empty                (Streaming_Fifo_Empty  ),
           .Fifo_Wr_En                (Streaming_Fifo_Wr_En  ),
           .Fifo_Wr_Data              (Streaming_Fifo_Wr_Data),
           .trigger                   (trigger)
          );

         wire stream_fifo_rst_n = ~(Streaming_FIFO_Reset_sync) & core_aresetn;

         // Sync/ Async streaming FIFO
         axi_perf_mon_v5_0_12_async_stream_fifo
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_FIFO_DEPTH              (C_FIFO_AXIS_DEPTH),
           .C_DATA_WIDTH              (C_FIFO_AXIS_TDATA_WIDTH),
           .C_AXIS_DWIDTH_ROUND_TO_32 (C_AXIS_DWIDTH_ROUND_TO_32),
           .C_USE_BLOCKMEM            (1),                   // 1 Use bram
           .C_COMMON_CLOCK            (C_FIFO_AXIS_SYNC),     //1 sync fifo 0 async fifo
           .C_LOG_DATA_OFFLD          (C_LOG_DATA_OFFLD)  ,
           .S_AXI_OFFLD_ID_WIDTH      (S_AXI_OFFLD_ID_WIDTH),  
           .C_EN_TRIGGER              (C_EN_TRIGGER)  
          ) async_stream_fifo_inst
          (
           .Wr_clk               (core_aclk),
           .Wr_rst_n             (stream_fifo_rst_n),
           .fifo_wr_en           (Streaming_Fifo_Wr_En),
           .eventlog_cur_cnt     (eventlog_cur_cnt),
           .fifo_full_out        (Streaming_Fifo_Full),
           .fifo_empty_out       (Streaming_Fifo_Empty),
           .Fifo_Data_In         (Streaming_Fifo_Wr_Data),
           .m_axis_aclk          (m_axis_aclk),
           .m_axis_aresetn       (m_axis_aresetn),
           .m_axis_tvalid        (m_axis_tvalid),
           .m_axis_tready        (m_axis_tready),
           .m_axis_tdata         (m_axis_tdata),
           .s_axi_offld_aclk     (s_axi_offld_aclk    ),
           .s_axi_offld_aresetn  (s_axi_offld_aresetn ),
           .s_axi_offld_araddr   (s_axi_offld_araddr  ),
           .s_axi_offld_arvalid  (s_axi_offld_arvalid ),
           .s_axi_offld_arlen    (s_axi_offld_arlen   ),
           .s_axi_offld_arid     (s_axi_offld_arid    ),
           .s_axi_offld_arready  (s_axi_offld_arready ),
           .s_axi_offld_rready   (s_axi_offld_rready  ),
           .s_axi_offld_rdata    (s_axi_offld_rdata   ),
           .s_axi_offld_rresp    (s_axi_offld_rresp   ),
           .s_axi_offld_rvalid   (s_axi_offld_rvalid  ),
           .s_axi_offld_rid      (s_axi_offld_rid     ),
           .s_axi_offld_rlast    (s_axi_offld_rlast   ),
           .trigger              (trigger) 
          );
         assign m_axis_tstrb = { {(C_FIFO_AXIS_TDATA_WIDTH/8){1'b1}} } ;
         assign m_axis_tid = 0;
     end
     else begin :GEN_NO_EVENT_LOG
         assign m_axis_tdata  = 0;
         assign m_axis_tvalid = 0;
         assign m_axis_tstrb = 0;
         assign m_axis_tid = 0;
         assign Streaming_Fifo_Full = 0;
     end
     endgenerate 

   //-- Edge detection of fifo full
   always @(posedge core_aclk) begin
       if (core_aresetn == RST_ACTIVE) begin
           Streaming_Fifo_Full_D1 <= 1'b0;
       end
       else begin
           Streaming_Fifo_Full_D1 <= Streaming_Fifo_Full;
       end
   end

   assign Streaming_Fifo_Full_Edge = Streaming_Fifo_Full & (!Streaming_Fifo_Full_D1);

   // Resets metric count through control register bit or through sampled interval  control register
   // When ever sample counter expires or when sample register is read 
   wire Metrics_Cnt_Reset_Final = Metrics_Cnt_Reset_sync | (Sample_Interval_Cnt_Lapse & Reset_On_Sample_Int_Lapse_sync)
                                  | (Lat_Sample_Reg & Reset_On_Sample_Int_Lapse_sync);
  


   //-- metric counters instantiation
     axi_perf_mon_v5_0_12_metric_counters 
    #(
      .C_FAMILY                    (C_FAMILY),
      .C_NUM_MONITOR_SLOTS         (C_NUM_MONITOR_SLOTS),
      .C_ENABLE_EVENT_COUNT        (C_ENABLE_EVENT_COUNT),
      .C_NUM_OF_COUNTERS           (C_NUM_OF_COUNTERS), 
      .C_METRIC_COUNT_WIDTH        (C_METRIC_COUNT_WIDTH),
      .C_METRIC_COUNT_SCALE        (C_METRIC_COUNT_SCALE),
      .COUNTER_LOAD_VALUE          (COUNTER_LOAD_VALUE)  

    ) metric_counters_inst
    (
      .clk                           (core_aclk ),
      .rst_n                         (core_aresetn),
      .Wtrans_Cnt_En                 (Wtrans_Cnt_En),
      .Rtrans_Cnt_En                 (Rtrans_Cnt_En),
      .S0_Write_Byte_Cnt             (S0_Write_Byte_Cnt),
      .S1_Write_Byte_Cnt             (S1_Write_Byte_Cnt),
      .S2_Write_Byte_Cnt             (S2_Write_Byte_Cnt),
      .S3_Write_Byte_Cnt             (S3_Write_Byte_Cnt),
      .S4_Write_Byte_Cnt             (S4_Write_Byte_Cnt),
      .S5_Write_Byte_Cnt             (S5_Write_Byte_Cnt),
      .S6_Write_Byte_Cnt             (S6_Write_Byte_Cnt),
      .S7_Write_Byte_Cnt             (S7_Write_Byte_Cnt),
      .S0_Slv_Wr_Idle_Cnt             (S0_Slv_Wr_Idle_Cnt),
      .S1_Slv_Wr_Idle_Cnt             (S1_Slv_Wr_Idle_Cnt),
      .S2_Slv_Wr_Idle_Cnt             (S2_Slv_Wr_Idle_Cnt),
      .S3_Slv_Wr_Idle_Cnt             (S3_Slv_Wr_Idle_Cnt),
      .S4_Slv_Wr_Idle_Cnt             (S4_Slv_Wr_Idle_Cnt),
      .S5_Slv_Wr_Idle_Cnt             (S5_Slv_Wr_Idle_Cnt),
      .S6_Slv_Wr_Idle_Cnt             (S6_Slv_Wr_Idle_Cnt),
      .S7_Slv_Wr_Idle_Cnt             (S7_Slv_Wr_Idle_Cnt),
      .S0_Write_Beat_Cnt             (S0_Write_Beat_Cnt),
      .S1_Write_Beat_Cnt             (S1_Write_Beat_Cnt),
      .S2_Write_Beat_Cnt             (S2_Write_Beat_Cnt),
      .S3_Write_Beat_Cnt             (S3_Write_Beat_Cnt),
      .S4_Write_Beat_Cnt             (S4_Write_Beat_Cnt),
      .S5_Write_Beat_Cnt             (S5_Write_Beat_Cnt),
      .S6_Write_Beat_Cnt             (S6_Write_Beat_Cnt),
      .S7_Write_Beat_Cnt             (S7_Write_Beat_Cnt),
      .S0_Read_Byte_Cnt              (S0_Read_Byte_Cnt),
      .S1_Read_Byte_Cnt              (S1_Read_Byte_Cnt),
      .S2_Read_Byte_Cnt              (S2_Read_Byte_Cnt),
      .S3_Read_Byte_Cnt              (S3_Read_Byte_Cnt),
      .S4_Read_Byte_Cnt              (S4_Read_Byte_Cnt),
      .S5_Read_Byte_Cnt              (S5_Read_Byte_Cnt),
      .S6_Read_Byte_Cnt              (S6_Read_Byte_Cnt),
      .S7_Read_Byte_Cnt              (S7_Read_Byte_Cnt),
      .S0_Read_Byte_Cnt_En           (S0_Read_Byte_Cnt_En),
      .S1_Read_Byte_Cnt_En           (S1_Read_Byte_Cnt_En),
      .S2_Read_Byte_Cnt_En           (S2_Read_Byte_Cnt_En),
      .S3_Read_Byte_Cnt_En           (S3_Read_Byte_Cnt_En),
      .S4_Read_Byte_Cnt_En           (S4_Read_Byte_Cnt_En),
      .S5_Read_Byte_Cnt_En           (S5_Read_Byte_Cnt_En),
      .S6_Read_Byte_Cnt_En           (S6_Read_Byte_Cnt_En),
      .S7_Read_Byte_Cnt_En           (S7_Read_Byte_Cnt_En),
      .Write_Beat_Cnt_En             (Write_Beat_Cnt_En),
      .Read_Beat_Cnt_En              (Read_Beat_Cnt_En),
      .S0_Read_Latency               (S0_Read_Latency),
      .S1_Read_Latency               (S1_Read_Latency),
      .S2_Read_Latency               (S2_Read_Latency),
      .S3_Read_Latency               (S3_Read_Latency),
      .S4_Read_Latency               (S4_Read_Latency),
      .S5_Read_Latency               (S5_Read_Latency),
      .S6_Read_Latency               (S6_Read_Latency),
      .S7_Read_Latency               (S7_Read_Latency),
      .S0_Write_Latency              (S0_Write_Latency),
      .S1_Write_Latency              (S1_Write_Latency),
      .S2_Write_Latency              (S2_Write_Latency),
      .S3_Write_Latency              (S3_Write_Latency),
      .S4_Write_Latency              (S4_Write_Latency),
      .S5_Write_Latency              (S5_Write_Latency),
      .S6_Write_Latency              (S6_Write_Latency),
      .S7_Write_Latency              (S7_Write_Latency),
      .Read_Latency_En               (Read_Latency_En),    
      .Write_Latency_En              (Write_Latency_En),   
      .Slv_Wr_Idle_Cnt_En            (Slv_Wr_Idle_Cnt_En), 
      .Mst_Rd_Idle_Cnt_En            (Mst_Rd_Idle_Cnt_En), 
      .Num_BValids_En                (Num_BValids_En),     
      .Num_WLasts_En                 (Num_WLasts_En),      
      .Num_RLasts_En                 (Num_RLasts_En),      
      .S_Transfer_Cnt_En             (S_Transfer_Cnt_En),
      .S_Packet_Cnt_En               (S_Packet_Cnt_En),  
      .S0_S_Data_Byte_Cnt            (S0_S_Data_Byte_Cnt),
      .S1_S_Data_Byte_Cnt            (S1_S_Data_Byte_Cnt),
      .S2_S_Data_Byte_Cnt            (S2_S_Data_Byte_Cnt),
      .S3_S_Data_Byte_Cnt            (S3_S_Data_Byte_Cnt),
      .S4_S_Data_Byte_Cnt            (S4_S_Data_Byte_Cnt),
      .S5_S_Data_Byte_Cnt            (S5_S_Data_Byte_Cnt),
      .S6_S_Data_Byte_Cnt            (S6_S_Data_Byte_Cnt),
      .S7_S_Data_Byte_Cnt            (S7_S_Data_Byte_Cnt),
      .S0_S_Position_Byte_Cnt        (S0_S_Position_Byte_Cnt),
      .S1_S_Position_Byte_Cnt        (S1_S_Position_Byte_Cnt),
      .S2_S_Position_Byte_Cnt        (S2_S_Position_Byte_Cnt),
      .S3_S_Position_Byte_Cnt        (S3_S_Position_Byte_Cnt),
      .S4_S_Position_Byte_Cnt        (S4_S_Position_Byte_Cnt),
      .S5_S_Position_Byte_Cnt        (S5_S_Position_Byte_Cnt),
      .S6_S_Position_Byte_Cnt        (S6_S_Position_Byte_Cnt),
      .S7_S_Position_Byte_Cnt        (S7_S_Position_Byte_Cnt),
      .S0_S_Null_Byte_Cnt            (S0_S_Null_Byte_Cnt),
      .S1_S_Null_Byte_Cnt            (S1_S_Null_Byte_Cnt),
      .S2_S_Null_Byte_Cnt            (S2_S_Null_Byte_Cnt),
      .S3_S_Null_Byte_Cnt            (S3_S_Null_Byte_Cnt),
      .S4_S_Null_Byte_Cnt            (S4_S_Null_Byte_Cnt),
      .S5_S_Null_Byte_Cnt            (S5_S_Null_Byte_Cnt),
      .S6_S_Null_Byte_Cnt            (S6_S_Null_Byte_Cnt),
      .S7_S_Null_Byte_Cnt            (S7_S_Null_Byte_Cnt),
      .S_Slv_Idle_Cnt_En             (S_Slv_Idle_Cnt_En),
      .S_Mst_Idle_Cnt_En             (S_Mst_Idle_Cnt_En),
      .S0_Max_Write_Latency          (S0_Max_Write_Latency),         
      .S1_Max_Write_Latency          (S1_Max_Write_Latency),         
      .S2_Max_Write_Latency          (S2_Max_Write_Latency),         
      .S3_Max_Write_Latency          (S3_Max_Write_Latency),         
      .S4_Max_Write_Latency          (S4_Max_Write_Latency),         
      .S5_Max_Write_Latency          (S5_Max_Write_Latency),         
      .S6_Max_Write_Latency          (S6_Max_Write_Latency),         
      .S7_Max_Write_Latency          (S7_Max_Write_Latency),         
      .S0_Min_Write_Latency          (S0_Min_Write_Latency),       
      .S1_Min_Write_Latency          (S1_Min_Write_Latency),       
      .S2_Min_Write_Latency          (S2_Min_Write_Latency),       
      .S3_Min_Write_Latency          (S3_Min_Write_Latency),       
      .S4_Min_Write_Latency          (S4_Min_Write_Latency),       
      .S5_Min_Write_Latency          (S5_Min_Write_Latency),       
      .S6_Min_Write_Latency          (S6_Min_Write_Latency),       
      .S7_Min_Write_Latency          (S7_Min_Write_Latency),       
      .S0_Max_Read_Latency           (S0_Max_Read_Latency),                  
      .S1_Max_Read_Latency           (S1_Max_Read_Latency),                  
      .S2_Max_Read_Latency           (S2_Max_Read_Latency),                  
      .S3_Max_Read_Latency           (S3_Max_Read_Latency),                  
      .S4_Max_Read_Latency           (S4_Max_Read_Latency),                  
      .S5_Max_Read_Latency           (S5_Max_Read_Latency),                  
      .S6_Max_Read_Latency           (S6_Max_Read_Latency),                  
      .S7_Max_Read_Latency           (S7_Max_Read_Latency),                  
      .S0_Min_Read_Latency           (S0_Min_Read_Latency), 
      .S1_Min_Read_Latency           (S1_Min_Read_Latency), 
      .S2_Min_Read_Latency           (S2_Min_Read_Latency), 
      .S3_Min_Read_Latency           (S3_Min_Read_Latency), 
      .S4_Min_Read_Latency           (S4_Min_Read_Latency), 
      .S5_Min_Read_Latency           (S5_Min_Read_Latency), 
      .S6_Min_Read_Latency           (S6_Min_Read_Latency), 
      .S7_Min_Read_Latency           (S7_Min_Read_Latency), 
      .External_Event_Cnt_En         (External_Event_Cnt_En),
      .Metrics_Cnt_En                (Metrics_Cnt_En_sync),
      .Metrics_Cnt_Reset             (Metrics_Cnt_Reset_Final),
      .Metric_Sel_0                  (Metric_Sel_0     ),
      .Metric_Sel_1                  (Metric_Sel_1     ),
      .Metric_Sel_2                  (Metric_Sel_2     ),
      .Metric_Sel_3                  (Metric_Sel_3     ),
      .Metric_Sel_4                  (Metric_Sel_4     ),
      .Metric_Sel_5                  (Metric_Sel_5     ),
      .Metric_Sel_6                  (Metric_Sel_6     ),
      .Metric_Sel_7                  (Metric_Sel_7     ),
      .Metric_Sel_8                  (Metric_Sel_8     ),
      .Metric_Sel_9                  (Metric_Sel_9     ),
      .Range_Reg_0                   (Range_Reg_0      ),
      .Range_Reg_1                   (Range_Reg_1      ),
      .Range_Reg_2                   (Range_Reg_2      ),
      .Range_Reg_3                   (Range_Reg_3      ),
      .Range_Reg_4                   (Range_Reg_4      ),
      .Range_Reg_5                   (Range_Reg_5      ),
      .Range_Reg_6                   (Range_Reg_6      ),
      .Range_Reg_7                   (Range_Reg_7      ),
      .Range_Reg_8                   (Range_Reg_8      ),
      .Range_Reg_9                   (Range_Reg_9      ),
      .Metric_Cnt_0                  (Metric_Cnt_0  ) ,
      .Metric_Cnt_1                  (Metric_Cnt_1  ) ,
      .Metric_Cnt_2                  (Metric_Cnt_2  ) ,
      .Metric_Cnt_3                  (Metric_Cnt_3  ) ,
      .Metric_Cnt_4                  (Metric_Cnt_4  ) ,
      .Metric_Cnt_5                  (Metric_Cnt_5  ) ,
      .Metric_Cnt_6                  (Metric_Cnt_6  ) ,
      .Metric_Cnt_7                  (Metric_Cnt_7  ) ,
      .Metric_Cnt_8                  (Metric_Cnt_8  ) ,
      .Metric_Cnt_9                  (Metric_Cnt_9  ) ,
      .Incrementer_0                 (Incrementer_0  ) ,
      .Incrementer_1                 (Incrementer_1  ) ,
      .Incrementer_2                 (Incrementer_2  ) ,
      .Incrementer_3                 (Incrementer_3  ) ,
      .Incrementer_4                 (Incrementer_4  ) ,
      .Incrementer_5                 (Incrementer_5  ) ,
      .Incrementer_6                 (Incrementer_6  ) ,
      .Incrementer_7                 (Incrementer_7  ) ,
      .Incrementer_8                 (Incrementer_8  ) ,
      .Incrementer_9                 (Incrementer_9  ) ,
      .Acc_OF_0                      (Acc_OF_0  ) ,
      .Acc_OF_1                      (Acc_OF_1  ) ,
      .Acc_OF_2                      (Acc_OF_2  ) ,
      .Acc_OF_3                      (Acc_OF_3  ) ,
      .Acc_OF_4                      (Acc_OF_4  ) ,
      .Acc_OF_5                      (Acc_OF_5  ) ,
      .Acc_OF_6                      (Acc_OF_6  ) ,
      .Acc_OF_7                      (Acc_OF_7  ) ,
      .Acc_OF_8                      (Acc_OF_8  ) ,
      .Acc_OF_9                      (Acc_OF_9  ) ,
      .Incr_OF_0                     (Incr_OF_0  ) ,
      .Incr_OF_1                     (Incr_OF_1  ) ,
      .Incr_OF_2                     (Incr_OF_2  ) ,
      .Incr_OF_3                     (Incr_OF_3  ) ,
      .Incr_OF_4                     (Incr_OF_4  ) ,
      .Incr_OF_5                     (Incr_OF_5  ) ,
      .Incr_OF_6                     (Incr_OF_6  ) ,
      .Incr_OF_7                     (Incr_OF_7  ) ,
      .Incr_OF_8                     (Incr_OF_8  ) ,
      .Incr_OF_9                     (Incr_OF_9  ) 
    );


  //-- synchronizing Interval_Cnt_En and Interval_Cnt_Ld and reset to metric counters
    generate    
    if (C_AXI4LITE_CORE_CLK_ASYNC == 1) begin : GEN_INTERVAL_CNT_SYNC
      // Synchronizing external trigger
      //-- Double Flop synchronization
      axi_perf_mon_v5_0_12_cdc_sync
      #(
         .c_cdc_type      (1             ),   
         .c_flop_input    (0             ),  
         .c_reset_state   (1             ),  
         .c_single_bit    (0             ),  
         .c_vector_width  (3             ),  
         .c_mtbf_stages   (4             )  
       )sample_interval_cnt_cdc_sync 
       (
         .prmry_aclk      (s_axi_aclk                                                              ),
         .prmry_rst_n     (s_axi_aresetn                                                           ),
         .prmry_in        (1'b0                                                                    ),
         .prmry_vect_in   ({Reset_On_Sample_Int_Lapse,Interval_Cnt_Ld, Interval_Cnt_En}            ),
         .scndry_aclk     (core_aclk                                                               ),
         .scndry_rst_n    (core_aresetn                                                            ),
         .prmry_ack       (                                                                        ),
         .scndry_out      (                                                                        ),
         .scndry_vect_out ({Reset_On_Sample_Int_Lapse_sync,Interval_Cnt_Ld_sync, Interval_Cnt_En_sync}) 
        );
    end 
    else begin : GEN_INTERVAL_CNT_NO_SYNC
        assign Interval_Cnt_Ld_sync           = Interval_Cnt_Ld;
        assign Interval_Cnt_En_sync           = Interval_Cnt_En;
        assign Reset_On_Sample_Int_Lapse_sync = Reset_On_Sample_Int_Lapse;
    end 
    endgenerate 
     
   wire Interval_Cnt_En_i  = Interval_Cnt_En_sync & Metrics_Cnt_En_sync;

   //-- Sample Interval Counter
   generate
   if((C_HAVE_SAMPLED_METRIC_CNT == 1)) begin :GEN_SAMPLE_METRIC_CNT
       axi_perf_mon_v5_0_12_samp_intl_cnt
       #(
             .C_FAMILY                      (C_FAMILY),
             .C_METRICS_SAMPLE_COUNT_WIDTH  (C_METRICS_SAMPLE_COUNT_WIDTH)
        ) sample_interval_counter_inst
        (
             .clk                       (core_aclk     ),
             .rst_n                     (core_aresetn  ),
             .Interval_Cnt_En           (Interval_Cnt_En_i  ),
             .Interval_Cnt_Ld           (Interval_Cnt_Ld_sync  ),
             .Interval_Cnt_Ld_Val       (Sample_Interval  ),
             .Sample_Interval_Cnt       (Sample_Interval_Cnt  ),
             .Sample_Interval_Cnt_Lapse (Sample_Interval_Cnt_Lapse) 
        );
    
   end
   else begin :GEN_NO_SAMPLE_METRIC_CNT
       assign Sample_Interval_Cnt_Lapse = 1'b0;

   end
   endgenerate


   wire Sample_En = capture_event | Sample_Interval_Cnt_Lapse | Lat_Sample_Reg;
   wire Sample_Metrics_Data_Reset_n = (!reset_event) & core_aresetn & (!Metrics_Cnt_Reset_sync);
  
   // Sampled metrics data instance
   axi_perf_mon_v5_0_12_samp_metrics_data
   #(
         .C_FAMILY                    (C_FAMILY),
         .C_NUM_OF_COUNTERS           (C_NUM_OF_COUNTERS), 
         .C_ENABLE_EVENT_COUNT        (C_ENABLE_EVENT_COUNT),
         .C_HAVE_SAMPLED_METRIC_CNT   (C_HAVE_SAMPLED_METRIC_CNT)
    ) sampled_metrics_data_inst
    (
         .clk                  (core_aclk     ),
         .rst_n                (Sample_Metrics_Data_Reset_n  ),
         .Sample_En            (Sample_En     ),
         .Metric_Cnt_0         (Metric_Cnt_0  ) ,
         .Metric_Cnt_1         (Metric_Cnt_1  ) ,
         .Metric_Cnt_2         (Metric_Cnt_2  ) ,
         .Metric_Cnt_3         (Metric_Cnt_3  ) ,
         .Metric_Cnt_4         (Metric_Cnt_4  ) ,
         .Metric_Cnt_5         (Metric_Cnt_5  ) ,
         .Metric_Cnt_6         (Metric_Cnt_6  ) ,
         .Metric_Cnt_7         (Metric_Cnt_7  ) ,
         .Metric_Cnt_8         (Metric_Cnt_8  ) ,
         .Metric_Cnt_9         (Metric_Cnt_9  ) ,
         .Incrementer_0        (Incrementer_0  ) ,
         .Incrementer_1        (Incrementer_1  ) ,
         .Incrementer_2        (Incrementer_2  ) ,
         .Incrementer_3        (Incrementer_3  ) ,
         .Incrementer_4        (Incrementer_4  ) ,
         .Incrementer_5        (Incrementer_5  ) ,
         .Incrementer_6        (Incrementer_6  ) ,
         .Incrementer_7        (Incrementer_7  ) ,
         .Incrementer_8        (Incrementer_8  ) ,
         .Incrementer_9        (Incrementer_9  ) ,
         .Samp_Metric_Cnt_0    (Samp_Metric_Cnt_0  ) ,
         .Samp_Metric_Cnt_1    (Samp_Metric_Cnt_1  ) ,
         .Samp_Metric_Cnt_2    (Samp_Metric_Cnt_2  ) ,
         .Samp_Metric_Cnt_3    (Samp_Metric_Cnt_3  ) ,
         .Samp_Metric_Cnt_4    (Samp_Metric_Cnt_4  ) ,
         .Samp_Metric_Cnt_5    (Samp_Metric_Cnt_5  ) ,
         .Samp_Metric_Cnt_6    (Samp_Metric_Cnt_6  ) ,
         .Samp_Metric_Cnt_7    (Samp_Metric_Cnt_7  ) ,
         .Samp_Metric_Cnt_8    (Samp_Metric_Cnt_8  ) ,
         .Samp_Metric_Cnt_9    (Samp_Metric_Cnt_9  ) ,
         .Samp_Incrementer_0   (Samp_Incrementer_0  ) ,
         .Samp_Incrementer_1   (Samp_Incrementer_1  ) ,
         .Samp_Incrementer_2   (Samp_Incrementer_2  ) ,
         .Samp_Incrementer_3   (Samp_Incrementer_3  ) ,
         .Samp_Incrementer_4   (Samp_Incrementer_4  ) ,
         .Samp_Incrementer_5   (Samp_Incrementer_5  ) ,
         .Samp_Incrementer_6   (Samp_Incrementer_6  ) ,
         .Samp_Incrementer_7   (Samp_Incrementer_7  ) ,
         .Samp_Incrementer_8   (Samp_Incrementer_8  ) ,
         .Samp_Incrementer_9   (Samp_Incrementer_9  ) 
       );

endmodule


//-----------------------------------------------------------------------------
// axi_perf_mon_v5_0_12_profile  module
//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename     : axi_perf_mon_v5_0_12_profile.v
// Version      : v5.0
// Description  : This is the top level wrapper file for the AXI Performance
//                Monitor profile mode. 
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
// axi_perf_mon_v5_0_12_top.v
//   \--axi_perf_mon_v5_0_12_profile.v
//     \-- axi_perf_mon_v5_0_12_axi_interface.v
//             \--axi_perf_mon_v5_0_12_cdc_sync.v
//             \-- axi_perf_mon_v5_0_12_intr_sync.v
//                 \--axi_perf_mon_v5_0_12_cdc_sync.v
//      \-- axi_perf_mon_v5_0_12_interrupt_module.v
//      \-- axi_perf_mon_v5_0_12_cdc_sync.v
//      \-- axi_perf_mon_v5_0_12_mon_fifo.v
//           \-- axi_perf_mon_v5_0_12_async_fifo.vhd
//       \-- axi_perf_mon_v5_0_12_register_module_profile.v
//       \-- axi_perf_mon_v5_0_12_metric_calc_profile.v
//            \-- axi_perf_mon_v5_0_12_sync_fifo.vhd
//            \-- axi_perf_mon_v5_0_12_counter.v
//       \-- axi_perf_mon_v5_0_12_metric_counters_profile.v
//           \--axi_perf_mon_v5_0_12_acc_sample_profile.v
//      \-- axi_perf_mon_v5_0_12_strm_fifo_wr_logic.v
//      \-- axi_perf_mon_v5_0_12_async_stream_fifo.v
//       \-- axi_perf_mon_v5_0_12_flags_gen_trace.v
//---------------------------------------------------------------------------
// Author  :   NLR 
// History :    
// NLR       10/02/2013      First Version
// ^^^^^^
//---------------------------------------------------------------------------
`timescale 1ns/1ps
(* DowngradeIPIdentifiedWarnings="yes" *)

module axi_perf_mon_v5_0_12_profile 
  # (
    parameter C_FAMILY                        = "virtex7",

    //AXI Slave Interface parameters for this core
    parameter C_S_AXI_ADDR_WIDTH              = 16, 
    parameter C_S_AXI_DATA_WIDTH              = 32,
    parameter C_S_AXI_PROTOCOL                = "AXI4LITE",
    parameter C_S_AXI_ID_WIDTH                = 1,
    parameter C_SUPPORT_ID_REFLECTION         = 0,

    //Counter Parameters
    parameter C_ENABLE_PROFILE                = 0,   //-- enables profile logic
    parameter C_NUM_MONITOR_SLOTS             = 1,
    parameter C_NUM_OF_COUNTERS               = 10,
    parameter C_NUM_OF_COUNTERS_EXTND         = 2,
    parameter C_METRIC_COUNT_WIDTH            = 32, 
    parameter C_HAVE_SAMPLED_METRIC_CNT       = 1,  //-- enable sampled metric counters logic
    parameter C_METRICS_SAMPLE_COUNT_WIDTH    = 32,
    parameter C_AXI4LITE_CORE_CLK_ASYNC       = 1,  //-- disable synchronizers incase its 0 

    //AXI Slot 0 Interface parameters
    parameter C_SLOT_0_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_0_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_0_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_0_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_0_AXI_SUB_PROTOCOL       = "AXI4LITE",
    parameter C_SLOT_0_FIFO_ENABLE            = 1,

    //AXI Slot 1 Interface parameters
    parameter C_SLOT_1_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_1_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_1_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_1_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_1_AXI_SUB_PROTOCOL       = "AXI4LITE",
    parameter C_SLOT_1_FIFO_ENABLE            = 1,

    //AXI Slot 2 Interface parameters
    parameter C_SLOT_2_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_2_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_2_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_2_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_2_AXI_SUB_PROTOCOL       = "AXI4LITE",
    parameter C_SLOT_2_FIFO_ENABLE            = 1,
 
    //AXI Slot 3 Interface parameters
    parameter C_SLOT_3_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_3_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_3_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_3_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_3_AXI_SUB_PROTOCOL       = "AXI4LITE",
    parameter C_SLOT_3_FIFO_ENABLE            = 1,

    //AXI Slot 4 Interface parameters
    parameter C_SLOT_4_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_4_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_4_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_4_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_4_AXI_SUB_PROTOCOL       = "AXI4LITE",
    parameter C_SLOT_4_FIFO_ENABLE            = 1,

    //AXI Slot 5 Interface parameters
    parameter C_SLOT_5_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_5_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_5_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_5_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_5_AXI_SUB_PROTOCOL       = "AXI4LITE",
    parameter C_SLOT_5_FIFO_ENABLE            = 1,

    //AXI Slot 6 Interface parameters
    parameter C_SLOT_6_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_6_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_6_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_6_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_6_AXI_SUB_PROTOCOL       = "AXI4LITE",
    parameter C_SLOT_6_FIFO_ENABLE            = 1,

    //AXI Slot 7 Interface parameters
    parameter C_SLOT_7_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_7_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_7_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_7_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_7_AXI_SUB_PROTOCOL       = "AXI4LITE",
    parameter C_SLOT_7_FIFO_ENABLE            = 1,

    // Register all Monitor inputs option
    parameter C_REG_ALL_MONITOR_SIGNALS       = 0,

    // Fifo option for external events
    parameter C_EXT_EVENT0_FIFO_ENABLE        = 1,
    parameter C_EXT_EVENT1_FIFO_ENABLE        = 1,
    parameter C_EXT_EVENT2_FIFO_ENABLE        = 1,
    parameter C_EXT_EVENT3_FIFO_ENABLE        = 1,
    parameter C_EXT_EVENT4_FIFO_ENABLE        = 1,
    parameter C_EXT_EVENT5_FIFO_ENABLE        = 1,
    parameter C_EXT_EVENT6_FIFO_ENABLE        = 1,
    parameter C_EXT_EVENT7_FIFO_ENABLE        = 1,

    //Trace Parameters
    parameter C_ENABLE_TRACE                  = 0,   //-- enables event logging logic
    parameter C_FIFO_AXIS_DEPTH               = 32,  // AXI Streaming FIFO depth
    parameter C_FIFO_AXIS_TDATA_WIDTH         = 56, // AXI Streaming FIFO width
    parameter C_AXIS_DWIDTH_ROUND_TO_32       = 56, // AXI Streaming FIFO width rounded to next 32bit
    parameter C_FIFO_AXIS_TID_WIDTH           = 1,   // AXI Streaming FIFO ID width
    parameter C_FIFO_AXIS_SYNC                = 0,   // 1=Sync FIFO, 0=ASYNC FIFO
    parameter C_EN_AXI_DEBUG                  = 0, // 1= Address info in log
    parameter C_EN_TRIGGER                    = 0, // 1= enable trigger mechanism
    parameter C_SHOW_AXI_IDS                  = 1,
    parameter C_SHOW_AXI_LEN                  = 1,
    parameter C_EN_WR_ADD_FLAG                = 1, 
    parameter C_EN_FIRST_WRITE_FLAG           = 1, 
    parameter C_EN_LAST_WRITE_FLAG            = 1, 
    parameter C_EN_RESPONSE_FLAG              = 1, 
    parameter C_EN_RD_ADD_FLAG                = 1, 
    parameter C_EN_FIRST_READ_FLAG            = 1, 
    parameter C_EN_LAST_READ_FLAG             = 1, 
    parameter C_EN_SW_REG_WR_FLAG             = 0, 
    parameter C_EN_EXT_EVENTS_FLAG            = 0,
    parameter C_LOG_DATA_OFFLD                = 0,//0- stream offload,1-Memorymap offload 
    parameter S_AXI_OFFLD_ID_WIDTH            = 1, //offload interface ID width.
    parameter C_EN_ALL_TRACE                  = 0    
        )
    (
    //AXI-Lite Interface   
    input                                    s_axi_aclk,
    input                                    s_axi_aresetn,
    input [15:0]                             s_axi_awaddr,
    input                                    s_axi_awvalid,
    input [C_S_AXI_ID_WIDTH-1:0]             s_axi_awid,     //AXI4 Full Interface support
    output                                   s_axi_awready,
    input [31:0]                             s_axi_wdata,
    input [3:0]                              s_axi_wstrb,
    input                                    s_axi_wvalid,
    output                                   s_axi_wready,
    output [1:0]                             s_axi_bresp,
    output                                   s_axi_bvalid,
    output [C_S_AXI_ID_WIDTH-1:0]            s_axi_bid,      //AXI4 Full Interface support
    input                                    s_axi_bready,
    input  [15:0]                            s_axi_araddr,
    input                                    s_axi_arvalid,
    input [C_S_AXI_ID_WIDTH-1:0]             s_axi_arid,     //AXI4 Full Interface support
    output                                   s_axi_arready,
    output [31:0]                            s_axi_rdata,
    output [1:0]                             s_axi_rresp,
    output                                   s_axi_rvalid,
    output [C_S_AXI_ID_WIDTH-1:0]            s_axi_rid,      //AXI4 Full Interface support
    input                                    s_axi_rready,
  
    // SLOT 0 AXI MM Interface signals
    input                                    slot_0_axi_aclk,
    input                                    slot_0_axi_aresetn,
    input [C_SLOT_0_AXI_ID_WIDTH-1:0]        slot_0_axi_awid,
    input [C_SLOT_0_AXI_ADDR_WIDTH-1:0]      slot_0_axi_awaddr,
    input [2:0]                              slot_0_axi_awprot,
    input [7:0]                              slot_0_axi_awlen,
    input [2:0]                              slot_0_axi_awsize,
    input [1:0]                              slot_0_axi_awburst,
    input [3:0]                              slot_0_axi_awcache,
    input                                    slot_0_axi_awlock,
    input                                    slot_0_axi_awvalid,
    input                                    slot_0_axi_awready,
    input [C_SLOT_0_AXI_DATA_WIDTH-1:0]      slot_0_axi_wdata,
    input [C_SLOT_0_AXI_DATA_WIDTH/8-1:0]    slot_0_axi_wstrb,
    input                                    slot_0_axi_wlast,
    input                                    slot_0_axi_wvalid,
    input                                    slot_0_axi_wready,
    input [C_SLOT_0_AXI_ID_WIDTH-1:0]        slot_0_axi_bid,
    input [1:0]                              slot_0_axi_bresp,
    input                                    slot_0_axi_bvalid,
    input                                    slot_0_axi_bready,
    input [C_SLOT_0_AXI_ID_WIDTH-1:0]        slot_0_axi_arid,
    input [C_SLOT_0_AXI_ADDR_WIDTH-1:0]      slot_0_axi_araddr,
    input [7:0]                              slot_0_axi_arlen,
    input [2:0]                              slot_0_axi_arsize,
    input [1:0]                              slot_0_axi_arburst,
    input [3:0]                              slot_0_axi_arcache,
    input [2:0]                              slot_0_axi_arprot,
    input                                    slot_0_axi_arlock,
    input                                    slot_0_axi_arvalid,
    input                                    slot_0_axi_arready,
    input [C_SLOT_0_AXI_ID_WIDTH-1:0]        slot_0_axi_rid,
    input [C_SLOT_0_AXI_DATA_WIDTH-1:0]      slot_0_axi_rdata,
    input [1:0]                              slot_0_axi_rresp,
    input                                    slot_0_axi_rlast,
    input                                    slot_0_axi_rvalid,
    input                                    slot_0_axi_rready,
  
    //SLOT 0 External Triggers
    input                                    slot_0_ext_trig,
    input                                    slot_0_ext_trig_stop,
  
    // SLOT 1 AXI MM interface signals
    
    input                                    slot_1_axi_aclk,
    input                                    slot_1_axi_aresetn,
    input [C_SLOT_1_AXI_ID_WIDTH-1:0]        slot_1_axi_awid,
    input [C_SLOT_1_AXI_ADDR_WIDTH-1:0]      slot_1_axi_awaddr,
    input [2:0]                              slot_1_axi_awprot,
    input [7:0]                              slot_1_axi_awlen,
    input [2:0]                              slot_1_axi_awsize,
    input [1:0]                              slot_1_axi_awburst,
    input [3:0]                              slot_1_axi_awcache,
    input                                    slot_1_axi_awlock,
    input                                    slot_1_axi_awvalid,
    input                                    slot_1_axi_awready,
    input [C_SLOT_1_AXI_DATA_WIDTH-1:0]      slot_1_axi_wdata,
    input [C_SLOT_1_AXI_DATA_WIDTH/8-1:0]    slot_1_axi_wstrb,
    input                                    slot_1_axi_wlast,
    input                                    slot_1_axi_wvalid,
    input                                    slot_1_axi_wready,
    input [C_SLOT_1_AXI_ID_WIDTH-1:0]        slot_1_axi_bid,
    input [1:0]                              slot_1_axi_bresp,
    input                                    slot_1_axi_bvalid,
    input                                    slot_1_axi_bready,
    input [C_SLOT_1_AXI_ID_WIDTH-1:0]        slot_1_axi_arid,
    input [C_SLOT_1_AXI_ADDR_WIDTH-1:0]      slot_1_axi_araddr,
    input [7:0]                              slot_1_axi_arlen,
    input [2:0]                              slot_1_axi_arsize,
    input [1:0]                              slot_1_axi_arburst,
    input [3:0]                              slot_1_axi_arcache,
    input [2:0]                              slot_1_axi_arprot,
    input                                    slot_1_axi_arlock,
    input                                    slot_1_axi_arvalid,
    input                                    slot_1_axi_arready,
    input [C_SLOT_1_AXI_ID_WIDTH-1:0]        slot_1_axi_rid,
    input [C_SLOT_1_AXI_DATA_WIDTH-1:0]      slot_1_axi_rdata,
    input [1:0]                              slot_1_axi_rresp,
    input                                    slot_1_axi_rlast,
    input                                    slot_1_axi_rvalid,
    input                                    slot_1_axi_rready,
  
    //SLOT 1 External Trigger
    input                                    slot_1_ext_trig,
    input                                    slot_1_ext_trig_stop,

    //SLOT 2 AXI MM Interface 
  
    input                                    slot_2_axi_aclk,
    input                                    slot_2_axi_aresetn,
    input [C_SLOT_2_AXI_ID_WIDTH-1:0]        slot_2_axi_awid,
    input [C_SLOT_2_AXI_ADDR_WIDTH-1:0]      slot_2_axi_awaddr,
    input [2:0]                              slot_2_axi_awprot,
    input [7:0]                              slot_2_axi_awlen,
    input [2:0]                              slot_2_axi_awsize,
    input [1:0]                              slot_2_axi_awburst,
    input [3:0]                              slot_2_axi_awcache,
    input                                    slot_2_axi_awlock,
    input                                    slot_2_axi_awvalid,
    input                                    slot_2_axi_awready,
    input [C_SLOT_2_AXI_DATA_WIDTH-1:0]      slot_2_axi_wdata,
    input [C_SLOT_2_AXI_DATA_WIDTH/8-1: 0]   slot_2_axi_wstrb,
    input                                    slot_2_axi_wlast,
    input                                    slot_2_axi_wvalid,
    input                                    slot_2_axi_wready,
    input [C_SLOT_2_AXI_ID_WIDTH-1:0]        slot_2_axi_bid,
    input [1:0]                              slot_2_axi_bresp,
    input                                    slot_2_axi_bvalid,
    input                                    slot_2_axi_bready,
    input [C_SLOT_2_AXI_ID_WIDTH-1:0]        slot_2_axi_arid,
    input [C_SLOT_2_AXI_ADDR_WIDTH-1:0]      slot_2_axi_araddr,
    input [7:0]                              slot_2_axi_arlen,
    input [2:0]                              slot_2_axi_arsize,
    input [1:0]                              slot_2_axi_arburst,
    input [3:0]                              slot_2_axi_arcache,
    input [2:0]                              slot_2_axi_arprot,
    input                                    slot_2_axi_arlock,
    input                                    slot_2_axi_arvalid,
    input                                    slot_2_axi_arready,
    input [C_SLOT_2_AXI_ID_WIDTH-1:0]        slot_2_axi_rid,
    input [C_SLOT_2_AXI_DATA_WIDTH-1:0]      slot_2_axi_rdata,
    input [1:0]                              slot_2_axi_rresp,
    input                                    slot_2_axi_rlast,
    input                                    slot_2_axi_rvalid,
    input                                    slot_2_axi_rready,
  
   //SLOT 2 External Trigger
    input                                    slot_2_ext_trig,
    input                                    slot_2_ext_trig_stop,
  
   //SLOT 3 AXI MM Interface
    input                                    slot_3_axi_aclk,
    input                                    slot_3_axi_aresetn,
    input [C_SLOT_3_AXI_ID_WIDTH-1:0]        slot_3_axi_awid,
    input [C_SLOT_3_AXI_ADDR_WIDTH-1:0]      slot_3_axi_awaddr,
    input [2:0]                              slot_3_axi_awprot,
    input [7:0]                              slot_3_axi_awlen,
    input [2:0]                              slot_3_axi_awsize,
    input [1:0]                              slot_3_axi_awburst,
    input [3:0]                              slot_3_axi_awcache,
    input                                    slot_3_axi_awlock,
    input                                    slot_3_axi_awvalid,
    input                                    slot_3_axi_awready,
    input [C_SLOT_3_AXI_DATA_WIDTH-1:0]      slot_3_axi_wdata,
    input [C_SLOT_3_AXI_DATA_WIDTH/8-1:0]    slot_3_axi_wstrb,
    input                                    slot_3_axi_wlast,
    input                                    slot_3_axi_wvalid,
    input                                    slot_3_axi_wready,
    input [C_SLOT_3_AXI_ID_WIDTH-1:0]        slot_3_axi_bid,
    input [1:0]                              slot_3_axi_bresp,
    input                                    slot_3_axi_bvalid,
    input                                    slot_3_axi_bready,
    input [C_SLOT_3_AXI_ID_WIDTH-1:0]        slot_3_axi_arid,
    input [C_SLOT_3_AXI_ADDR_WIDTH-1:0]      slot_3_axi_araddr,
    input [7:0]                              slot_3_axi_arlen,
    input [2:0]                              slot_3_axi_arsize,
    input [1:0]                              slot_3_axi_arburst,
    input [3:0]                              slot_3_axi_arcache,
    input [2:0]                              slot_3_axi_arprot,
    input                                    slot_3_axi_arlock,
    input                                    slot_3_axi_arvalid,
    input                                    slot_3_axi_arready,
    input [C_SLOT_3_AXI_ID_WIDTH-1:0]        slot_3_axi_rid,
    input [C_SLOT_3_AXI_DATA_WIDTH-1:0]      slot_3_axi_rdata,
    input [1:0]                              slot_3_axi_rresp,
    input                                    slot_3_axi_rlast,
    input                                    slot_3_axi_rvalid,
    input                                    slot_3_axi_rready,
  
    //SLOT 3 External Trigger
    input                                    slot_3_ext_trig,
    input                                    slot_3_ext_trig_stop,
  
    //SLOT 4 AXI MM Interface
    input                                    slot_4_axi_aclk,
    input                                    slot_4_axi_aresetn,
    input [C_SLOT_4_AXI_ID_WIDTH-1:0]        slot_4_axi_awid,
    input [C_SLOT_4_AXI_ADDR_WIDTH-1:0]      slot_4_axi_awaddr,
    input [2:0]                              slot_4_axi_awprot,
    input [7:0]                              slot_4_axi_awlen,
    input [2:0]                              slot_4_axi_awsize,
    input [1:0]                              slot_4_axi_awburst,
    input [3:0]                              slot_4_axi_awcache,
    input                                    slot_4_axi_awlock,
    input                                    slot_4_axi_awvalid,
    input                                    slot_4_axi_awready,
    input [C_SLOT_4_AXI_DATA_WIDTH-1:0]      slot_4_axi_wdata,
    input [C_SLOT_4_AXI_DATA_WIDTH/8-1:0]    slot_4_axi_wstrb,
    input                                    slot_4_axi_wlast,
    input                                    slot_4_axi_wvalid,
    input                                    slot_4_axi_wready,
    input [C_SLOT_4_AXI_ID_WIDTH-1:0]        slot_4_axi_bid,
    input [1:0]                              slot_4_axi_bresp,
    input                                    slot_4_axi_bvalid,
    input                                    slot_4_axi_bready,
    input  [C_SLOT_4_AXI_ID_WIDTH-1:0]       slot_4_axi_arid,
    input  [C_SLOT_4_AXI_ADDR_WIDTH-1:0]     slot_4_axi_araddr,
    input  [7:0]                             slot_4_axi_arlen,
    input  [2:0]                             slot_4_axi_arsize,
    input  [1:0]                             slot_4_axi_arburst,
    input  [3:0]                             slot_4_axi_arcache,
    input  [2:0]                             slot_4_axi_arprot,
    input                                    slot_4_axi_arlock,
    input                                    slot_4_axi_arvalid,
    input                                    slot_4_axi_arready,
    input [C_SLOT_4_AXI_ID_WIDTH-1:0]        slot_4_axi_rid,
    input [C_SLOT_4_AXI_DATA_WIDTH-1:0]      slot_4_axi_rdata,
    input [1:0]                              slot_4_axi_rresp,
    input                                    slot_4_axi_rlast,
    input                                    slot_4_axi_rvalid,
    input                                    slot_4_axi_rready,
  
    //SLOT 4 External Trigger
    input                                    slot_4_ext_trig,
    input                                    slot_4_ext_trig_stop,

    //SLOT 5 AXI MM Interface
  
    input                                    slot_5_axi_aclk,
    input                                    slot_5_axi_aresetn,
    input [C_SLOT_5_AXI_ID_WIDTH-1:0]        slot_5_axi_awid,
    input [C_SLOT_5_AXI_ADDR_WIDTH-1:0]      slot_5_axi_awaddr,
    input [2:0]                              slot_5_axi_awprot,
    input [7:0]                              slot_5_axi_awlen,
    input [2:0]                              slot_5_axi_awsize,
    input [1:0]                              slot_5_axi_awburst,
    input [3:0]                              slot_5_axi_awcache,
    input                                    slot_5_axi_awlock,
    input                                    slot_5_axi_awvalid,
    input                                    slot_5_axi_awready,
    input [C_SLOT_5_AXI_DATA_WIDTH-1:0]      slot_5_axi_wdata,
    input [C_SLOT_5_AXI_DATA_WIDTH/8-1:0]    slot_5_axi_wstrb,
    input                                    slot_5_axi_wlast,
    input                                    slot_5_axi_wvalid,
    input                                    slot_5_axi_wready,
    input [C_SLOT_5_AXI_ID_WIDTH-1:0]        slot_5_axi_bid,
    input [1:0]                              slot_5_axi_bresp,
    input                                    slot_5_axi_bvalid,
    input                                    slot_5_axi_bready,
    input [C_SLOT_5_AXI_ID_WIDTH-1:0]        slot_5_axi_arid,
    input [C_SLOT_5_AXI_ADDR_WIDTH-1:0]      slot_5_axi_araddr,
    input [7:0]                              slot_5_axi_arlen,
    input [2:0]                              slot_5_axi_arsize,
    input [1:0]                              slot_5_axi_arburst,
    input [3:0]                              slot_5_axi_arcache,
    input [2:0]                              slot_5_axi_arprot,
    input                                    slot_5_axi_arlock,
    input                                    slot_5_axi_arvalid,
    input                                    slot_5_axi_arready,
    input [C_SLOT_5_AXI_ID_WIDTH-1:0]        slot_5_axi_rid,
    input [C_SLOT_5_AXI_DATA_WIDTH-1:0]      slot_5_axi_rdata,
    input [1:0]                              slot_5_axi_rresp,
    input                                    slot_5_axi_rlast,
    input                                    slot_5_axi_rvalid,
    input                                    slot_5_axi_rready,
  
    //SLOT 5 External Trigger
    input                                    slot_5_ext_trig,
    input                                    slot_5_ext_trig_stop,
  
    //SLOT 6 AXI MM Interface
    input                                    slot_6_axi_aclk,
    input                                    slot_6_axi_aresetn,
    input [C_SLOT_6_AXI_ID_WIDTH-1:0]        slot_6_axi_awid,
    input [C_SLOT_6_AXI_ADDR_WIDTH-1:0]      slot_6_axi_awaddr,
    input [2:0]                              slot_6_axi_awprot,
    input [7:0]                              slot_6_axi_awlen,
    input [2:0]                              slot_6_axi_awsize,
    input [1:0]                              slot_6_axi_awburst,
    input [3:0]                              slot_6_axi_awcache,
    input                                    slot_6_axi_awlock,
    input                                    slot_6_axi_awvalid,
    input                                    slot_6_axi_awready,
    input [C_SLOT_6_AXI_DATA_WIDTH-1:0]      slot_6_axi_wdata,
    input [C_SLOT_6_AXI_DATA_WIDTH/8-1:0]    slot_6_axi_wstrb,
    input                                    slot_6_axi_wlast,
    input                                    slot_6_axi_wvalid,
    input                                    slot_6_axi_wready,
    input [C_SLOT_6_AXI_ID_WIDTH-1:0]        slot_6_axi_bid,
    input [1:0]                              slot_6_axi_bresp,
    input                                    slot_6_axi_bvalid,
    input                                    slot_6_axi_bready,
    input [C_SLOT_6_AXI_ID_WIDTH-1:0]        slot_6_axi_arid,
    input [C_SLOT_6_AXI_ADDR_WIDTH-1:0]      slot_6_axi_araddr,
    input [7:0]                              slot_6_axi_arlen,
    input [2:0]                              slot_6_axi_arsize,
    input [1:0]                              slot_6_axi_arburst,
    input [3:0]                              slot_6_axi_arcache,
    input [2:0]                              slot_6_axi_arprot,
    input                                    slot_6_axi_arlock,
    input                                    slot_6_axi_arvalid,
    input                                    slot_6_axi_arready,
    input [C_SLOT_6_AXI_ID_WIDTH-1:0]        slot_6_axi_rid,
    input [C_SLOT_6_AXI_DATA_WIDTH-1:0]      slot_6_axi_rdata,
    input [1:0]                              slot_6_axi_rresp,
    input                                    slot_6_axi_rlast,
    input                                    slot_6_axi_rvalid,
    input                                    slot_6_axi_rready,
  
    //SLOT 6 External Trigger
    input                                    slot_6_ext_trig,
    input                                    slot_6_ext_trig_stop,
  
    //SLOT 7 AXI MM Interface
    input                                    slot_7_axi_aclk,
    input                                    slot_7_axi_aresetn,
    input [C_SLOT_7_AXI_ID_WIDTH-1:0]        slot_7_axi_awid,
    input [C_SLOT_7_AXI_ADDR_WIDTH-1:0]      slot_7_axi_awaddr,
    input [2:0]                              slot_7_axi_awprot,
    input [7:0]                              slot_7_axi_awlen,
    input [2:0]                              slot_7_axi_awsize,
    input [1:0]                              slot_7_axi_awburst,
    input [3:0]                              slot_7_axi_awcache,
    input                                    slot_7_axi_awlock,
    input                                    slot_7_axi_awvalid,
    input                                    slot_7_axi_awready,
    input [C_SLOT_7_AXI_DATA_WIDTH-1:0]      slot_7_axi_wdata,
    input [C_SLOT_7_AXI_DATA_WIDTH/8-1:0]    slot_7_axi_wstrb,
    input                                    slot_7_axi_wlast,
    input                                    slot_7_axi_wvalid,
    input                                    slot_7_axi_wready,
    input [C_SLOT_7_AXI_ID_WIDTH-1:0]        slot_7_axi_bid,
    input [1:0]                              slot_7_axi_bresp,
    input                                    slot_7_axi_bvalid,
    input                                    slot_7_axi_bready,
    input [C_SLOT_7_AXI_ID_WIDTH-1:0]        slot_7_axi_arid,
    input [C_SLOT_7_AXI_ADDR_WIDTH-1:0]      slot_7_axi_araddr,
    input [7:0]                              slot_7_axi_arlen,
    input [2:0]                              slot_7_axi_arsize,
    input [1:0]                              slot_7_axi_arburst,
    input [3:0]                              slot_7_axi_arcache,
    input [2:0]                              slot_7_axi_arprot,
    input                                    slot_7_axi_arlock,
    input                                    slot_7_axi_arvalid,
    input                                    slot_7_axi_arready,
    input  [C_SLOT_7_AXI_ID_WIDTH-1:0]       slot_7_axi_rid,
    input  [C_SLOT_7_AXI_DATA_WIDTH-1:0]     slot_7_axi_rdata,
    input  [1:0]                             slot_7_axi_rresp,
    input                                    slot_7_axi_rlast,
    input                                    slot_7_axi_rvalid,
    input                                    slot_7_axi_rready,
  
    //SLOT 7 External Trigger
    input                                    slot_7_ext_trig,
    input                                    slot_7_ext_trig_stop,
 
     // External Event 0
    input                                    ext_clk_0,
    input                                    ext_rstn_0,
    input                                    ext_event_0_cnt_start,
    input                                    ext_event_0_cnt_stop,
    input                                    ext_event_0,
  
     // External Event 1
    input                                    ext_clk_1,
    input                                    ext_rstn_1,
    input                                    ext_event_1_cnt_start,
    input                                    ext_event_1_cnt_stop,
    input                                    ext_event_1,

     // External Event 2
    input                                    ext_clk_2,
    input                                    ext_rstn_2,
    input                                    ext_event_2_cnt_start,
    input                                    ext_event_2_cnt_stop,
    input                                    ext_event_2,

     // External Event 3
    input                                    ext_clk_3,
    input                                    ext_rstn_3,
    input                                    ext_event_3_cnt_start,
    input                                    ext_event_3_cnt_stop,
    input                                    ext_event_3,

    // External Event 4
    input                                    ext_clk_4,
    input                                    ext_rstn_4,
    input                                    ext_event_4_cnt_start,
    input                                    ext_event_4_cnt_stop,
    input                                    ext_event_4,

    // External Event 5
    input                                    ext_clk_5,
    input                                    ext_rstn_5,
    input                                    ext_event_5_cnt_start,
    input                                    ext_event_5_cnt_stop,
    input                                    ext_event_5,

    // External Event 6
    input                                    ext_clk_6,
    input                                    ext_rstn_6,
    input                                    ext_event_6_cnt_start,
    input                                    ext_event_6_cnt_stop,
    input                                    ext_event_6,

    // External Event 7
    input                                    ext_clk_7,
    input                                    ext_rstn_7,
    input                                    ext_event_7_cnt_start,
    input                                    ext_event_7_cnt_stop,
    input                                    ext_event_7,
  
     // Capture and Reset events for metric counters
    input                                    capture_event,
    input                                    reset_event,
  
     // Core Clock and Reset signals
    input                                    core_aclk,
    input                                    core_aresetn,
 
     // Event Log streaming interface
    input                                    m_axis_aclk,
    input                                    m_axis_aresetn,
    output [C_FIFO_AXIS_TDATA_WIDTH-1:0]     m_axis_tdata,
    output [C_FIFO_AXIS_TDATA_WIDTH/8-1:0]   m_axis_tstrb,
    output                                   m_axis_tvalid,
    output [C_FIFO_AXIS_TID_WIDTH-1:0]       m_axis_tid,
    input                                    m_axis_tready,
    
     // Event Log 32b memorymap  interface
    input                                    s_axi_offld_aclk,
    input                                    s_axi_offld_aresetn,
    input [31:0]                             s_axi_offld_araddr ,
    input                                    s_axi_offld_arvalid,
    input [7:0]                              s_axi_offld_arlen  ,
    input [S_AXI_OFFLD_ID_WIDTH-1:0]         s_axi_offld_arid   ,    
    output                                   s_axi_offld_arready,
    input                                    s_axi_offld_rready ,
    output [31:0]                            s_axi_offld_rdata  ,
    output [1:0]                             s_axi_offld_rresp  ,
    output                                   s_axi_offld_rvalid ,
    output [S_AXI_OFFLD_ID_WIDTH-1:0]        s_axi_offld_rid    ,      
    output                                   s_axi_offld_rlast  ,      
    
     // Interrupt to the Processor
    output                                   interrupt,
    input                       			      trigger_in,
    output 				    trigger_in_ack
);
  

   /*---------------------------------------------------------------------
   -----------------------Parameter declarations-------------------------
   ------------------------------------------------------------------------*/
  localparam RST_ACTIVE = 1'b0;
  localparam C_NUM_INTR_INPUTS = 2; 
  localparam C_SW_SYNC_DATA_WIDTH = 32; 

  localparam C_MON_FIFO_DWIDTH_S0 = C_SLOT_0_AXI_ID_WIDTH*4 +C_SLOT_0_AXI_ADDR_WIDTH*2 +(C_SLOT_0_AXI_DATA_WIDTH/8)+42;
  localparam C_MON_FIFO_DWIDTH_S1 = C_SLOT_1_AXI_ID_WIDTH*4 +C_SLOT_1_AXI_ADDR_WIDTH*2 +(C_SLOT_1_AXI_DATA_WIDTH/8)+42;
  localparam C_MON_FIFO_DWIDTH_S2 = C_SLOT_2_AXI_ID_WIDTH*4 +C_SLOT_2_AXI_ADDR_WIDTH*2 +(C_SLOT_2_AXI_DATA_WIDTH/8)+42;
  localparam C_MON_FIFO_DWIDTH_S3 = C_SLOT_3_AXI_ID_WIDTH*4 +C_SLOT_3_AXI_ADDR_WIDTH*2 +(C_SLOT_3_AXI_DATA_WIDTH/8)+42;
  localparam C_MON_FIFO_DWIDTH_S4 = C_SLOT_4_AXI_ID_WIDTH*4 +C_SLOT_4_AXI_ADDR_WIDTH*2 +(C_SLOT_4_AXI_DATA_WIDTH/8)+42; 
  localparam C_MON_FIFO_DWIDTH_S5 = C_SLOT_5_AXI_ID_WIDTH*4 +C_SLOT_5_AXI_ADDR_WIDTH*2 +(C_SLOT_5_AXI_DATA_WIDTH/8)+42; 
  localparam C_MON_FIFO_DWIDTH_S6 = C_SLOT_6_AXI_ID_WIDTH*4 +C_SLOT_6_AXI_ADDR_WIDTH*2 +(C_SLOT_6_AXI_DATA_WIDTH/8)+42; 
  localparam C_MON_FIFO_DWIDTH_S7 = C_SLOT_7_AXI_ID_WIDTH*4 +C_SLOT_7_AXI_ADDR_WIDTH*2 +(C_SLOT_7_AXI_DATA_WIDTH/8)+42; 
  
  //-- Flag widths for each monitor slot  
  // localparam C_SLOT_N_FLAG_WIDTH = C_EN_WR_ADD_FLAG+C_EN_FIRST_WRITE_FLAG+C_EN_LAST_WRITE_FLAG+C_EN_RESPONSE_FLAG
  //                                +C_EN_RD_ADD_FLAG+C_EN_FIRST_READ_FLAG+C_EN_LAST_READ_FLAG;
  localparam C_SLOT_N_FLAG_WIDTH = 7;

  //-- Log Data widths for each monitor slot  
  localparam C_SLOT_0_LOG_DATA_WIDTH = (C_EN_AXI_DEBUG) ? (C_SLOT_0_AXI_ADDR_WIDTH*2 +16+4) : ((4*C_SLOT_0_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN));  
  localparam C_SLOT_1_LOG_DATA_WIDTH = (C_EN_AXI_DEBUG) ? (C_SLOT_1_AXI_ADDR_WIDTH*2 +16+4) : ((4*C_SLOT_1_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN));  
  localparam C_SLOT_2_LOG_DATA_WIDTH = (C_EN_AXI_DEBUG) ? (C_SLOT_2_AXI_ADDR_WIDTH*2 +16+4) : ((4*C_SLOT_2_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN));  
  localparam C_SLOT_3_LOG_DATA_WIDTH = (C_EN_AXI_DEBUG) ? (C_SLOT_3_AXI_ADDR_WIDTH*2 +16+4) : ((4*C_SLOT_3_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN));  
  localparam C_SLOT_4_LOG_DATA_WIDTH = (C_EN_AXI_DEBUG) ? (C_SLOT_4_AXI_ADDR_WIDTH*2 +16+4) : ((4*C_SLOT_4_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN));  
  localparam C_SLOT_5_LOG_DATA_WIDTH = (C_EN_AXI_DEBUG) ? (C_SLOT_5_AXI_ADDR_WIDTH*2 +16+4) : ((4*C_SLOT_5_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN));  
  localparam C_SLOT_6_LOG_DATA_WIDTH = (4*C_SLOT_6_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN);  
  localparam C_SLOT_7_LOG_DATA_WIDTH = (4*C_SLOT_7_AXI_ID_WIDTH*C_SHOW_AXI_IDS) + (16*C_SHOW_AXI_LEN);  
 
  localparam C_SLOT_0_LOG_WIDTH = (C_EN_AXI_DEBUG) ? (C_SLOT_0_LOG_DATA_WIDTH) : (C_SLOT_0_LOG_DATA_WIDTH + C_SLOT_N_FLAG_WIDTH);
  localparam C_SLOT_1_LOG_WIDTH = (C_EN_AXI_DEBUG) ? (C_SLOT_1_LOG_DATA_WIDTH) : (C_SLOT_1_LOG_DATA_WIDTH + C_SLOT_N_FLAG_WIDTH);
  localparam C_SLOT_2_LOG_WIDTH = (C_EN_AXI_DEBUG) ? (C_SLOT_2_LOG_DATA_WIDTH) : (C_SLOT_2_LOG_DATA_WIDTH + C_SLOT_N_FLAG_WIDTH);
  localparam C_SLOT_3_LOG_WIDTH = (C_EN_AXI_DEBUG) ? (C_SLOT_3_LOG_DATA_WIDTH) : (C_SLOT_3_LOG_DATA_WIDTH + C_SLOT_N_FLAG_WIDTH);
  localparam C_SLOT_4_LOG_WIDTH = (C_EN_AXI_DEBUG) ? (C_SLOT_4_LOG_DATA_WIDTH) : (C_SLOT_4_LOG_DATA_WIDTH + C_SLOT_N_FLAG_WIDTH);
  localparam C_SLOT_5_LOG_WIDTH = (C_EN_AXI_DEBUG) ? (C_SLOT_5_LOG_DATA_WIDTH) : (C_SLOT_5_LOG_DATA_WIDTH + C_SLOT_N_FLAG_WIDTH);
  localparam C_SLOT_6_LOG_WIDTH = C_SLOT_6_LOG_DATA_WIDTH + C_SLOT_N_FLAG_WIDTH;
  localparam C_SLOT_7_LOG_WIDTH = C_SLOT_7_LOG_DATA_WIDTH + C_SLOT_N_FLAG_WIDTH;
  
  localparam C_MAX_OUTSTAND_DEPTH = 32;
 
   /*---------------------------------------------------------------------
   -----------------------wire/connection declarations-------------------------
   ------------------------------------------------------------------------*/
  wire [31:0]                          Trace_ctrl_reg;
  
  wire  [(C_S_AXI_ADDR_WIDTH - 1):0]   Bus2IP_Addr          ;
  wire  [(C_S_AXI_DATA_WIDTH - 1):0]   Bus2IP_Data          ;
  wire  [(C_S_AXI_DATA_WIDTH/8 - 1):0] Bus2IP_BE            ;
  wire                                 Bus2IP_Burst         ;
  wire                                 Bus2IP_RdCE          ;
  wire                                 Bus2IP_WrCE          ;
  wire  [(C_S_AXI_DATA_WIDTH - 1):0]   IP2Bus_Data          ;
  wire                                 IP2Bus_DataValid     ;
  wire                                 IP2Bus_Error         ;
  wire  [(C_METRICS_SAMPLE_COUNT_WIDTH - 1):0] Sample_Interval;    
  wire  [(C_METRICS_SAMPLE_COUNT_WIDTH - 1):0] Sample_Interval_Cnt;    
  wire                                 Interval_Cnt_En      ;
  wire                                 Interval_Cnt_Ld      ;
  wire                                 Sample_Interval_Cnt_Lapse      ;
  wire                                 Reset_On_Sample_Int_Lapse;
  wire                                 Global_Intr_En       ;
  wire                                 Intr_Reg_IER_Wr_En   ;
  wire                                 Intr_Reg_ISR_Wr_En   ;
  wire [(C_NUM_INTR_INPUTS - 1):0]     Intr_Reg_IER         ;   
  wire [(C_NUM_INTR_INPUTS - 1):0]     Intr_Reg_ISR         ;    
  wire                                 eventlog_rd_clk         ;    
  wire                                 eventlog_rd_rstn         ;    
  wire [31:0]                          eventlog_cur_cnt         ;    
  wire [31:0]                          Metric_Cnt_0;    
  wire [31:0]                          Metric_Cnt_1;    
  wire [31:0]                          Metric_Cnt_2;    
  wire [31:0]                          Metric_Cnt_3;    
  wire [31:0]                          Metric_Cnt_4;    
  wire [31:0]                          Metric_Cnt_5;    
  wire [31:0]                          Metric_Cnt_6;    
  wire [31:0]                          Metric_Cnt_7;    
  wire [31:0]                          Metric_Cnt_8;    
  wire [31:0]                          Metric_Cnt_9;    
  wire [31:0]                          Samp_Metric_Cnt_0;    
  wire [31:0]                          Samp_Metric_Cnt_1;    
  wire [31:0]                          Samp_Metric_Cnt_2;    
  wire [31:0]                          Samp_Metric_Cnt_3;    
  wire [31:0]                          Samp_Metric_Cnt_4;    
  wire [31:0]                          Samp_Metric_Cnt_5;    
  wire [31:0]                          Samp_Metric_Cnt_6;    
  wire [31:0]                          Samp_Metric_Cnt_7;    
  wire [31:0]                          Samp_Metric_Cnt_8;    
  wire [31:0]                          Samp_Metric_Cnt_9;    
  wire [6:0]                           Flag_Enable_Reg;    
  wire                                 SW_Data_Log_En;    
  wire [C_SW_SYNC_DATA_WIDTH-1:0]      SW_Data;    
  wire                                 SW_Data_Wr_En;    
  wire                                 Streaming_FIFO_Reset;
  wire                                 Event_Log_En;
  wire                                 Metrics_Cnt_En;
  wire                                 Metrics_Cnt_Reset;
  wire  [5:0]                          Control_Bits_sync  ;
  wire [(C_NUM_INTR_INPUTS - 1):0]     Intr_In             ;    
  wire [(C_NUM_INTR_INPUTS - 1):0]     Intr_In_sync        ;    

  wire  [C_SLOT_0_LOG_WIDTH-1:0]       Slot_0_Log;
  wire  [C_SLOT_1_LOG_WIDTH-1:0]       Slot_1_Log;
  wire  [C_SLOT_2_LOG_WIDTH-1:0]       Slot_2_Log;
  wire  [C_SLOT_3_LOG_WIDTH-1:0]       Slot_3_Log;
  wire  [C_SLOT_4_LOG_WIDTH-1:0]       Slot_4_Log;
  wire  [C_SLOT_5_LOG_WIDTH-1:0]       Slot_5_Log;
  wire  [C_SLOT_6_LOG_WIDTH-1:0]       Slot_6_Log;
  wire  [C_SLOT_7_LOG_WIDTH-1:0]       Slot_7_Log;
  localparam log_wid_mark = (C_EN_TRIGGER == 1) ? 4: 0;
  wire 	  Slot_0_Log_En_Marked;
  wire [C_SLOT_0_LOG_WIDTH-1+log_wid_mark:0] Slot_0_Log_Marked;
  wire 	  Slot_1_Log_En_Marked;
  wire [C_SLOT_1_LOG_WIDTH-1+log_wid_mark:0] Slot_1_Log_Marked;
  wire 	  Slot_2_Log_En_Marked;
  wire [C_SLOT_2_LOG_WIDTH-1+log_wid_mark:0] Slot_2_Log_Marked;
  wire 	  Slot_3_Log_En_Marked;
  wire [C_SLOT_3_LOG_WIDTH-1+log_wid_mark:0] Slot_3_Log_Marked;
  wire 	  Slot_4_Log_En_Marked;
  wire [C_SLOT_4_LOG_WIDTH-1+log_wid_mark:0] Slot_4_Log_Marked;
  wire 	  Slot_5_Log_En_Marked;
  wire [C_SLOT_5_LOG_WIDTH-1+log_wid_mark:0] Slot_5_Log_Marked;
 wire stream_fifo_rst_n;
  // Streaming FIFO connections
  wire                                 Streaming_Fifo_Full   ;
  reg                                  Streaming_Fifo_Full_D1;
  wire                                 Streaming_Fifo_Full_Edge;
  wire                                 Streaming_Fifo_Empty  ;
  wire                                 Streaming_Fifo_Wr_En  ;
  wire  [C_FIFO_AXIS_TDATA_WIDTH-1:0]  Streaming_Fifo_Wr_Data;

  wire                                 SLOT_0_clk;
  wire                                 SLOT_0_Arst_n;
  wire [C_MON_FIFO_DWIDTH_S0-1:0]      Slot_0_Data_In;
  wire [C_MON_FIFO_DWIDTH_S0-1:0]      Slot_0_Sync_Data_Out;
  wire                                 Slot_0_Sync_Data_Valid;
  wire                                 SLOT_1_clk;
  wire                                 SLOT_1_Arst_n;
  wire [C_MON_FIFO_DWIDTH_S1-1:0]      Slot_1_Data_In;
  wire [C_MON_FIFO_DWIDTH_S1-1:0]      Slot_1_Sync_Data_Out;
  wire                                 Slot_1_Sync_Data_Valid;
  wire                                 SLOT_2_clk;
  wire                                 SLOT_2_Arst_n;
  wire [C_MON_FIFO_DWIDTH_S2-1:0]      Slot_2_Data_In;
  wire [C_MON_FIFO_DWIDTH_S2-1:0]      Slot_2_Sync_Data_Out;
  wire                                 Slot_2_Sync_Data_Valid;
  wire                                 SLOT_3_clk;
  wire                                 SLOT_3_Arst_n;
  wire [C_MON_FIFO_DWIDTH_S3-1:0]      Slot_3_Data_In;
  wire [C_MON_FIFO_DWIDTH_S3-1:0]      Slot_3_Sync_Data_Out;
  wire                                 Slot_3_Sync_Data_Valid;
  wire                                 SLOT_4_clk;
  wire                                 SLOT_4_Arst_n;
  wire [C_MON_FIFO_DWIDTH_S4-1:0]      Slot_4_Data_In;
  wire [C_MON_FIFO_DWIDTH_S4-1:0]      Slot_4_Sync_Data_Out;
  wire                                 Slot_4_Sync_Data_Valid;
  wire                                 SLOT_5_clk;
  wire                                 SLOT_5_Arst_n;
  wire [C_MON_FIFO_DWIDTH_S5-1:0]      Slot_5_Data_In;
  wire [C_MON_FIFO_DWIDTH_S5-1:0]      Slot_5_Sync_Data_Out;
  wire                                 Slot_5_Sync_Data_Valid;
  wire                                 SLOT_6_clk;
  wire                                 SLOT_6_Arst_n;
  wire [C_MON_FIFO_DWIDTH_S6-1:0]      Slot_6_Data_In;
  wire [C_MON_FIFO_DWIDTH_S6-1:0]      Slot_6_Sync_Data_Out;
  wire                                 Slot_6_Sync_Data_Valid;
  wire                                 SLOT_7_clk;
  wire                                 SLOT_7_Arst_n;
  wire [C_MON_FIFO_DWIDTH_S7-1:0]      Slot_7_Data_In;
  wire [C_MON_FIFO_DWIDTH_S7-1:0]      Slot_7_Sync_Data_Out;
  wire                                 Slot_7_Sync_Data_Valid;
  //Metric counter connections 
  wire                                 Metrics_Cnt_En_sync       ; 
  wire                                 Metrics_Cnt_Reset_sync    ; 
  wire                                 Event_Log_En_sync         ; 
  wire                                 Streaming_FIFO_Reset_sync ; 
  wire                                 Interval_Cnt_Ld_sync ; 
  wire                                 Interval_Cnt_En_sync ; 
  wire                                 Reset_On_Sample_Int_Lapse_sync ; 
  wire                                 Sample_Metric_Cnt_Ovf_En_sync;

  // 8 monitor slots metric count enables

  wire [C_NUM_MONITOR_SLOTS-1:0]       Wtrans_Cnt_En;
  wire [C_NUM_MONITOR_SLOTS-1:0]       Rtrans_Cnt_En;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_Write_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_Write_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_Write_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_Write_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_Write_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_Write_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_Write_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_Write_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_Read_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_Read_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_Read_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_Read_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_Read_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_Read_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_Read_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_Read_Byte_Cnt;
  wire                                 S0_Read_Byte_Cnt_En;
  wire                                 S1_Read_Byte_Cnt_En;
  wire                                 S2_Read_Byte_Cnt_En;
  wire                                 S3_Read_Byte_Cnt_En;
  wire                                 S4_Read_Byte_Cnt_En;
  wire                                 S5_Read_Byte_Cnt_En;
  wire                                 S6_Read_Byte_Cnt_En;
  wire                                 S7_Read_Byte_Cnt_En;
  wire [C_NUM_MONITOR_SLOTS-1:0]       Write_Beat_Cnt_En;
  wire [C_NUM_MONITOR_SLOTS-1:0]       Read_Beat_Cnt_En;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_Min_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_Min_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_Min_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_Min_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_Min_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_Min_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_Min_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_Min_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_Max_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_Max_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_Max_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_Max_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_Max_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_Max_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_Max_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_Max_Read_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_Min_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_Min_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_Min_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_Min_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_Min_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_Min_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_Min_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_Min_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_Max_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_Max_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_Max_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_Max_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_Max_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_Max_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_Max_Write_Latency;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_Max_Write_Latency;
  wire [C_NUM_MONITOR_SLOTS-1:0]       Read_Latency_En;
  wire [C_NUM_MONITOR_SLOTS-1:0]       Write_Latency_En;
  wire [C_NUM_MONITOR_SLOTS-1:0]       Slv_Wr_Idle_Cnt_En;        
  wire [C_NUM_MONITOR_SLOTS-1:0]       Mst_Rd_Idle_Cnt_En;        
  wire [C_NUM_MONITOR_SLOTS-1:0]       Num_BValids_En;       
  wire [C_NUM_MONITOR_SLOTS-1:0]       Num_WLasts_En;             
  wire [C_NUM_MONITOR_SLOTS-1:0]       Num_RLasts_En;      
  //AXI Streaming metrics
  wire [C_NUM_MONITOR_SLOTS-1:0]       S_Transfer_Cnt_En;
  wire [C_NUM_MONITOR_SLOTS-1:0]       S_Packet_Cnt_En;  
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_S_Data_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_S_Data_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_S_Data_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_S_Data_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_S_Data_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_S_Data_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_S_Data_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_S_Data_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_S_Position_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_S_Position_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_S_Position_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_S_Position_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_S_Position_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_S_Position_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_S_Position_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_S_Position_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S0_S_Null_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S1_S_Null_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S2_S_Null_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S3_S_Null_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S4_S_Null_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S5_S_Null_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S6_S_Null_Byte_Cnt;
  wire [C_METRIC_COUNT_WIDTH-1:0]      S7_S_Null_Byte_Cnt;
  wire [C_NUM_MONITOR_SLOTS-1:0]       S_Slv_Idle_Cnt_En;
  wire [C_NUM_MONITOR_SLOTS-1:0]       S_Mst_Idle_Cnt_En;
  wire [C_METRIC_COUNT_WIDTH-1:0]      Metric_Cnt_Out;
  wire [C_METRIC_COUNT_WIDTH-1:0]      Sample_Metric_Cnt_Out;


  //External Events
  wire [C_NUM_MONITOR_SLOTS-1:0]       External_Event_Cnt_En;
  wire [2:0]                           Ext_Event0_Flags;
  wire [2:0]                           Ext_Event1_Flags;
  wire [2:0]                           Ext_Event2_Flags;
  wire [2:0]                           Ext_Event3_Flags;
  wire [2:0]                           Ext_Event4_Flags;
  wire [2:0]                           Ext_Event5_Flags;
  wire [2:0]                           Ext_Event6_Flags;
  wire [2:0]                           Ext_Event7_Flags;
  wire [2:0]                           Ext_Event_Flag_En;
 
  // Accumulator signals
  wire                                 Acc_OF_0;    
  wire                                 Acc_OF_1;    
  wire                                 Acc_OF_2;    
  wire                                 Acc_OF_3;    
  wire                                 Acc_OF_4;    
  wire                                 Acc_OF_5;    
  wire                                 Acc_OF_6;    
  wire                                 Acc_OF_7;    
  wire                                 Acc_OF_8;    
  wire                                 Acc_OF_9;    
  // Incrementor signals
  wire                                 Incr_OF_0;    
  wire                                 Incr_OF_1;    
  wire                                 Incr_OF_2;    
  wire                                 Incr_OF_3;    
  wire                                 Incr_OF_4;    
  wire                                 Incr_OF_5;    
  wire                                 Incr_OF_6;    
  wire                                 Incr_OF_7;    
  wire                                 Incr_OF_8;    
  wire                                 Incr_OF_9;    
  wire                                 Use_Ext_Trig;
  wire                                 Use_Ext_Trig_sync;
  wire                                 Use_Ext_Trig_Log;
  wire                                 Use_Ext_Trig_Log_sync;

  //Flag generator log enables
  wire                                 Slot_0_Log_En;
  wire                                 Slot_1_Log_En;
  wire                                 Slot_2_Log_En;
  wire                                 Slot_3_Log_En;
  wire                                 Slot_4_Log_En;
  wire                                 Slot_5_Log_En;
  wire                                 Slot_6_Log_En;
  wire                                 Slot_7_Log_En;

  // Latency ID register connections

  wire [9:0]                           Lat_Addr_11downto2;
  wire [31:0]                          Metric_Ram_Data_In;
  wire                                 Lat_Sample_Reg;

   /*-------------Generate Monitor fifo data input -------------------*/

    assign SLOT_0_clk    = slot_0_axi_aclk;
    assign SLOT_0_Arst_n = slot_0_axi_aresetn;
    assign Slot_0_Data_In = {slot_0_axi_awid,slot_0_axi_awaddr,slot_0_axi_awlen,slot_0_axi_awsize,
                            slot_0_axi_awburst,slot_0_axi_awvalid,slot_0_axi_awready,
                            slot_0_axi_wstrb,slot_0_axi_wlast,slot_0_axi_wvalid,slot_0_axi_wready,
                            slot_0_axi_bid,slot_0_axi_bresp,slot_0_axi_bvalid,slot_0_axi_bready,
                            slot_0_axi_arid,slot_0_axi_araddr,slot_0_axi_arlen,slot_0_axi_arsize,
                            slot_0_axi_arburst,slot_0_axi_arvalid,slot_0_axi_arready,slot_0_axi_rid,
                            slot_0_axi_rresp,slot_0_axi_rlast,slot_0_axi_rvalid,slot_0_axi_rready};
    
    assign SLOT_1_clk    = slot_1_axi_aclk;
    assign SLOT_1_Arst_n = slot_1_axi_aresetn;
    assign Slot_1_Data_In = {slot_1_axi_awid,slot_1_axi_awaddr,slot_1_axi_awlen,slot_1_axi_awsize,
                            slot_1_axi_awburst,slot_1_axi_awvalid,slot_1_axi_awready,
                            slot_1_axi_wstrb,slot_1_axi_wlast,slot_1_axi_wvalid,slot_1_axi_wready,
                            slot_1_axi_bid,slot_1_axi_bresp,slot_1_axi_bvalid,slot_1_axi_bready,
                            slot_1_axi_arid,slot_1_axi_araddr,slot_1_axi_arlen,slot_1_axi_arsize,
                            slot_1_axi_arburst,slot_1_axi_arvalid,slot_1_axi_arready,slot_1_axi_rid,
                            slot_1_axi_rresp,slot_1_axi_rlast,slot_1_axi_rvalid,slot_1_axi_rready};

    assign SLOT_2_clk    = slot_2_axi_aclk;
    assign SLOT_2_Arst_n = slot_2_axi_aresetn;
    assign Slot_2_Data_In = {slot_2_axi_awid,slot_2_axi_awaddr,slot_2_axi_awlen,slot_2_axi_awsize,
                            slot_2_axi_awburst,slot_2_axi_awvalid,slot_2_axi_awready,
                            slot_2_axi_wstrb,slot_2_axi_wlast,slot_2_axi_wvalid,slot_2_axi_wready,
                            slot_2_axi_bid,slot_2_axi_bresp,slot_2_axi_bvalid,slot_2_axi_bready,
                            slot_2_axi_arid,slot_2_axi_araddr,slot_2_axi_arlen,slot_2_axi_arsize,
                            slot_2_axi_arburst,slot_2_axi_arvalid,slot_2_axi_arready,slot_2_axi_rid,
                            slot_2_axi_rresp,slot_2_axi_rlast,slot_2_axi_rvalid,slot_2_axi_rready};
    
    assign SLOT_3_clk    = slot_3_axi_aclk;
    assign SLOT_3_Arst_n = slot_3_axi_aresetn;
    assign Slot_3_Data_In = {slot_3_axi_awid,slot_3_axi_awaddr,slot_3_axi_awlen,slot_3_axi_awsize,
                            slot_3_axi_awburst,slot_3_axi_awvalid,slot_3_axi_awready,
                            slot_3_axi_wstrb,slot_3_axi_wlast,slot_3_axi_wvalid,slot_3_axi_wready,
                            slot_3_axi_bid,slot_3_axi_bresp,slot_3_axi_bvalid,slot_3_axi_bready,
                            slot_3_axi_arid,slot_3_axi_araddr,slot_3_axi_arlen,slot_3_axi_arsize,
                            slot_3_axi_arburst,slot_3_axi_arvalid,slot_3_axi_arready,slot_3_axi_rid,
                            slot_3_axi_rresp,slot_3_axi_rlast,slot_3_axi_rvalid,slot_3_axi_rready};

    assign SLOT_4_clk    = slot_4_axi_aclk;
    assign SLOT_4_Arst_n = slot_4_axi_aresetn;
    assign Slot_4_Data_In = {slot_4_axi_awid,slot_4_axi_awaddr,slot_4_axi_awlen,slot_4_axi_awsize,
                            slot_4_axi_awburst,slot_4_axi_awvalid,slot_4_axi_awready,
                            slot_4_axi_wstrb,slot_4_axi_wlast,slot_4_axi_wvalid,slot_4_axi_wready,
                            slot_4_axi_bid,slot_4_axi_bresp,slot_4_axi_bvalid,slot_4_axi_bready,
                            slot_4_axi_arid,slot_4_axi_araddr,slot_4_axi_arlen,slot_4_axi_arsize,
                            slot_4_axi_arburst,slot_4_axi_arvalid,slot_4_axi_arready,slot_4_axi_rid,
                            slot_4_axi_rresp,slot_4_axi_rlast,slot_4_axi_rvalid,slot_4_axi_rready};

    assign SLOT_5_clk    = slot_5_axi_aclk;
    assign SLOT_5_Arst_n = slot_5_axi_aresetn;
    assign Slot_5_Data_In = {slot_5_axi_awid,slot_5_axi_awaddr,slot_5_axi_awlen,slot_5_axi_awsize,
                            slot_5_axi_awburst,slot_5_axi_awvalid,slot_5_axi_awready,
                            slot_5_axi_wstrb,slot_5_axi_wlast,slot_5_axi_wvalid,slot_5_axi_wready,
                            slot_5_axi_bid,slot_5_axi_bresp,slot_5_axi_bvalid,slot_5_axi_bready,
                            slot_5_axi_arid,slot_5_axi_araddr,slot_5_axi_arlen,slot_5_axi_arsize,
                            slot_5_axi_arburst,slot_5_axi_arvalid,slot_5_axi_arready,slot_5_axi_rid,
                            slot_5_axi_rresp,slot_5_axi_rlast,slot_5_axi_rvalid,slot_5_axi_rready};

    assign SLOT_6_clk    = slot_6_axi_aclk;
    assign SLOT_6_Arst_n = slot_6_axi_aresetn;
    assign Slot_6_Data_In = {slot_6_axi_awid,slot_6_axi_awaddr,slot_6_axi_awlen,slot_6_axi_awsize,
                            slot_6_axi_awburst,slot_6_axi_awvalid,slot_6_axi_awready,
                            slot_6_axi_wstrb,slot_6_axi_wlast,slot_6_axi_wvalid,slot_6_axi_wready,
                            slot_6_axi_bid,slot_6_axi_bresp,slot_6_axi_bvalid,slot_6_axi_bready,
                            slot_6_axi_arid,slot_6_axi_araddr,slot_6_axi_arlen,slot_6_axi_arsize,
                            slot_6_axi_arburst,slot_6_axi_arvalid,slot_6_axi_arready,slot_6_axi_rid,
                            slot_6_axi_rresp,slot_6_axi_rlast,slot_6_axi_rvalid,slot_6_axi_rready};

    assign SLOT_7_clk    = slot_7_axi_aclk;
    assign SLOT_7_Arst_n = slot_7_axi_aresetn;
    assign Slot_7_Data_In = {slot_7_axi_awid,slot_7_axi_awaddr,slot_7_axi_awlen,slot_7_axi_awsize,
                            slot_7_axi_awburst,slot_7_axi_awvalid,slot_7_axi_awready,
                            slot_7_axi_wstrb,slot_7_axi_wlast,slot_7_axi_wvalid,slot_7_axi_wready,
                            slot_7_axi_bid,slot_7_axi_bresp,slot_7_axi_bvalid,slot_7_axi_bready,
                            slot_7_axi_arid,slot_7_axi_araddr,slot_7_axi_arlen,slot_7_axi_arsize,
                            slot_7_axi_arburst,slot_7_axi_arvalid,slot_7_axi_arready,slot_7_axi_rid,
                            slot_7_axi_rresp,slot_7_axi_rlast,slot_7_axi_rvalid,slot_7_axi_rready};


   wire Sample_En = capture_event | Sample_Interval_Cnt_Lapse | Lat_Sample_Reg;
   wire Sample_rst_n = (!reset_event) & (!Metrics_Cnt_Reset_sync);

   generate if(C_EN_SW_REG_WR_FLAG == 1) begin:GEN_SW_DATA_SYNC_EN
     assign SW_Data_Log_En = 1'b1;
   end
   else begin:GEN_NO_SW_DATA_SYNC_EN
     assign SW_Data_Log_En = 1'b0;
   end
   endgenerate

   /*----------------------------------------------------------------------
   ------------------- Submodule instantiations-----------------------------
   -----------------------------------------------------------------------*/ 

   // AXI Lite Interface module

   axi_perf_mon_v5_0_12_axi_interface
   #(
         .C_FAMILY                (C_FAMILY               ), 
         .C_S_AXI_PROTOCOL        (C_S_AXI_PROTOCOL       ),
         .C_S_AXI_ADDR_WIDTH      (C_S_AXI_ADDR_WIDTH     ),
         .C_S_AXI_DATA_WIDTH      (C_S_AXI_DATA_WIDTH     ),
         .C_S_AXI_ID_WIDTH        (C_S_AXI_ID_WIDTH       ),
         .C_SUPPORT_ID_REFLECTION (C_SUPPORT_ID_REFLECTION) 
     ) axi_interface_inst
     (
         .S_AXI_ACLK          (s_axi_aclk ),       
         .S_AXI_ARESETN       (s_axi_aresetn),
         .S_AXI_AWADDR        (s_axi_awaddr),
         .S_AXI_AWVALID       (s_axi_awvalid),
         .S_AXI_AWID          (s_axi_awid),
         .S_AXI_AWREADY       (s_axi_awready),
         .S_AXI_WDATA         (s_axi_wdata),
         .S_AXI_WSTRB         (s_axi_wstrb),
         .S_AXI_WVALID        (s_axi_wvalid), 
         .S_AXI_WREADY        (s_axi_wready), 
         .S_AXI_BRESP         (s_axi_bresp),
         .S_AXI_BVALID        (s_axi_bvalid),
         .S_AXI_BID           (s_axi_bid),
         .S_AXI_BREADY        (s_axi_bready), 
         .S_AXI_ARADDR        (s_axi_araddr),
         .S_AXI_ARVALID       (s_axi_arvalid),
         .S_AXI_ARID          (s_axi_arid),
         .S_AXI_ARREADY       (s_axi_arready), 
         .S_AXI_RDATA         (s_axi_rdata  ), 
         .S_AXI_RRESP         (s_axi_rresp  ),
         .S_AXI_RVALID        (s_axi_rvalid ),
         .S_AXI_RID           (s_axi_rid),
         .S_AXI_RREADY        (s_axi_rready ),
         .Bus2IP_Addr         (Bus2IP_Addr  ),
         .Bus2IP_Data         (Bus2IP_Data  ),
         .Bus2IP_BE           (Bus2IP_BE    ),
         .Bus2IP_Burst        (Bus2IP_Burst ), 
         .Bus2IP_RdCE         (Bus2IP_RdCE  ), 
         .Bus2IP_WrCE         (Bus2IP_WrCE  ),
         .IP2Bus_Data         (IP2Bus_Data  ), 
         .IP2Bus_DataValid    (IP2Bus_DataValid),
         .IP2Bus_Error        (IP2Bus_Error )
      );
  generate if (C_LOG_DATA_OFFLD == 0 ) begin : LOG_DATA_OFFLOAD_STREAM
    assign eventlog_rd_clk = m_axis_aclk;
    assign eventlog_rd_rstn = m_axis_aresetn;
  end
  endgenerate
  generate if (C_LOG_DATA_OFFLD == 1 ) begin : LOG_DATA_OFFLOAD_MEMORY
    assign eventlog_rd_clk = s_axi_offld_aclk;
    assign eventlog_rd_rstn = s_axi_offld_aresetn;
  end
  endgenerate

  // Register module instance
   axi_perf_mon_v5_0_12_register_module_profile
   #(
         .C_FAMILY                    (C_FAMILY),
         .C_S_AXI_ADDR_WIDTH          (C_S_AXI_ADDR_WIDTH),
         .C_S_AXI_DATA_WIDTH          (C_S_AXI_DATA_WIDTH),
         .C_NUM_MONITOR_SLOTS         (C_NUM_MONITOR_SLOTS), 
         .C_NUM_OF_COUNTERS           (C_NUM_OF_COUNTERS), 
         .C_NUM_INTR_INPUTS           (C_NUM_INTR_INPUTS),
         .C_ENABLE_PROFILE            (C_ENABLE_PROFILE),
         .C_ENABLE_TRACE              (C_ENABLE_TRACE),
         .C_METRICS_SAMPLE_COUNT_WIDTH(C_METRICS_SAMPLE_COUNT_WIDTH),
         .C_SW_SYNC_DATA_WIDTH        (C_SW_SYNC_DATA_WIDTH),
         .C_EN_ALL_TRACE              (C_EN_ALL_TRACE), 
         .C_AXIS_DWIDTH_ROUND_TO_32   (C_AXIS_DWIDTH_ROUND_TO_32),
         .C_AXI4LITE_CORE_CLK_ASYNC   (C_AXI4LITE_CORE_CLK_ASYNC)
    ) register_module_inst
    (
         .S_AXI_ACLK           (s_axi_aclk),
         .S_AXI_ARESETN        (s_axi_aresetn),
         .Bus2IP_Addr          (Bus2IP_Addr),
         .Bus2IP_Data          (Bus2IP_Data),
         .Bus2IP_BE            (Bus2IP_BE),
         .Bus2IP_Burst         (Bus2IP_Burst),
         .Bus2IP_RdCE          (Bus2IP_RdCE)  ,
         .Bus2IP_WrCE          (Bus2IP_WrCE),
         .IP2Bus_Data          (IP2Bus_Data) ,
         .IP2Bus_DataValid     (IP2Bus_DataValid),
         .IP2Bus_Error         (IP2Bus_Error),
         .CORE_ACLK            (core_aclk   ),
         .CORE_ARESETN         (core_aresetn ),
         .Metric_Ram_Data_In   (Metric_Ram_Data_In),
         .Sample_Interval      (Sample_Interval  ),
         .Interval_Cnt_En      (Interval_Cnt_En  ),
         .Interval_Cnt_Ld      (Interval_Cnt_Ld  ),
         .Reset_On_Sample_Int_Lapse(Reset_On_Sample_Int_Lapse),
         .Global_Intr_En       (Global_Intr_En   ),
         .Intr_Reg_IER_Wr_En   (Intr_Reg_IER_Wr_En ),
         .Intr_Reg_ISR_Wr_En   (Intr_Reg_ISR_Wr_En ),
         .Intr_Reg_IER         (Intr_Reg_IER     ),
         .Intr_Reg_ISR         (Intr_Reg_ISR     ),
         .eventlog_rd_clk      (eventlog_rd_clk  ),
         .eventlog_rd_rstn     (eventlog_rd_rstn ),
         .eventlog_cur_cnt     (eventlog_cur_cnt ),
         .SW_Data              (SW_Data          ),
         .SW_Data_Wr_En        (SW_Data_Wr_En    ),
         .Streaming_FIFO_Reset (Streaming_FIFO_Reset),
         .Event_Log_En         (Event_Log_En     ),
         .Metrics_Cnt_En       (Metrics_Cnt_En   ),
         .Metrics_Cnt_Reset    (Metrics_Cnt_Reset),
         .Use_Ext_Trigger      (Use_Ext_Trig     ),
         .Use_Ext_Trigger_Log  (Use_Ext_Trig_Log ),
         .Lat_Sample_Reg       (Lat_Sample_Reg),
         .Wr_Lat_Start         (Wr_Lat_Start), //0 Address Issue 1 Address acceptance
         .Wr_Lat_End           (Wr_Lat_End), //1 First write   0 Last write  
         .Rd_Lat_Start         (Rd_Lat_Start), //0 Address Issue 1 Address acceptance 
         .Rd_Lat_End           (Rd_Lat_End),  //1 First Read    0 Last Read
         .Trace_ctrl_reg       (Trace_ctrl_reg),
         .Lat_Addr_11downto2   (Lat_Addr_11downto2)
       );

   
    assign Intr_In = { Streaming_Fifo_Full_Edge, Sample_Interval_Cnt_Lapse};

    // synchronizing the inputs to interrupt module
    generate
    if((C_AXI4LITE_CORE_CLK_ASYNC == 1)) begin :GEN_INTR_ASYNC
        axi_perf_mon_v5_0_12_intr_sync
           #(
                 .C_FAMILY            (C_FAMILY),
                 .C_DWIDTH            (C_NUM_INTR_INPUTS) 
            ) intr_sync_module_inst
            (
                 .clk_1               (core_aclk),
                 .rst_1_n             (core_aresetn), 
                 .DATA_IN             (Intr_In),
                 .clk_2               (s_axi_aclk),
                 .rst_2_n             (s_axi_aresetn), 
                 .SYNC_DATA_OUT       (Intr_In_sync)
            );
    end
    else begin :GEN_INTR_SYNC
        assign Intr_In_sync = Intr_In;
    end
    endgenerate
       

    // Interrupt Module instance

    wire [C_NUM_INTR_INPUTS-1:0] Wr_Data = Bus2IP_Data[C_NUM_INTR_INPUTS:1];

    axi_perf_mon_v5_0_12_interrupt_module 
    #(
         .C_FAMILY             (C_FAMILY         ),
         .C_NUM_INTR_INPUTS    (C_NUM_INTR_INPUTS)
     ) interrupt_module_inst
     (
         .clk                  (s_axi_aclk        ),
         .rst_n                (s_axi_aresetn     ),
         .Intr                 (Intr_In_sync      ),
         .Interrupt_Enable     (Global_Intr_En    ),
         .IER_Wr_En            (Intr_Reg_IER_Wr_En),                
         .ISR_Wr_En            (Intr_Reg_ISR_Wr_En),
         .Wr_Data              (Wr_Data           ),
         .IER                  (Intr_Reg_IER      ), 
         .ISR                  (Intr_Reg_ISR      ), 
         .Interrupt            (interrupt         )
      );

    //assigning global clock count enable ane reset signals to bus

    //-- Control Bits
    wire [5:0] Control_Bits = {Use_Ext_Trig_Log,Use_Ext_Trig, 
                               Streaming_FIFO_Reset,
                               Event_Log_En,
                               Metrics_Cnt_Reset, Metrics_Cnt_En };
 
    generate    
    if (C_AXI4LITE_CORE_CLK_ASYNC == 1) begin : GEN_CONTROL_SYNC
        //-- Synchronizing Control bits to core clk  
        //-- Double Flop synchronization
        axi_perf_mon_v5_0_12_cdc_sync
        #(
           .c_cdc_type      (1             ),   
           .c_flop_input    (0             ),  
           .c_reset_state   (1             ),  
           .c_single_bit    (0             ),  
           .c_vector_width  (6             ),  
           .c_mtbf_stages   (4             )  
         )control_sig_cdc_sync 
         (
           .prmry_aclk      (s_axi_aclk          ),
           .prmry_rst_n     (s_axi_aresetn       ),
           .prmry_in        (1'b0                ),
           .prmry_vect_in   (Control_Bits        ),
           .scndry_aclk     (core_aclk           ),
           .scndry_rst_n    (core_aresetn        ),
           .prmry_ack       (                    ),
           .scndry_out      (                    ),
           .scndry_vect_out (Control_Bits_sync   ) 
          );

        assign Metrics_Cnt_En_sync           = Control_Bits_sync[0];
        assign Metrics_Cnt_Reset_sync        = Control_Bits_sync[1];
        assign Event_Log_En_sync             = Control_Bits_sync[2]; 
        assign Streaming_FIFO_Reset_sync     = Control_Bits_sync[3];
        assign Use_Ext_Trig_sync             = Control_Bits_sync[4];
        assign Use_Ext_Trig_Log_sync         = Control_Bits_sync[5];

    end 
    else begin : GEN_CONTROL_NO_SYNC
        assign Metrics_Cnt_En_sync           = Control_Bits[0];
        assign Metrics_Cnt_Reset_sync        = Control_Bits[1];
        assign Event_Log_En_sync             = Control_Bits[2];
        assign Streaming_FIFO_Reset_sync     = Control_Bits[3];
        assign Use_Ext_Trig_sync             = Control_Bits[4];
        assign Use_Ext_Trig_Log_sync         = Control_Bits[5];
    end 
    endgenerate 
   wire trigger_in_sync;

   reg 	trigger_in_ack_r;

   wire 	trigger_in_d4;

//synchoronize the input trigger_in signal with level shifter
        axi_perf_mon_v5_0_12_cdc_sync
        #(
           .c_cdc_type      (1             ),   
           .c_flop_input    (0             ),  
           .c_reset_state   (1             ),  
           .c_single_bit    (1             ),  
           .c_vector_width  (1             ),  
           .c_mtbf_stages   (4             )  
         ) trigger_sig_cdc_sync 
         (
           .prmry_aclk      (1'b1                ),
           .prmry_rst_n     (1'b1                ),
           .prmry_in        (trigger_in          ),
           .prmry_vect_in   (1'b0                ),
           .scndry_aclk     (core_aclk           ),
           .scndry_rst_n    (core_aresetn        ),
           .prmry_ack       (                    ),
           .scndry_out      (trigger_in_d4       ),
           .scndry_vect_out (                    ) 
          );
// always @ (posedge core_aclk ) begin
//     if (core_aresetn == RST_ACTIVE)
//       begin
//	  trigger_in_d1 <=0;
//	  trigger_in_d2<=0;
//	  trigger_in_d3<=0;
//	  trigger_in_d4<=0;
//       end
//     else
//       begin
//	  trigger_in_d1 <= trigger_in;
//	  trigger_in_d2 <= trigger_in_d1;
//	  trigger_in_d3 <= trigger_in_d2;
//	  trigger_in_d4 <= trigger_in_d3;
//       end
//   end
   
   assign trigger_in_sync = trigger_in_d4;

 
//generate trigger_ack hand-shaking signal
  always @(posedge core_aclk) begin
      if (core_aresetn == RST_ACTIVE)
      	trigger_in_ack_r <=0;
      else begin
      	if (trigger_in_sync)
	         trigger_in_ack_r <= 1'b1;
      	else
	         trigger_in_ack_r <=1'b0;
    end
  end
   assign trigger_in_ack = trigger_in_ack_r;

//generate trigger signal for the controlling of internal components. Also use Metric_Cnt_En_sync signal as enable signal and Metrics_Cnt_Reset_sync as reset signal
   
   reg trigger,trigger1;
   always @ (posedge core_aclk) begin
			   
       if (core_aresetn == RST_ACTIVE) begin
	     trigger1 <=0;
	     trigger <=0;
       end else begin
	    trigger <= trigger1;
       if (trigger_in_sync && Metrics_Cnt_En_sync && !Metrics_Cnt_Reset_sync)
	     trigger1 <=1'b1;
    	 else if (!trigger_in_sync && Metrics_Cnt_En_sync && !Metrics_Cnt_Reset_sync)
	     trigger1 <= trigger1;
       else
	    trigger1 <=0;
   end	
end   

     //-- Slot 0
     // Monitor FIFO instantiations
     axi_perf_mon_v5_0_12_mon_fifo
     #(
       .C_FAMILY                  (C_FAMILY),
       .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),  
       .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S0),
       .C_FIFO_ENABLE             (C_SLOT_0_FIFO_ENABLE) 
      ) mon_fifo_inst_0
      (
       .Mon_clk                   (SLOT_0_clk),
       .Mon_rst_n                 (SLOT_0_Arst_n),
       .Data_In                   (Slot_0_Data_In),
       //.mon_en                    (Metrics_Cnt_En_sync),
       .CORE_ACLK                 (core_aclk),
       .CORE_ARESETN              (core_aresetn),
       .Sync_Data_Out             (Slot_0_Sync_Data_Out),
       .Sync_Data_Valid           (Slot_0_Sync_Data_Valid)
      );
///kartheek
      wire [2:0] Ext_Event0_Data_In; //= {ext_event_0_cnt_start,ext_event_0_cnt_stop,ext_event_0};
      wire [2:0] Ext_Event0_Sync_Data_Out;
      wire       Ext_Event0_Sync_Data_Valid;
     generate if(C_EN_AXI_DEBUG == 0 && C_EN_EXT_EVENTS_FLAG == 1 && C_ENABLE_TRACE == 1) begin:GEN_SLOT0_EXT_TRACE

      assign Ext_Event0_Data_In = {ext_event_0_cnt_start,ext_event_0_cnt_stop,ext_event_0};
      // wire [2:0] Ext_Event0_Sync_Data_Out;
      // wire       Ext_Event0_Sync_Data_Valid;
       
       // External Event0 through monitor FIFO
       axi_perf_mon_v5_0_12_mon_fifo
           #(
             .C_FAMILY                  (C_FAMILY),
             .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
             .C_MON_FIFO_DATA_WIDTH     (3),
             .C_FIFO_ENABLE             (C_EXT_EVENT0_FIFO_ENABLE) 
            ) mon_fifo_ext_event0_inst
            (
             .Mon_clk                   (ext_clk_0),
             .Mon_rst_n                 (ext_rstn_0),
             .Data_In                   (Ext_Event0_Data_In),
             //.mon_en                    (Metrics_Cnt_En_sync),
             .CORE_ACLK                 (core_aclk),
             .CORE_ARESETN              (core_aresetn),
             .Sync_Data_Out             (Ext_Event0_Sync_Data_Out),
             .Sync_Data_Valid           (Ext_Event0_Sync_Data_Valid)
            );
       end
       else begin
          assign Ext_Event0_Sync_Data_Out = 0;
          assign Ext_Event0_Sync_Data_Valid = 0;
       end
endgenerate

//kartheek
     generate if(C_ENABLE_TRACE == 1) begin:GEN_SLOT0_TRACE

      //wire [2:0] Ext_Event0_Data_In = {ext_event_0_cnt_start,ext_event_0_cnt_stop,ext_event_0};
      // wire [2:0] Ext_Event0_Sync_Data_Out;
      // wire       Ext_Event0_Sync_Data_Valid;
              //Flag Generator instantiation for slot0
       axi_perf_mon_v5_0_12_flags_gen_trace
       #(
         .C_FAMILY                  (C_FAMILY),
         .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S0), 
         .C_LOG_WIDTH               (C_SLOT_0_LOG_WIDTH),
         .C_FLAG_WIDTH              (C_SLOT_N_FLAG_WIDTH), 
         .C_AXI_ADDR_WIDTH          (C_SLOT_0_AXI_ADDR_WIDTH), 
         .C_AXI_DATA_WIDTH          (C_SLOT_0_AXI_DATA_WIDTH), 
         .C_AXI_ID_WIDTH            (C_SLOT_0_AXI_ID_WIDTH), 
         .C_AXI_PROTOCOL            (C_SLOT_0_AXI_PROTOCOL), 
         .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
         .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
         .C_EN_WR_ADD_FLAG          (C_EN_WR_ADD_FLAG), 
         .C_EN_FIRST_WRITE_FLAG     (C_EN_FIRST_WRITE_FLAG), 
         .C_EN_LAST_WRITE_FLAG      (C_EN_LAST_WRITE_FLAG), 
         .C_EN_RESPONSE_FLAG        (C_EN_RESPONSE_FLAG), 
         .C_EN_RD_ADD_FLAG          (C_EN_RD_ADD_FLAG), 
         .C_EN_FIRST_READ_FLAG      (C_EN_FIRST_READ_FLAG), 
         .C_EN_LAST_READ_FLAG       (C_EN_LAST_READ_FLAG), 
         .C_EN_EXT_EVENTS_FLAG      (C_EN_EXT_EVENTS_FLAG), 
         .C_EN_ALL_TRACE            (C_EN_ALL_TRACE), 
         .C_EN_AXI_DEBUG            (C_EN_AXI_DEBUG) 
        ) flags_generator_inst_0
        (
         .clk                       (core_aclk),
         .rst_n                     (core_aresetn),
         .Data_In                   (Slot_0_Sync_Data_Out),
         .Data_Valid                (Slot_0_Sync_Data_Valid), 
         .Ext_Trig                  (slot_0_ext_trig),
         .Ext_Trig_Stop             (slot_0_ext_trig_stop),
         .Use_Ext_Trig_Log          (Use_Ext_Trig_Log_sync),                 
         .Log_Data                  (Slot_0_Log),
         .Log_En                    (Slot_0_Log_En),
         .Ext_Data_in               (Ext_Event0_Sync_Data_Out),
         .Ext_Data_Valid            (Ext_Event0_Sync_Data_Valid),
         .Trace_Ctrl_bits           (Trace_ctrl_reg[3:0]),
         .Ext_Event_Flags           (Ext_Event0_Flags)
        );
        
     end
      else begin:GEN_SLOT0_NO_TRACE
        assign Slot_0_Log = 0;
        assign Slot_0_Log_En = 1'b0;
        assign Slot_0_Log_Marked = 0;
        assign Slot_0_Log_En_Marked = 1'b0;
        assign Ext_Event0_Flags = 0;
      end
      endgenerate

      generate if(C_ENABLE_TRACE == 1 && C_EN_TRIGGER == 1) begin : GEN_POST_TRIGGER
//Aligning start and end events of transactions
       axi_perf_mon_v5_0_12_postTriggerMarker 
	    #(
			   // Parameters
			.C_FAMILY                  (C_FAMILY),
         .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S0), 
         .C_LOG_WIDTH               (C_SLOT_0_LOG_WIDTH),
         .C_FLAG_WIDTH              (C_SLOT_N_FLAG_WIDTH), 
         .C_AXI_ADDR_WIDTH          (C_SLOT_0_AXI_ADDR_WIDTH), 
         .C_AXI_DATA_WIDTH          (C_SLOT_0_AXI_DATA_WIDTH), 
         .C_AXI_ID_WIDTH            (C_SLOT_0_AXI_ID_WIDTH), 
         .C_AXI_PROTOCOL            (C_SLOT_0_AXI_PROTOCOL), 
         .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
         .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
         .C_EN_WR_ADD_FLAG          (C_EN_WR_ADD_FLAG), 
         .C_EN_FIRST_WRITE_FLAG     (C_EN_FIRST_WRITE_FLAG), 
         .C_EN_LAST_WRITE_FLAG      (C_EN_LAST_WRITE_FLAG), 
         .C_EN_RESPONSE_FLAG        (C_EN_RESPONSE_FLAG), 
         .C_EN_RD_ADD_FLAG          (C_EN_RD_ADD_FLAG), 
         .C_EN_FIRST_READ_FLAG      (C_EN_FIRST_READ_FLAG), 
         .C_EN_LAST_READ_FLAG       (C_EN_LAST_READ_FLAG), 
         .C_EN_EXT_EVENTS_FLAG      (C_EN_EXT_EVENTS_FLAG)
	   )
		triggerMarker_slot0 (
			    // Outputs
			    .Log_Data_Marked	(Slot_0_Log_Marked),
			    .Log_en_out		(Slot_0_Log_En_Marked),
			    // Inputs
			    .clk		  (core_aclk),
			    .rst_n	  (stream_fifo_rst_n),
			    .trigger  (trigger),
			    .reStart  (Metrics_Cnt_Reset_sync),
			    .Log_Data (Slot_0_Log),
			    .Log_En	  (Slot_0_Log_En)
			    );

     end
      else if(C_ENABLE_TRACE == 1 && C_EN_TRIGGER == 0) begin :GEN_NO_POST_TRIGGER
      assign Slot_0_Log_Marked = Slot_0_Log;
      assign Slot_0_Log_En_Marked = Slot_0_Log_En;
      end
      endgenerate


     generate
     if(C_ENABLE_PROFILE ==  1) begin :GEN_SLOT0_PROFILE 

     // Metric calculator instance for slot0
     axi_perf_mon_v5_0_12_metric_calc_profile 
    #(
      .C_AXIID                   (C_SLOT_0_AXI_ID_WIDTH    ),
      .C_AXIADDR                 (C_SLOT_0_AXI_ADDR_WIDTH  ),
      .C_AXIDATA                 (C_SLOT_0_AXI_DATA_WIDTH  ),
      .C_AXI_SUB_PROTOCOL        (C_SLOT_0_AXI_SUB_PROTOCOL),
      .C_OUTSTAND_DEPTH          (C_MAX_OUTSTAND_DEPTH),
      .C_METRIC_COUNT_WIDTH      (C_METRIC_COUNT_WIDTH),
      .C_MON_FIFO_WIDTH          (C_MON_FIFO_DWIDTH_S0)
     ) metric_calc_inst0
     (
      .clk                       (core_aclk ),
      .rst_n                     (core_aresetn),
      .Data_In                   (Slot_0_Sync_Data_Out),
      .Data_Valid                (Slot_0_Sync_Data_Valid), 
      .Metrics_Cnt_En            (Metrics_Cnt_En_sync),
      .Metrics_Cnt_Reset         (Metrics_Cnt_Reset_sync),
      .Use_Ext_Trig              (Use_Ext_Trig_sync),
      .Ext_Trig                  (slot_0_ext_trig),
      .Ext_Trig_Stop             (slot_0_ext_trig_stop),
      .Wr_Lat_Start              (Wr_Lat_Start    ),  //0 Address Issue 1 Address acceptance
      .Wr_Lat_End                (Wr_Lat_End      ),  //1 First write   0 Last write  
      .Rd_Lat_Start              (Rd_Lat_Start    ),  //0 Address Issue 1 Address acceptance 
      .Rd_Lat_End                (Rd_Lat_End      ),  //1 First Read    0 Last Read
      .Wtrans_Cnt_En             (Wtrans_Cnt_En[0]),
      .Rtrans_Cnt_En             (Rtrans_Cnt_En[0]),
      .Write_Byte_Cnt            (S0_Write_Byte_Cnt),
      .Read_Byte_Cnt             (S0_Read_Byte_Cnt),
      .Read_Byte_Cnt_En          (S0_Read_Byte_Cnt_En),
      .Write_Beat_Cnt_En         (Write_Beat_Cnt_En[0]),
      .Read_Beat_Cnt_En          (Read_Beat_Cnt_En[0]),
      .Read_Latency              (S0_Read_Latency),
      .Write_Latency             (S0_Write_Latency),
      .Read_Latency_En           (Read_Latency_En[0]),    
      .Write_Latency_En          (Write_Latency_En[0]),   
      .Max_Write_Latency         (S0_Max_Write_Latency),                   
      .Min_Write_Latency         (S0_Min_Write_Latency),                   
      .Max_Read_Latency          (S0_Max_Read_Latency),                   
      .Min_Read_Latency          (S0_Min_Read_Latency)                   
    );

    end
    else begin: GEN_SLOT0_NO_PROFILE
         assign S0_Write_Byte_Cnt    = 0;
         assign S0_Read_Byte_Cnt     = 0;
         assign S0_Read_Byte_Cnt_En  = 0;
         assign S0_Read_Latency      = 0;
         assign S0_Write_Latency     = 0;
    end
    endgenerate

     //-- Slot 1
     generate
     if(C_NUM_MONITOR_SLOTS > 1) begin :GEN_SLOT1_MON_FIFO 

          axi_perf_mon_v5_0_12_mon_fifo
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
           .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S1),
           .C_FIFO_ENABLE             (C_SLOT_1_FIFO_ENABLE) 
          ) mon_fifo_inst_1
          (
           .Mon_clk                   (SLOT_1_clk),
           .Mon_rst_n                 (SLOT_1_Arst_n),
           .Data_In                   (Slot_1_Data_In),
           //.mon_en                    (Metrics_Cnt_En_sync),
           .CORE_ACLK                 (core_aclk),
           .CORE_ARESETN              (core_aresetn),
           .Sync_Data_Out             (Slot_1_Sync_Data_Out),
           .Sync_Data_Valid           (Slot_1_Sync_Data_Valid)
          );
      end
      else begin:GEN_SLOT1_NO_MON_FIFO
         assign Slot_1_Sync_Data_Out = 0;
      end
      endgenerate

     generate
     if(C_NUM_MONITOR_SLOTS > 1 && C_ENABLE_PROFILE ==  1) begin :GEN_SLOT1 

          // Metric calculator instance for slot1
          axi_perf_mon_v5_0_12_metric_calc_profile 
          #(
            .C_AXIID                   (C_SLOT_1_AXI_ID_WIDTH    ),
            .C_AXIADDR                 (C_SLOT_1_AXI_ADDR_WIDTH  ),
            .C_AXIDATA                 (C_SLOT_1_AXI_DATA_WIDTH  ),
            .C_AXI_SUB_PROTOCOL        (C_SLOT_1_AXI_SUB_PROTOCOL),
            .C_OUTSTAND_DEPTH          (C_MAX_OUTSTAND_DEPTH),
            .C_METRIC_COUNT_WIDTH      (C_METRIC_COUNT_WIDTH),
            .C_MON_FIFO_WIDTH          (C_MON_FIFO_DWIDTH_S1)
          ) metric_calc_inst1
          (
            .clk                       (core_aclk ),
            .rst_n                     (core_aresetn),
            .Data_In                   (Slot_1_Sync_Data_Out),
            .Data_Valid                (Slot_1_Sync_Data_Valid), 
            .Metrics_Cnt_En            (Metrics_Cnt_En_sync),
            .Metrics_Cnt_Reset         (Metrics_Cnt_Reset_sync),
            .Use_Ext_Trig              (Use_Ext_Trig_sync),
            .Ext_Trig                  (slot_1_ext_trig),
            .Ext_Trig_Stop             (slot_1_ext_trig_stop),
            .Wr_Lat_Start              (Wr_Lat_Start    ),  //0 Address Issue 1 Address acceptance
            .Wr_Lat_End                (Wr_Lat_End      ),  //1 First write   0 Last write  
            .Rd_Lat_Start              (Rd_Lat_Start    ),  //0 Address Issue 1 Address acceptance 
            .Rd_Lat_End                (Rd_Lat_End      ),  //1 First Read    0 Last Read
            .Wtrans_Cnt_En             (Wtrans_Cnt_En[1]),
            .Rtrans_Cnt_En             (Rtrans_Cnt_En[1]),
            .Write_Byte_Cnt            (S1_Write_Byte_Cnt),
            .Read_Byte_Cnt             (S1_Read_Byte_Cnt),
            .Read_Byte_Cnt_En          (S1_Read_Byte_Cnt_En),
            .Write_Beat_Cnt_En         (Write_Beat_Cnt_En[1]),
            .Read_Beat_Cnt_En          (Read_Beat_Cnt_En[1]),
            .Read_Latency              (S1_Read_Latency),
            .Write_Latency             (S1_Write_Latency),
            .Read_Latency_En           (Read_Latency_En[1]),    
            .Write_Latency_En          (Write_Latency_En[1])   ,
            .Max_Write_Latency         (S1_Max_Write_Latency),                   
            .Min_Write_Latency         (S1_Min_Write_Latency),                   
            .Max_Read_Latency          (S1_Max_Read_Latency),                   
            .Min_Read_Latency          (S1_Min_Read_Latency)                   
          );
     end
     else begin :GEN_NO_SLOT1
         assign S1_Write_Byte_Cnt    = 0;
         assign S1_Read_Byte_Cnt     = 0;
         assign S1_Read_Byte_Cnt_En  = 0;
         assign S1_Read_Latency      = 0;
         assign S1_Write_Latency     = 0;
     end
     endgenerate 
       wire [2:0] Ext_Event1_Data_In;
       wire [2:0] Ext_Event1_Sync_Data_Out;
       wire       Ext_Event1_Sync_Data_Valid;
      generate if (C_NUM_MONITOR_SLOTS > 1 && C_ENABLE_TRACE == 1 && C_EN_AXI_DEBUG == 0 && C_EN_EXT_EVENTS_FLAG == 1) begin:GEN_SLOT1_EXT_TRACE
      assign Ext_Event1_Data_In = {ext_event_1_cnt_start,ext_event_1_cnt_stop,ext_event_1};
      // External Event1 through monitor FIFO
       axi_perf_mon_v5_0_12_mon_fifo
           #(
             .C_FAMILY                  (C_FAMILY),
             .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
             .C_MON_FIFO_DATA_WIDTH     (3),
             .C_FIFO_ENABLE             (C_EXT_EVENT1_FIFO_ENABLE) 
            ) mon_fifo_ext_event1_inst
            (
             .Mon_clk                   (ext_clk_1),
             .Mon_rst_n                 (ext_rstn_1),
             .Data_In                   (Ext_Event1_Data_In),
             //.mon_en                    (Metrics_Cnt_En_sync),
             .CORE_ACLK                 (core_aclk),
             .CORE_ARESETN              (core_aresetn),
             .Sync_Data_Out             (Ext_Event1_Sync_Data_Out),
             .Sync_Data_Valid           (Ext_Event1_Sync_Data_Valid)
            );
    end
    else begin
          assign Ext_Event1_Sync_Data_Out = 0;
          assign Ext_Event1_Sync_Data_Valid = 0;

    end
endgenerate
     generate if(C_NUM_MONITOR_SLOTS > 1 && C_ENABLE_TRACE == 1) begin:GEN_SLOT1_TRACE

      //Flag Generator instantiation for slot1
       axi_perf_mon_v5_0_12_flags_gen_trace
       #(
         .C_FAMILY                  (C_FAMILY),
         .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S1), 
         .C_LOG_WIDTH               (C_SLOT_1_LOG_WIDTH),
         .C_FLAG_WIDTH              (C_SLOT_N_FLAG_WIDTH), 
         .C_AXI_ADDR_WIDTH          (C_SLOT_1_AXI_ADDR_WIDTH), 
         .C_AXI_DATA_WIDTH          (C_SLOT_1_AXI_DATA_WIDTH), 
         .C_AXI_ID_WIDTH            (C_SLOT_1_AXI_ID_WIDTH), 
         .C_AXI_PROTOCOL            (C_SLOT_1_AXI_PROTOCOL), 
         .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
         .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
         .C_EN_WR_ADD_FLAG          (C_EN_WR_ADD_FLAG), 
         .C_EN_FIRST_WRITE_FLAG     (C_EN_FIRST_WRITE_FLAG), 
         .C_EN_LAST_WRITE_FLAG      (C_EN_LAST_WRITE_FLAG), 
         .C_EN_RESPONSE_FLAG        (C_EN_RESPONSE_FLAG), 
         .C_EN_RD_ADD_FLAG          (C_EN_RD_ADD_FLAG), 
         .C_EN_FIRST_READ_FLAG      (C_EN_FIRST_READ_FLAG), 
         .C_EN_LAST_READ_FLAG       (C_EN_LAST_READ_FLAG), 
         .C_EN_EXT_EVENTS_FLAG      (C_EN_EXT_EVENTS_FLAG), 
         .C_EN_ALL_TRACE            (C_EN_ALL_TRACE), 
         .C_EN_AXI_DEBUG            (C_EN_AXI_DEBUG) 
        ) flags_generator_inst_1
        (
         .clk                       (core_aclk),
         .rst_n                     (core_aresetn),
         .Data_In                   (Slot_1_Sync_Data_Out),
         .Data_Valid                (Slot_1_Sync_Data_Valid), 
         .Ext_Trig                  (slot_1_ext_trig),
         .Ext_Trig_Stop             (slot_1_ext_trig_stop),
         .Use_Ext_Trig_Log          (Use_Ext_Trig_Log_sync),                 
         .Log_Data                  (Slot_1_Log),
         .Log_En                    (Slot_1_Log_En),
         .Ext_Data_in               (Ext_Event1_Sync_Data_Out),
         .Ext_Data_Valid            (Ext_Event1_Sync_Data_Valid),
         .Trace_Ctrl_bits           (Trace_ctrl_reg[7:4]),
         .Ext_Event_Flags           (Ext_Event1_Flags)
        );

      end
      else begin:GEN_SLOT1_NO_TRACE
        assign Slot_1_Log = 0;
        assign Slot_1_Log_En = 1'b0;
        assign Slot_1_Log_Marked = 0;
        assign Slot_1_Log_En_Marked = 1'b0;
        assign Ext_Event1_Flags = 0;
      end
      endgenerate
 generate if(C_NUM_MONITOR_SLOTS > 1 && C_ENABLE_TRACE == 1 && C_EN_TRIGGER == 1) begin : GEN_S1_POST_TRIGGER
//Aligning start and end events of transactions
       axi_perf_mon_v5_0_12_postTriggerMarker 
	    #(
			   // Parameters
			.C_FAMILY                  (C_FAMILY),
         .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S1), 
         .C_LOG_WIDTH               (C_SLOT_1_LOG_WIDTH),
         .C_FLAG_WIDTH              (C_SLOT_N_FLAG_WIDTH), 
         .C_AXI_ADDR_WIDTH          (C_SLOT_1_AXI_ADDR_WIDTH), 
         .C_AXI_DATA_WIDTH          (C_SLOT_1_AXI_DATA_WIDTH), 
         .C_AXI_ID_WIDTH            (C_SLOT_1_AXI_ID_WIDTH), 
         .C_AXI_PROTOCOL            (C_SLOT_1_AXI_PROTOCOL), 
         .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
         .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
         .C_EN_WR_ADD_FLAG          (C_EN_WR_ADD_FLAG), 
         .C_EN_FIRST_WRITE_FLAG     (C_EN_FIRST_WRITE_FLAG), 
         .C_EN_LAST_WRITE_FLAG      (C_EN_LAST_WRITE_FLAG), 
         .C_EN_RESPONSE_FLAG        (C_EN_RESPONSE_FLAG), 
         .C_EN_RD_ADD_FLAG          (C_EN_RD_ADD_FLAG), 
         .C_EN_FIRST_READ_FLAG      (C_EN_FIRST_READ_FLAG), 
         .C_EN_LAST_READ_FLAG       (C_EN_LAST_READ_FLAG), 
         .C_EN_EXT_EVENTS_FLAG      (C_EN_EXT_EVENTS_FLAG)
	   )
		triggerMarker_slot1 (
			    // Outputs
			    .Log_Data_Marked	(Slot_1_Log_Marked),
			    .Log_en_out		(Slot_1_Log_En_Marked),
			    // Inputs
			    .clk		  (core_aclk),
			    .rst_n	  (stream_fifo_rst_n),
			    .trigger  (trigger),
			    .reStart  (Metrics_Cnt_Reset_sync),
			    .Log_Data (Slot_1_Log),
			    .Log_En	  (Slot_1_Log_En)
			    );

     end
      else if(C_NUM_MONITOR_SLOTS > 1 && C_ENABLE_TRACE == 1 && C_EN_TRIGGER == 0) begin :GEN_S1_NO_POST_TRIGGER
      assign Slot_1_Log_Marked = Slot_1_Log;
      assign Slot_1_Log_En_Marked = Slot_1_Log_En;
      end
      endgenerate

     //-- Slot 2
     generate
     if(C_NUM_MONITOR_SLOTS > 2) begin :GEN_SLOT2_MON_FIFO
        axi_perf_mon_v5_0_12_mon_fifo
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
           .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S2),
           .C_FIFO_ENABLE             (C_SLOT_2_FIFO_ENABLE) 
          ) mon_fifo_inst_2
          (
           .Mon_clk                   (SLOT_2_clk),
           .Mon_rst_n                 (SLOT_2_Arst_n),
           .Data_In                   (Slot_2_Data_In),
           //.mon_en                    (Metrics_Cnt_En_sync),
           .CORE_ACLK                 (core_aclk),
           .CORE_ARESETN              (core_aresetn),
           .Sync_Data_Out             (Slot_2_Sync_Data_Out),
           .Sync_Data_Valid           (Slot_2_Sync_Data_Valid)
          );
     end
     else begin:GEN_SLOT2_NO_MON_FIFO
         assign Slot_2_Sync_Data_Out = 0;
     end
     endgenerate
     
     generate
     if(C_NUM_MONITOR_SLOTS > 2 && C_ENABLE_PROFILE ==  1) begin :GEN_SLOT2
         
          // Metric calculator instance for slot2
          axi_perf_mon_v5_0_12_metric_calc_profile 
            #(
              .C_AXIID                (C_SLOT_2_AXI_ID_WIDTH    ),
              .C_AXIADDR              (C_SLOT_2_AXI_ADDR_WIDTH  ),
              .C_AXIDATA              (C_SLOT_2_AXI_DATA_WIDTH  ),
              .C_AXI_SUB_PROTOCOL     (C_SLOT_2_AXI_SUB_PROTOCOL),
              .C_OUTSTAND_DEPTH       (C_MAX_OUTSTAND_DEPTH),
              .C_METRIC_COUNT_WIDTH   (C_METRIC_COUNT_WIDTH),
              .C_MON_FIFO_WIDTH       (C_MON_FIFO_DWIDTH_S2)
            ) metric_calc_inst2
            (
              .clk                    (core_aclk ),
              .rst_n                  (core_aresetn),
              .Data_In                (Slot_2_Sync_Data_Out),
              .Data_Valid             (Slot_2_Sync_Data_Valid), 
              .Metrics_Cnt_En         (Metrics_Cnt_En_sync),
              .Metrics_Cnt_Reset      (Metrics_Cnt_Reset_sync),
              .Use_Ext_Trig           (Use_Ext_Trig_sync),
              .Ext_Trig               (slot_2_ext_trig),
              .Ext_Trig_Stop          (slot_2_ext_trig_stop),
              .Wr_Lat_Start           (Wr_Lat_Start),  //0 Address Issue 1 Address acceptance
              .Wr_Lat_End             (Wr_Lat_End),    //1 First write   0 Last write  
              .Rd_Lat_Start           (Rd_Lat_Start),  //0 Address Issue 1 Address acceptance 
              .Rd_Lat_End             (Rd_Lat_End),    //1 First Read    0 Last Read
              .Wtrans_Cnt_En          (Wtrans_Cnt_En[2]),
              .Rtrans_Cnt_En          (Rtrans_Cnt_En[2]),
              .Write_Byte_Cnt         (S2_Write_Byte_Cnt),
              .Read_Byte_Cnt          (S2_Read_Byte_Cnt),
              .Read_Byte_Cnt_En       (S2_Read_Byte_Cnt_En),
              .Write_Beat_Cnt_En      (Write_Beat_Cnt_En[2]),
              .Read_Beat_Cnt_En       (Read_Beat_Cnt_En[2]),
              .Read_Latency           (S2_Read_Latency),
              .Write_Latency          (S2_Write_Latency),
              .Read_Latency_En        (Read_Latency_En[2]),    
              .Write_Latency_En       (Write_Latency_En[2])   ,
              .Max_Write_Latency      (S2_Max_Write_Latency),                   
              .Min_Write_Latency      (S2_Min_Write_Latency),                   
              .Max_Read_Latency       (S2_Max_Read_Latency),                   
              .Min_Read_Latency       (S2_Min_Read_Latency)                   
            );
     end
     else begin :GEN_NO_SLOT2
         assign S2_Write_Byte_Cnt    = 0;
         assign S2_Read_Byte_Cnt     = 0;
         assign S2_Read_Byte_Cnt_En  = 0;
         assign S2_Read_Latency      = 0;
         assign S2_Write_Latency     = 0;
     end
     endgenerate 

      wire [2:0] Ext_Event2_Data_In;// = {ext_event_2_cnt_start,ext_event_2_cnt_stop,ext_event_2};
       wire [2:0] Ext_Event2_Sync_Data_Out;
       wire       Ext_Event2_Sync_Data_Valid;
       generate if (C_NUM_MONITOR_SLOTS > 2 && C_ENABLE_TRACE == 1 && C_EN_AXI_DEBUG == 0 && C_EN_EXT_EVENTS_FLAG == 1) begin:GEN_SLOT2_EXT_TRACE
        assign Ext_Event2_Data_In = {ext_event_2_cnt_start,ext_event_2_cnt_stop,ext_event_2};
    
       // External Event2 through monitor FIFO
       axi_perf_mon_v5_0_12_mon_fifo
           #(
             .C_FAMILY                  (C_FAMILY),
             .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
             .C_MON_FIFO_DATA_WIDTH     (3),
             .C_FIFO_ENABLE             (C_EXT_EVENT2_FIFO_ENABLE) 
            ) mon_fifo_ext_event2_inst
            (
             .Mon_clk                   (ext_clk_2),
             .Mon_rst_n                 (ext_rstn_2),
             .Data_In                   (Ext_Event2_Data_In),
             //.mon_en                    (Metrics_Cnt_En_sync),
             .CORE_ACLK                 (core_aclk),
             .CORE_ARESETN              (core_aresetn),
             .Sync_Data_Out             (Ext_Event2_Sync_Data_Out),
             .Sync_Data_Valid           (Ext_Event2_Sync_Data_Valid)
            );
     end
     else begin
          assign Ext_Event2_Sync_Data_Out = 0;
          assign Ext_Event2_Sync_Data_Valid = 0;
     end
 endgenerate
     generate if(C_NUM_MONITOR_SLOTS > 2 && C_ENABLE_TRACE == 1) begin:GEN_SLOT2_TRACE

             //Flag Generator instantiation for slot2
       axi_perf_mon_v5_0_12_flags_gen_trace
       #(
         .C_FAMILY                  (C_FAMILY),
         .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S2), 
         .C_LOG_WIDTH               (C_SLOT_2_LOG_WIDTH),
         .C_FLAG_WIDTH              (C_SLOT_N_FLAG_WIDTH), 
         .C_AXI_ADDR_WIDTH          (C_SLOT_2_AXI_ADDR_WIDTH), 
         .C_AXI_DATA_WIDTH          (C_SLOT_2_AXI_DATA_WIDTH), 
         .C_AXI_ID_WIDTH            (C_SLOT_2_AXI_ID_WIDTH), 
         .C_AXI_PROTOCOL            (C_SLOT_2_AXI_PROTOCOL), 
         .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
         .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
         .C_EN_WR_ADD_FLAG          (C_EN_WR_ADD_FLAG), 
         .C_EN_FIRST_WRITE_FLAG     (C_EN_FIRST_WRITE_FLAG), 
         .C_EN_LAST_WRITE_FLAG      (C_EN_LAST_WRITE_FLAG), 
         .C_EN_RESPONSE_FLAG        (C_EN_RESPONSE_FLAG), 
         .C_EN_RD_ADD_FLAG          (C_EN_RD_ADD_FLAG), 
         .C_EN_FIRST_READ_FLAG      (C_EN_FIRST_READ_FLAG), 
         .C_EN_LAST_READ_FLAG       (C_EN_LAST_READ_FLAG), 
         .C_EN_EXT_EVENTS_FLAG      (C_EN_EXT_EVENTS_FLAG), 
         .C_EN_ALL_TRACE            (C_EN_ALL_TRACE), 
         .C_EN_AXI_DEBUG            (C_EN_AXI_DEBUG) 
        ) flags_generator_inst_2
        (
         .clk                       (core_aclk),
         .rst_n                     (core_aresetn),
         .Data_In                   (Slot_2_Sync_Data_Out),
         .Data_Valid                (Slot_2_Sync_Data_Valid), 
         .Ext_Trig                  (slot_2_ext_trig),
         .Ext_Trig_Stop             (slot_2_ext_trig_stop),
         .Use_Ext_Trig_Log          (Use_Ext_Trig_Log_sync),                 
         .Log_Data                  (Slot_2_Log),
         .Log_En                    (Slot_2_Log_En),
         .Ext_Data_in               (Ext_Event2_Sync_Data_Out),
         .Ext_Data_Valid            (Ext_Event2_Sync_Data_Valid),
         .Trace_Ctrl_bits           (Trace_ctrl_reg[11:8]),
         .Ext_Event_Flags           (Ext_Event2_Flags)
        );

      end
      else begin:GEN_SLOT2_NO_TRACE
        assign Slot_2_Log = 0;
        assign Slot_2_Log_En = 1'b0;
        assign Slot_2_Log_Marked = 0;
        assign Slot_2_Log_En_Marked = 1'b0;
        assign Ext_Event2_Flags = 0;
      end
      endgenerate
 generate if(C_NUM_MONITOR_SLOTS > 2 && C_ENABLE_TRACE == 1 && C_EN_TRIGGER == 1) begin : GEN_S2_POST_TRIGGER
//Aligning start and end events of transactions
       axi_perf_mon_v5_0_12_postTriggerMarker 
	    #(
			   // Parameters
			.C_FAMILY                  (C_FAMILY),
         .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S2), 
         .C_LOG_WIDTH               (C_SLOT_2_LOG_WIDTH),
         .C_FLAG_WIDTH              (C_SLOT_N_FLAG_WIDTH), 
         .C_AXI_ADDR_WIDTH          (C_SLOT_2_AXI_ADDR_WIDTH), 
         .C_AXI_DATA_WIDTH          (C_SLOT_2_AXI_DATA_WIDTH), 
         .C_AXI_ID_WIDTH            (C_SLOT_2_AXI_ID_WIDTH), 
         .C_AXI_PROTOCOL            (C_SLOT_2_AXI_PROTOCOL), 
         .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
         .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
         .C_EN_WR_ADD_FLAG          (C_EN_WR_ADD_FLAG), 
         .C_EN_FIRST_WRITE_FLAG     (C_EN_FIRST_WRITE_FLAG), 
         .C_EN_LAST_WRITE_FLAG      (C_EN_LAST_WRITE_FLAG), 
         .C_EN_RESPONSE_FLAG        (C_EN_RESPONSE_FLAG), 
         .C_EN_RD_ADD_FLAG          (C_EN_RD_ADD_FLAG), 
         .C_EN_FIRST_READ_FLAG      (C_EN_FIRST_READ_FLAG), 
         .C_EN_LAST_READ_FLAG       (C_EN_LAST_READ_FLAG), 
         .C_EN_EXT_EVENTS_FLAG      (C_EN_EXT_EVENTS_FLAG)
	   )
		triggerMarker_slot2 (
			    // Outputs
			    .Log_Data_Marked	(Slot_2_Log_Marked),
			    .Log_en_out		(Slot_2_Log_En_Marked),
			    // Inputs
			    .clk		  (core_aclk),
			    .rst_n	  (stream_fifo_rst_n),
			    .trigger  (trigger),
			    .reStart  (Metrics_Cnt_Reset_sync),
			    .Log_Data (Slot_2_Log),
			    .Log_En	  (Slot_2_Log_En)
			    );

     end
      else if(C_NUM_MONITOR_SLOTS > 2 && C_ENABLE_TRACE == 1 && C_EN_TRIGGER == 0) begin :GEN_S2_NO_POST_TRIGGER
      assign Slot_2_Log_Marked = Slot_2_Log;
      assign Slot_2_Log_En_Marked = Slot_2_Log_En;
      end
      endgenerate


     //-- Slot 3
     generate
     if(C_NUM_MONITOR_SLOTS > 3) begin :GEN_SLOT3_MON_FIFO
        axi_perf_mon_v5_0_12_mon_fifo
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
           .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S3),
           .C_FIFO_ENABLE             (C_SLOT_3_FIFO_ENABLE) 
          ) mon_fifo_inst_3
          (
           .Mon_clk                   (SLOT_3_clk),
           .Mon_rst_n                 (SLOT_3_Arst_n),
           .Data_In                   (Slot_3_Data_In),
           //.mon_en                    (Metrics_Cnt_En_sync),
           .CORE_ACLK                 (core_aclk),
           .CORE_ARESETN              (core_aresetn),
           .Sync_Data_Out             (Slot_3_Sync_Data_Out),
           .Sync_Data_Valid           (Slot_3_Sync_Data_Valid)
          );

     end
     else begin:GEN_SLOT3_NO_MON_FIFO
         assign Slot_3_Sync_Data_Out = 0;
     end
     endgenerate

     generate
     if(C_NUM_MONITOR_SLOTS > 3 && C_ENABLE_PROFILE ==  1) begin :GEN_SLOT3

                   // Metric calculator instance for slot3
          axi_perf_mon_v5_0_12_metric_calc_profile 
         #(
           .C_AXIID                   (C_SLOT_3_AXI_ID_WIDTH    ),
           .C_AXIADDR                 (C_SLOT_3_AXI_ADDR_WIDTH  ),
           .C_AXIDATA                 (C_SLOT_3_AXI_DATA_WIDTH  ),
           .C_AXI_SUB_PROTOCOL        (C_SLOT_3_AXI_SUB_PROTOCOL),
           .C_OUTSTAND_DEPTH          (C_MAX_OUTSTAND_DEPTH),
           .C_METRIC_COUNT_WIDTH      (C_METRIC_COUNT_WIDTH),
           .C_MON_FIFO_WIDTH          (C_MON_FIFO_DWIDTH_S3)
         ) metric_calc_inst3
         (
           .clk                       (core_aclk ),
           .rst_n                     (core_aresetn),
           .Data_In                   (Slot_3_Sync_Data_Out),
           .Data_Valid                (Slot_3_Sync_Data_Valid), 
           .Metrics_Cnt_En            (Metrics_Cnt_En_sync),
           .Metrics_Cnt_Reset         (Metrics_Cnt_Reset_sync),
           .Use_Ext_Trig              (Use_Ext_Trig_sync),
           .Ext_Trig                  (slot_3_ext_trig),
           .Ext_Trig_Stop             (slot_3_ext_trig_stop),
           .Wr_Lat_Start              (Wr_Lat_Start    ),  //0 Address Issue 1 Address acceptance
           .Wr_Lat_End                (Wr_Lat_End      ),  //1 First write   0 Last write  
           .Rd_Lat_Start              (Rd_Lat_Start    ),  //0 Address Issue 1 Address acceptance 
           .Rd_Lat_End                (Rd_Lat_End      ),  //1 First Read    0 Last Read
           .Wtrans_Cnt_En             (Wtrans_Cnt_En[3]),
           .Rtrans_Cnt_En             (Rtrans_Cnt_En[3]),
           .Write_Byte_Cnt            (S3_Write_Byte_Cnt),
           .Read_Byte_Cnt             (S3_Read_Byte_Cnt),
           .Read_Byte_Cnt_En          (S3_Read_Byte_Cnt_En),
           .Write_Beat_Cnt_En         (Write_Beat_Cnt_En[3]),
           .Read_Beat_Cnt_En          (Read_Beat_Cnt_En[3]),
           .Read_Latency              (S3_Read_Latency),
           .Write_Latency             (S3_Write_Latency),
           .Read_Latency_En           (Read_Latency_En[3]),    
           .Write_Latency_En          (Write_Latency_En[3])   ,
           .Max_Write_Latency         (S3_Max_Write_Latency),                   
           .Min_Write_Latency         (S3_Min_Write_Latency),                   
           .Max_Read_Latency          (S3_Max_Read_Latency),                   
           .Min_Read_Latency          (S3_Min_Read_Latency)                   
         );
     end
     else begin :GEN_NO_SLOT3
         assign S3_Write_Byte_Cnt    = 0;
         assign S3_Read_Byte_Cnt     = 0;
         assign S3_Read_Byte_Cnt_En  = 0;
         assign S3_Read_Latency      = 0;
         assign S3_Write_Latency     = 0;
     end
     endgenerate 

       wire [2:0] Ext_Event3_Data_In;// = {ext_event_3_cnt_start,ext_event_3_cnt_stop,ext_event_3};
       wire [2:0] Ext_Event3_Sync_Data_Out;
       wire       Ext_Event3_Sync_Data_Valid;
     generate if(C_NUM_MONITOR_SLOTS > 3 && C_ENABLE_TRACE == 1 && C_EN_AXI_DEBUG == 0 && C_EN_EXT_EVENTS_FLAG == 1) begin:GEN_SLOT3_EXT_TRACE
       assign Ext_Event3_Data_In = {ext_event_3_cnt_start,ext_event_3_cnt_stop,ext_event_3};
       // External Event3 through monitor FIFO
       axi_perf_mon_v5_0_12_mon_fifo
           #(
             .C_FAMILY                  (C_FAMILY),
             .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
             .C_MON_FIFO_DATA_WIDTH     (3),
             .C_FIFO_ENABLE             (C_EXT_EVENT3_FIFO_ENABLE) 
            ) mon_fifo_ext_event3_inst
            (
             .Mon_clk                   (ext_clk_3),
             .Mon_rst_n                 (ext_rstn_3),
             .Data_In                   (Ext_Event3_Data_In),
             //.mon_en                    (Metrics_Cnt_En_sync),
	          .CORE_ACLK                 (core_aclk),
             .CORE_ARESETN              (core_aresetn),
             .Sync_Data_Out             (Ext_Event3_Sync_Data_Out),
             .Sync_Data_Valid           (Ext_Event3_Sync_Data_Valid)
            );
        end
        else begin
          assign Ext_Event3_Sync_Data_Out = 0;
          assign Ext_Event3_Sync_Data_Valid = 0;

        end
    endgenerate
     generate if(C_NUM_MONITOR_SLOTS > 3 && C_ENABLE_TRACE == 1) begin:GEN_SLOT3_TRACE

              //Flag Generator instantiation for slot3
       axi_perf_mon_v5_0_12_flags_gen_trace
       #(
         .C_FAMILY                  (C_FAMILY),
         .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S3), 
         .C_LOG_WIDTH               (C_SLOT_3_LOG_WIDTH),
         .C_FLAG_WIDTH              (C_SLOT_N_FLAG_WIDTH), 
         .C_AXI_ADDR_WIDTH          (C_SLOT_3_AXI_ADDR_WIDTH), 
         .C_AXI_DATA_WIDTH          (C_SLOT_3_AXI_DATA_WIDTH), 
         .C_AXI_ID_WIDTH            (C_SLOT_3_AXI_ID_WIDTH), 
         .C_AXI_PROTOCOL            (C_SLOT_3_AXI_PROTOCOL), 
         .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
         .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
         .C_EN_WR_ADD_FLAG          (C_EN_WR_ADD_FLAG), 
         .C_EN_FIRST_WRITE_FLAG     (C_EN_FIRST_WRITE_FLAG), 
         .C_EN_LAST_WRITE_FLAG      (C_EN_LAST_WRITE_FLAG), 
         .C_EN_RESPONSE_FLAG        (C_EN_RESPONSE_FLAG), 
         .C_EN_RD_ADD_FLAG          (C_EN_RD_ADD_FLAG), 
         .C_EN_FIRST_READ_FLAG      (C_EN_FIRST_READ_FLAG), 
         .C_EN_LAST_READ_FLAG       (C_EN_LAST_READ_FLAG), 
         .C_EN_EXT_EVENTS_FLAG      (C_EN_EXT_EVENTS_FLAG), 
         .C_EN_ALL_TRACE            (C_EN_ALL_TRACE), 
         .C_EN_AXI_DEBUG            (C_EN_AXI_DEBUG) 
        ) flags_generator_inst_3
        (
         .clk                       (core_aclk),
         .rst_n                     (core_aresetn),
         .Data_In                   (Slot_3_Sync_Data_Out),
         .Data_Valid                (Slot_3_Sync_Data_Valid), 
         .Ext_Trig                  (slot_3_ext_trig),
         .Ext_Trig_Stop             (slot_3_ext_trig_stop),
         .Use_Ext_Trig_Log          (Use_Ext_Trig_Log_sync),                 
         .Log_Data                  (Slot_3_Log),
         .Log_En                    (Slot_3_Log_En),
         .Ext_Data_in               (Ext_Event3_Sync_Data_Out),
         .Ext_Data_Valid            (Ext_Event3_Sync_Data_Valid),
         .Trace_Ctrl_bits           (Trace_ctrl_reg[15:12]),
         .Ext_Event_Flags           (Ext_Event3_Flags)
        );
 
      end
      else begin:GEN_SLOT3_NO_TRACE
        assign Slot_3_Log = 0;
        assign Slot_3_Log_En = 1'b0;
        assign Slot_3_Log_Marked = 0;
        assign Slot_3_Log_En_Marked = 1'b0;
        assign Ext_Event3_Flags = 0;
      end
      endgenerate
 generate if(C_NUM_MONITOR_SLOTS > 3 && C_ENABLE_TRACE == 1 && C_EN_TRIGGER == 1) begin : GEN_S3_POST_TRIGGER
//Aligning start and end events of transactions
       axi_perf_mon_v5_0_12_postTriggerMarker 
	    #(
			   // Parameters
			.C_FAMILY                  (C_FAMILY),
         .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S3), 
         .C_LOG_WIDTH               (C_SLOT_3_LOG_WIDTH),
         .C_FLAG_WIDTH              (C_SLOT_N_FLAG_WIDTH), 
         .C_AXI_ADDR_WIDTH          (C_SLOT_3_AXI_ADDR_WIDTH), 
         .C_AXI_DATA_WIDTH          (C_SLOT_3_AXI_DATA_WIDTH), 
         .C_AXI_ID_WIDTH            (C_SLOT_3_AXI_ID_WIDTH), 
         .C_AXI_PROTOCOL            (C_SLOT_3_AXI_PROTOCOL), 
         .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
         .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
         .C_EN_WR_ADD_FLAG          (C_EN_WR_ADD_FLAG), 
         .C_EN_FIRST_WRITE_FLAG     (C_EN_FIRST_WRITE_FLAG), 
         .C_EN_LAST_WRITE_FLAG      (C_EN_LAST_WRITE_FLAG), 
         .C_EN_RESPONSE_FLAG        (C_EN_RESPONSE_FLAG), 
         .C_EN_RD_ADD_FLAG          (C_EN_RD_ADD_FLAG), 
         .C_EN_FIRST_READ_FLAG      (C_EN_FIRST_READ_FLAG), 
         .C_EN_LAST_READ_FLAG       (C_EN_LAST_READ_FLAG), 
         .C_EN_EXT_EVENTS_FLAG      (C_EN_EXT_EVENTS_FLAG)
	   )
		triggerMarker_slot3 (
			    // Outputs
			    .Log_Data_Marked	(Slot_3_Log_Marked),
			    .Log_en_out		(Slot_3_Log_En_Marked),
			    // Inputs
			    .clk		  (core_aclk),
			    .rst_n	  (stream_fifo_rst_n),
			    .trigger  (trigger),
			    .reStart  (Metrics_Cnt_Reset_sync),
			    .Log_Data (Slot_3_Log),
			    .Log_En	  (Slot_3_Log_En)
			    );

     end
      else if(C_NUM_MONITOR_SLOTS > 3 && C_ENABLE_TRACE == 1 && C_EN_TRIGGER == 0) begin :GEN_S3_NO_POST_TRIGGER
      assign Slot_3_Log_Marked = Slot_3_Log;
      assign Slot_3_Log_En_Marked = Slot_3_Log_En;
      end
      endgenerate


     //-- Slot 4
     generate
     if(C_NUM_MONITOR_SLOTS > 4) begin :GEN_SLOT4_MON_FIFO
          axi_perf_mon_v5_0_12_mon_fifo
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
           .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S4),
           .C_FIFO_ENABLE             (C_SLOT_4_FIFO_ENABLE) 
          ) mon_fifo_inst_4
          (
           .Mon_clk                   (SLOT_4_clk),
           .Mon_rst_n                 (SLOT_4_Arst_n),
           .Data_In                   (Slot_4_Data_In),
           //.mon_en                    (Metrics_Cnt_En_sync),
           .CORE_ACLK                 (core_aclk),
           .CORE_ARESETN              (core_aresetn),
           .Sync_Data_Out             (Slot_4_Sync_Data_Out),
           .Sync_Data_Valid           (Slot_4_Sync_Data_Valid)
          );

     end
     else begin:GEN_SLOT4_NO_MON_FIFO
          assign Slot_4_Sync_Data_Out = 0;
     end
     endgenerate

     generate
     if(C_NUM_MONITOR_SLOTS > 4 && C_ENABLE_PROFILE ==  1) begin :GEN_SLOT4

          // Metric calculator instance for slot4
          axi_perf_mon_v5_0_12_metric_calc_profile 
             #(
            .C_AXIID                   (C_SLOT_4_AXI_ID_WIDTH    ),
            .C_AXIADDR                 (C_SLOT_4_AXI_ADDR_WIDTH  ),
            .C_AXIDATA                 (C_SLOT_4_AXI_DATA_WIDTH  ),
            .C_AXI_SUB_PROTOCOL        (C_SLOT_4_AXI_SUB_PROTOCOL),
            .C_OUTSTAND_DEPTH          (C_MAX_OUTSTAND_DEPTH),
            .C_METRIC_COUNT_WIDTH      (C_METRIC_COUNT_WIDTH),
            .C_MON_FIFO_WIDTH          (C_MON_FIFO_DWIDTH_S4)
             ) metric_calc_inst4
          (
            .clk                       (core_aclk ),
            .rst_n                     (core_aresetn),
            .Data_In                   (Slot_4_Sync_Data_Out),
            .Data_Valid                (Slot_4_Sync_Data_Valid), 
            .Metrics_Cnt_En            (Metrics_Cnt_En_sync),
            .Metrics_Cnt_Reset         (Metrics_Cnt_Reset_sync),
            .Use_Ext_Trig              (Use_Ext_Trig_sync),
            .Ext_Trig                  (slot_4_ext_trig),
            .Ext_Trig_Stop             (slot_4_ext_trig_stop),
            .Wr_Lat_Start              (Wr_Lat_Start    ),  //0 Address Issue 1 Address acceptance
            .Wr_Lat_End                (Wr_Lat_End      ),  //1 First write   0 Last write  
            .Rd_Lat_Start              (Rd_Lat_Start    ),  //0 Address Issue 1 Address acceptance 
            .Rd_Lat_End                (Rd_Lat_End      ),  //1 First Read    0 Last Read
            .Wtrans_Cnt_En             (Wtrans_Cnt_En[4]),
            .Rtrans_Cnt_En             (Rtrans_Cnt_En[4]),
            .Write_Byte_Cnt            (S4_Write_Byte_Cnt),
            .Read_Byte_Cnt             (S4_Read_Byte_Cnt),
            .Read_Byte_Cnt_En          (S4_Read_Byte_Cnt_En),
            .Write_Beat_Cnt_En         (Write_Beat_Cnt_En[4]),
            .Read_Beat_Cnt_En          (Read_Beat_Cnt_En[4]),
            .Read_Latency              (S4_Read_Latency),
            .Write_Latency             (S4_Write_Latency),
            .Read_Latency_En           (Read_Latency_En[4]),    
            .Write_Latency_En          (Write_Latency_En[4])   ,
            .Max_Write_Latency         (S4_Max_Write_Latency),                   
            .Min_Write_Latency         (S4_Min_Write_Latency),                   
            .Max_Read_Latency          (S4_Max_Read_Latency),                   
            .Min_Read_Latency          (S4_Min_Read_Latency)                   
          );
     end
     else begin :GEN_NO_SLOT4
         assign S4_Write_Byte_Cnt    = 0;
         assign S4_Read_Byte_Cnt     = 0;
         assign S4_Read_Byte_Cnt_En  = 0;
         assign S4_Read_Latency      = 0;
         assign S4_Write_Latency     = 0;
     end
     endgenerate 


     wire [2:0] Ext_Event4_Data_In;// = {ext_event_4_cnt_start,ext_event_4_cnt_stop,ext_event_4};
       wire [2:0] Ext_Event4_Sync_Data_Out;
       wire       Ext_Event4_Sync_Data_Valid;
      generate if (C_NUM_MONITOR_SLOTS > 4 && C_ENABLE_TRACE == 1 && C_EN_AXI_DEBUG == 0 && C_EN_EXT_EVENTS_FLAG == 1) begin:GEN_SLOT4_EXT_TRACE
     assign Ext_Event4_Data_In = {ext_event_4_cnt_start,ext_event_4_cnt_stop,ext_event_4};
    
       // External Event4 through monitor FIFO
       axi_perf_mon_v5_0_12_mon_fifo
           #(
             .C_FAMILY                  (C_FAMILY),
             .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
             .C_MON_FIFO_DATA_WIDTH     (3),
             .C_FIFO_ENABLE             (C_EXT_EVENT4_FIFO_ENABLE) 
            ) mon_fifo_ext_event4_inst
            (
             .Mon_clk                   (ext_clk_4),
             .Mon_rst_n                 (ext_rstn_4),
             .Data_In                   (Ext_Event4_Data_In),
             //.mon_en                    (Metrics_Cnt_En_sync),
             .CORE_ACLK                 (core_aclk),
             .CORE_ARESETN              (core_aresetn),
             .Sync_Data_Out             (Ext_Event4_Sync_Data_Out),
             .Sync_Data_Valid           (Ext_Event4_Sync_Data_Valid)
            );
        end
        else begin
          assign Ext_Event4_Sync_Data_Out = 0;
          assign Ext_Event4_Sync_Data_Valid = 0;

        end
    endgenerate
    generate if(C_NUM_MONITOR_SLOTS > 4 && C_ENABLE_TRACE == 1) begin:GEN_SLOT4_TRACE

              //Flag Generator instantiation for slot4
       axi_perf_mon_v5_0_12_flags_gen_trace
       #(
         .C_FAMILY                  (C_FAMILY),
         .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S4), 
         .C_LOG_WIDTH               (C_SLOT_4_LOG_WIDTH),
         .C_FLAG_WIDTH              (C_SLOT_N_FLAG_WIDTH), 
         .C_AXI_ADDR_WIDTH          (C_SLOT_4_AXI_ADDR_WIDTH), 
         .C_AXI_DATA_WIDTH          (C_SLOT_4_AXI_DATA_WIDTH), 
         .C_AXI_ID_WIDTH            (C_SLOT_4_AXI_ID_WIDTH), 
         .C_AXI_PROTOCOL            (C_SLOT_4_AXI_PROTOCOL), 
         .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
         .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
         .C_EN_WR_ADD_FLAG          (C_EN_WR_ADD_FLAG), 
         .C_EN_FIRST_WRITE_FLAG     (C_EN_FIRST_WRITE_FLAG), 
         .C_EN_LAST_WRITE_FLAG      (C_EN_LAST_WRITE_FLAG), 
         .C_EN_RESPONSE_FLAG        (C_EN_RESPONSE_FLAG), 
         .C_EN_RD_ADD_FLAG          (C_EN_RD_ADD_FLAG), 
         .C_EN_FIRST_READ_FLAG      (C_EN_FIRST_READ_FLAG), 
         .C_EN_LAST_READ_FLAG       (C_EN_LAST_READ_FLAG), 
         .C_EN_EXT_EVENTS_FLAG      (C_EN_EXT_EVENTS_FLAG), 
         .C_EN_ALL_TRACE            (C_EN_ALL_TRACE), 
         .C_EN_AXI_DEBUG            (C_EN_AXI_DEBUG) 
        ) flags_generator_inst_4
        (
         .clk                       (core_aclk),
         .rst_n                     (core_aresetn),
         .Data_In                   (Slot_4_Sync_Data_Out),
         .Data_Valid                (Slot_4_Sync_Data_Valid), 
         .Ext_Trig                  (slot_4_ext_trig),
         .Ext_Trig_Stop             (slot_4_ext_trig_stop),
         .Use_Ext_Trig_Log          (Use_Ext_Trig_Log_sync),                 
         .Log_Data                  (Slot_4_Log),
         .Log_En                    (Slot_4_Log_En),
         .Ext_Data_in               (Ext_Event4_Sync_Data_Out),
         .Ext_Data_Valid            (Ext_Event4_Sync_Data_Valid),
         .Trace_Ctrl_bits           (Trace_ctrl_reg[19:16]),
         .Ext_Event_Flags           (Ext_Event4_Flags)
        );

      end
      else begin:GEN_SLOT4_NO_TRACE
        assign Slot_4_Log = 0;
        assign Slot_4_Log_En = 1'b0;
        assign Slot_4_Log_Marked = 0;
        assign Slot_4_Log_En_Marked = 1'b0;
        assign Ext_Event4_Flags = 0;
      end
      endgenerate
 generate if(C_NUM_MONITOR_SLOTS > 4 && C_ENABLE_TRACE == 1 && C_EN_TRIGGER == 1) begin : GEN_S4_POST_TRIGGER
//Aligning start and end events of transactions
       axi_perf_mon_v5_0_12_postTriggerMarker 
	    #(
			   // Parameters
			.C_FAMILY                  (C_FAMILY),
         .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S4), 
         .C_LOG_WIDTH               (C_SLOT_4_LOG_WIDTH),
         .C_FLAG_WIDTH              (C_SLOT_N_FLAG_WIDTH), 
         .C_AXI_ADDR_WIDTH          (C_SLOT_4_AXI_ADDR_WIDTH), 
         .C_AXI_DATA_WIDTH          (C_SLOT_4_AXI_DATA_WIDTH), 
         .C_AXI_ID_WIDTH            (C_SLOT_4_AXI_ID_WIDTH), 
         .C_AXI_PROTOCOL            (C_SLOT_4_AXI_PROTOCOL), 
         .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
         .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
         .C_EN_WR_ADD_FLAG          (C_EN_WR_ADD_FLAG), 
         .C_EN_FIRST_WRITE_FLAG     (C_EN_FIRST_WRITE_FLAG), 
         .C_EN_LAST_WRITE_FLAG      (C_EN_LAST_WRITE_FLAG), 
         .C_EN_RESPONSE_FLAG        (C_EN_RESPONSE_FLAG), 
         .C_EN_RD_ADD_FLAG          (C_EN_RD_ADD_FLAG), 
         .C_EN_FIRST_READ_FLAG      (C_EN_FIRST_READ_FLAG), 
         .C_EN_LAST_READ_FLAG       (C_EN_LAST_READ_FLAG), 
         .C_EN_EXT_EVENTS_FLAG      (C_EN_EXT_EVENTS_FLAG)
	   )
		triggerMarker_slot4 (
			    // Outputs
			    .Log_Data_Marked	(Slot_4_Log_Marked),
			    .Log_en_out		(Slot_4_Log_En_Marked),
			    // Inputs
			    .clk		  (core_aclk),
			    .rst_n	  (stream_fifo_rst_n),
			    .trigger  (trigger),
			    .reStart  (Metrics_Cnt_Reset_sync),
			    .Log_Data (Slot_4_Log),
			    .Log_En	  (Slot_4_Log_En)
			    );

     end
      else if(C_NUM_MONITOR_SLOTS > 4 && C_ENABLE_TRACE == 1 && C_EN_TRIGGER == 0) begin :GEN_S4_NO_POST_TRIGGER
      assign Slot_4_Log_Marked = Slot_4_Log;
      assign Slot_4_Log_En_Marked = Slot_4_Log_En;
      end
      endgenerate


     //-- Slot 5
     generate
     if(C_NUM_MONITOR_SLOTS > 5) begin :GEN_SLOT5_MON_FIFO
         axi_perf_mon_v5_0_12_mon_fifo
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
           .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S5),
           .C_FIFO_ENABLE             (C_SLOT_5_FIFO_ENABLE) 
          ) mon_fifo_inst_5
          (
           .Mon_clk                   (SLOT_5_clk),
           .Mon_rst_n                 (SLOT_5_Arst_n),
           .Data_In                   (Slot_5_Data_In),
           //.mon_en                    (Metrics_Cnt_En_sync),
           .CORE_ACLK                 (core_aclk),
           .CORE_ARESETN              (core_aresetn),
           .Sync_Data_Out             (Slot_5_Sync_Data_Out),
           .Sync_Data_Valid           (Slot_5_Sync_Data_Valid)
          );
     end
     else begin:GEN_SLOT5_NO_MON_FIFO
        assign Slot_5_Sync_Data_Out = 0;
     end
     endgenerate


     generate
     if(C_NUM_MONITOR_SLOTS > 5 && C_ENABLE_PROFILE ==  1) begin :GEN_SLOT5

                // Metric calculator instance for slot5
          axi_perf_mon_v5_0_12_metric_calc_profile 
          #(
            .C_AXIID                   (C_SLOT_5_AXI_ID_WIDTH    ),
            .C_AXIADDR                 (C_SLOT_5_AXI_ADDR_WIDTH  ),
            .C_AXIDATA                 (C_SLOT_5_AXI_DATA_WIDTH  ),
            .C_AXI_SUB_PROTOCOL        (C_SLOT_5_AXI_SUB_PROTOCOL),
            .C_OUTSTAND_DEPTH          (C_MAX_OUTSTAND_DEPTH),
            .C_METRIC_COUNT_WIDTH      (C_METRIC_COUNT_WIDTH),
            .C_MON_FIFO_WIDTH          (C_MON_FIFO_DWIDTH_S5)
          ) metric_calc_inst5
          (
            .clk                       (core_aclk ),
            .rst_n                     (core_aresetn),
            .Data_In                   (Slot_5_Sync_Data_Out),
            .Data_Valid                (Slot_5_Sync_Data_Valid), 
            .Metrics_Cnt_En            (Metrics_Cnt_En_sync),
            .Metrics_Cnt_Reset         (Metrics_Cnt_Reset_sync),
            .Use_Ext_Trig              (Use_Ext_Trig_sync),
            .Ext_Trig                  (slot_5_ext_trig),
            .Ext_Trig_Stop             (slot_5_ext_trig_stop),
            .Wr_Lat_Start              (Wr_Lat_Start),  //0 Address Issue 1 Address acceptance
            .Wr_Lat_End                (Wr_Lat_End),  //1 First write   0 Last write  
            .Rd_Lat_Start              (Rd_Lat_Start),  //0 Address Issue 1 Address acceptance 
            .Rd_Lat_End                (Rd_Lat_End),  //1 First Read    0 Last Read
            .Wtrans_Cnt_En             (Wtrans_Cnt_En[5]),
            .Rtrans_Cnt_En             (Rtrans_Cnt_En[5]),
            .Write_Byte_Cnt            (S5_Write_Byte_Cnt),
            .Read_Byte_Cnt             (S5_Read_Byte_Cnt),
            .Read_Byte_Cnt_En          (S5_Read_Byte_Cnt_En),
            .Write_Beat_Cnt_En         (Write_Beat_Cnt_En[5]),
            .Read_Beat_Cnt_En          (Read_Beat_Cnt_En[5]),
            .Read_Latency              (S5_Read_Latency),
            .Write_Latency             (S5_Write_Latency),
            .Read_Latency_En           (Read_Latency_En[5]),    
            .Write_Latency_En          (Write_Latency_En[5])   ,
            .Max_Write_Latency         (S5_Max_Write_Latency),                   
            .Min_Write_Latency         (S5_Min_Write_Latency),                   
            .Max_Read_Latency          (S5_Max_Read_Latency),                   
            .Min_Read_Latency          (S5_Min_Read_Latency)                   
          );
     end
     else begin :GEN_NO_SLOT5
         assign S5_Write_Byte_Cnt    = 0;
         assign S5_Read_Byte_Cnt     = 0;
         assign S5_Read_Byte_Cnt_En  = 0;
         assign S5_Read_Latency      = 0;
         assign S5_Write_Latency     = 0;
     end
     endgenerate 

       wire [2:0] Ext_Event5_Data_In;// = {ext_event_5_cnt_start,ext_event_5_cnt_stop,ext_event_5};
       wire [2:0] Ext_Event5_Sync_Data_Out;
       wire       Ext_Event5_Sync_Data_Valid;
      generate if (C_NUM_MONITOR_SLOTS > 5 && C_ENABLE_TRACE == 1 && C_EN_AXI_DEBUG == 0 && C_EN_EXT_EVENTS_FLAG == 1) begin:GEN_SLOT5_EXT_TRACE
       
       assign Ext_Event5_Data_In = {ext_event_5_cnt_start,ext_event_5_cnt_stop,ext_event_5};
    
       // External Event5 through monitor FIFO
       axi_perf_mon_v5_0_12_mon_fifo
           #(
             .C_FAMILY                  (C_FAMILY),
             .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
             .C_MON_FIFO_DATA_WIDTH     (3),
             .C_FIFO_ENABLE             (C_EXT_EVENT5_FIFO_ENABLE) 
            ) mon_fifo_ext_event5_inst
            (
             .Mon_clk                   (ext_clk_5),
             .Mon_rst_n                 (ext_rstn_5),
             .Data_In                   (Ext_Event5_Data_In),
             //.mon_en                    (Metrics_Cnt_En_sync),
             .CORE_ACLK                 (core_aclk),
             .CORE_ARESETN              (core_aresetn),
             .Sync_Data_Out             (Ext_Event5_Sync_Data_Out),
             .Sync_Data_Valid           (Ext_Event5_Sync_Data_Valid)
            );
        end
        else begin
          assign Ext_Event5_Sync_Data_Out = 0;
          assign Ext_Event5_Sync_Data_Valid = 0;
        end
    endgenerate

     generate if(C_NUM_MONITOR_SLOTS > 5 && C_ENABLE_TRACE == 1) begin:GEN_SLOT5_TRACE
              //Flag Generator instantiation for slot5
       axi_perf_mon_v5_0_12_flags_gen_trace
       #(
         .C_FAMILY                  (C_FAMILY),
         .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S5), 
         .C_LOG_WIDTH               (C_SLOT_5_LOG_WIDTH),
         .C_FLAG_WIDTH              (C_SLOT_N_FLAG_WIDTH), 
         .C_AXI_ADDR_WIDTH          (C_SLOT_5_AXI_ADDR_WIDTH), 
         .C_AXI_DATA_WIDTH          (C_SLOT_5_AXI_DATA_WIDTH), 
         .C_AXI_ID_WIDTH            (C_SLOT_5_AXI_ID_WIDTH), 
         .C_AXI_PROTOCOL            (C_SLOT_5_AXI_PROTOCOL), 
         .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
         .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
         .C_EN_WR_ADD_FLAG          (C_EN_WR_ADD_FLAG), 
         .C_EN_FIRST_WRITE_FLAG     (C_EN_FIRST_WRITE_FLAG), 
         .C_EN_LAST_WRITE_FLAG      (C_EN_LAST_WRITE_FLAG), 
         .C_EN_RESPONSE_FLAG        (C_EN_RESPONSE_FLAG), 
         .C_EN_RD_ADD_FLAG          (C_EN_RD_ADD_FLAG), 
         .C_EN_FIRST_READ_FLAG      (C_EN_FIRST_READ_FLAG), 
         .C_EN_LAST_READ_FLAG       (C_EN_LAST_READ_FLAG), 
         .C_EN_EXT_EVENTS_FLAG      (C_EN_EXT_EVENTS_FLAG), 
         .C_EN_ALL_TRACE            (C_EN_ALL_TRACE), 
         .C_EN_AXI_DEBUG            (C_EN_AXI_DEBUG) 
        ) flags_generator_inst_5
        (
         .clk                       (core_aclk),
         .rst_n                     (core_aresetn),
         .Data_In                   (Slot_5_Sync_Data_Out),
         .Data_Valid                (Slot_5_Sync_Data_Valid), 
         .Ext_Trig                  (slot_5_ext_trig),
         .Ext_Trig_Stop             (slot_5_ext_trig_stop),
         .Use_Ext_Trig_Log          (Use_Ext_Trig_Log_sync),                 
         .Log_Data                  (Slot_5_Log),
         .Log_En                    (Slot_5_Log_En),
         .Ext_Data_in               (Ext_Event5_Sync_Data_Out),
         .Ext_Data_Valid            (Ext_Event5_Sync_Data_Valid),
         .Trace_Ctrl_bits           (Trace_ctrl_reg[23:20]),
         .Ext_Event_Flags           (Ext_Event5_Flags)
        );

      end
      else begin:GEN_SLOT5_NO_TRACE
        assign Slot_5_Log = 0;
        assign Slot_5_Log_En = 1'b0;
        assign Slot_5_Log_Marked = 0;
        assign Slot_5_Log_En_Marked = 1'b0;
        assign Ext_Event5_Flags = 0;
      end
      endgenerate
 generate if(C_NUM_MONITOR_SLOTS > 5 && C_ENABLE_TRACE == 1 && C_EN_TRIGGER == 1) begin : GEN_S5_POST_TRIGGER
//Aligning start and end events of transactions
       axi_perf_mon_v5_0_12_postTriggerMarker 
	    #(
			   // Parameters
			.C_FAMILY                  (C_FAMILY),
         .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S5), 
         .C_LOG_WIDTH               (C_SLOT_5_LOG_WIDTH),
         .C_FLAG_WIDTH              (C_SLOT_N_FLAG_WIDTH), 
         .C_AXI_ADDR_WIDTH          (C_SLOT_5_AXI_ADDR_WIDTH), 
         .C_AXI_DATA_WIDTH          (C_SLOT_5_AXI_DATA_WIDTH), 
         .C_AXI_ID_WIDTH            (C_SLOT_5_AXI_ID_WIDTH), 
         .C_AXI_PROTOCOL            (C_SLOT_5_AXI_PROTOCOL), 
         .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
         .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
         .C_EN_WR_ADD_FLAG          (C_EN_WR_ADD_FLAG), 
         .C_EN_FIRST_WRITE_FLAG     (C_EN_FIRST_WRITE_FLAG), 
         .C_EN_LAST_WRITE_FLAG      (C_EN_LAST_WRITE_FLAG), 
         .C_EN_RESPONSE_FLAG        (C_EN_RESPONSE_FLAG), 
         .C_EN_RD_ADD_FLAG          (C_EN_RD_ADD_FLAG), 
         .C_EN_FIRST_READ_FLAG      (C_EN_FIRST_READ_FLAG), 
         .C_EN_LAST_READ_FLAG       (C_EN_LAST_READ_FLAG), 
         .C_EN_EXT_EVENTS_FLAG      (C_EN_EXT_EVENTS_FLAG)
	   )
		triggerMarker_slot5 (
			    // Outputs
			    .Log_Data_Marked	(Slot_5_Log_Marked),
			    .Log_en_out		(Slot_5_Log_En_Marked),
			    // Inputs
			    .clk		  (core_aclk),
			    .rst_n	  (stream_fifo_rst_n),
			    .trigger  (trigger),
			    .reStart  (Metrics_Cnt_Reset_sync),
			    .Log_Data (Slot_5_Log),
			    .Log_En	  (Slot_5_Log_En)
			    );

     end
      else if(C_NUM_MONITOR_SLOTS > 5 && C_ENABLE_TRACE == 1 && C_EN_TRIGGER == 0) begin :GEN_S5_NO_POST_TRIGGER
      assign Slot_5_Log_Marked = Slot_5_Log;
      assign Slot_5_Log_En_Marked = Slot_5_Log_En;
      end
      endgenerate


     //-- Slot 6
     generate
     if(C_NUM_MONITOR_SLOTS > 6 ) begin :GEN_SLOT6_MON_FIFO
        axi_perf_mon_v5_0_12_mon_fifo
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
           .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S6),
           .C_FIFO_ENABLE             (C_SLOT_6_FIFO_ENABLE) 
          ) mon_fifo_inst_6
          (
           .Mon_clk                   (SLOT_6_clk),
           .Mon_rst_n                 (SLOT_6_Arst_n),
           .Data_In                   (Slot_6_Data_In),
           //.mon_en                    (Metrics_Cnt_En_sync),
           .CORE_ACLK                 (core_aclk),
           .CORE_ARESETN              (core_aresetn),
           .Sync_Data_Out             (Slot_6_Sync_Data_Out),
           .Sync_Data_Valid           (Slot_6_Sync_Data_Valid)
          );
     end
     else begin:GEN_SLOT6_NO_MON_FIFO
         assign Slot_6_Sync_Data_Out = 0;
     end
     endgenerate
         
     generate
     if(C_NUM_MONITOR_SLOTS > 6 && C_ENABLE_PROFILE ==  1) begin :GEN_SLOT6
         
         // Metric calculator instance for slot6
         axi_perf_mon_v5_0_12_metric_calc_profile 
          #(
            .C_AXIID                   (C_SLOT_6_AXI_ID_WIDTH    ),
            .C_AXIADDR                 (C_SLOT_6_AXI_ADDR_WIDTH  ),
            .C_AXIDATA                 (C_SLOT_6_AXI_DATA_WIDTH  ),
            .C_AXI_SUB_PROTOCOL        (C_SLOT_6_AXI_SUB_PROTOCOL),
            .C_OUTSTAND_DEPTH          (C_MAX_OUTSTAND_DEPTH),
            .C_METRIC_COUNT_WIDTH      (C_METRIC_COUNT_WIDTH),
            .C_MON_FIFO_WIDTH          (C_MON_FIFO_DWIDTH_S6)
          ) metric_calc_inst6
          (
            .clk                       (core_aclk ),
            .rst_n                     (core_aresetn),
            .Data_In                   (Slot_6_Sync_Data_Out),
            .Data_Valid                (Slot_6_Sync_Data_Valid), 
            .Metrics_Cnt_En            (Metrics_Cnt_En_sync),
            .Metrics_Cnt_Reset         (Metrics_Cnt_Reset_sync),
            .Use_Ext_Trig              (Use_Ext_Trig_sync),
            .Ext_Trig                  (slot_6_ext_trig),
            .Ext_Trig_Stop             (slot_6_ext_trig_stop),
            .Wr_Lat_Start              (Wr_Lat_Start    ),  //0 Address Issue 1 Address acceptance
            .Wr_Lat_End                (Wr_Lat_End),  //1 First write   0 Last write  
            .Rd_Lat_Start              (Rd_Lat_Start),  //0 Address Issue 1 Address acceptance 
            .Rd_Lat_End                (Rd_Lat_End),  //1 First Read    0 Last Read
            .Wtrans_Cnt_En             (Wtrans_Cnt_En[6]),
            .Rtrans_Cnt_En             (Rtrans_Cnt_En[6]),
            .Write_Byte_Cnt            (S6_Write_Byte_Cnt),
            .Read_Byte_Cnt             (S6_Read_Byte_Cnt),
            .Read_Byte_Cnt_En          (S6_Read_Byte_Cnt_En),
            .Write_Beat_Cnt_En         (Write_Beat_Cnt_En[6]),
            .Read_Beat_Cnt_En          (Read_Beat_Cnt_En[6]),
            .Read_Latency              (S6_Read_Latency),
            .Write_Latency             (S6_Write_Latency),
            .Read_Latency_En           (Read_Latency_En[6]),    
            .Write_Latency_En          (Write_Latency_En[6])   ,
            .Max_Write_Latency         (S6_Max_Write_Latency),                   
            .Min_Write_Latency         (S6_Min_Write_Latency),                   
            .Max_Read_Latency          (S6_Max_Read_Latency),                   
            .Min_Read_Latency          (S6_Min_Read_Latency)                   
          );
     end
     else begin :GEN_NO_SLOT6
         assign S6_Write_Byte_Cnt    = 0;
         assign S6_Read_Byte_Cnt     = 0;
         assign S6_Read_Byte_Cnt_En  = 0;
         assign S6_Read_Latency      = 0;
         assign S6_Write_Latency     = 0;
     end
     endgenerate 

       wire [2:0] Ext_Event6_Data_In;// = {ext_event_6_cnt_start,ext_event_6_cnt_stop,ext_event_6};
       wire [2:0] Ext_Event6_Sync_Data_Out;
       wire       Ext_Event6_Sync_Data_Valid;
      generate if (C_EN_AXI_DEBUG == 0 && C_EN_EXT_EVENTS_FLAG == 1 && C_NUM_MONITOR_SLOTS > 6 && C_ENABLE_TRACE == 1) begin:GEN_SLOT6_EXT_TRACE
       assign Ext_Event6_Data_In = {ext_event_6_cnt_start,ext_event_6_cnt_stop,ext_event_6};
    
       // External Event6 through monitor FIFO
       axi_perf_mon_v5_0_12_mon_fifo
           #(
             .C_FAMILY                  (C_FAMILY),
             .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
             .C_MON_FIFO_DATA_WIDTH     (3),
             .C_FIFO_ENABLE             (C_EXT_EVENT6_FIFO_ENABLE) 
            ) mon_fifo_ext_event6_inst
            (
             .Mon_clk                   (ext_clk_6),
             .Mon_rst_n                 (ext_rstn_6),
             .Data_In                   (Ext_Event6_Data_In),
             //.mon_en                    (Metrics_Cnt_En_sync),
             .CORE_ACLK                 (core_aclk),
             .CORE_ARESETN              (core_aresetn),
             .Sync_Data_Out             (Ext_Event6_Sync_Data_Out),
             .Sync_Data_Valid           (Ext_Event6_Sync_Data_Valid)
            );
        end
        else begin
          assign Ext_Event6_Sync_Data_Out = 0;
          assign Ext_Event6_Sync_Data_Valid = 0;
        end
    endgenerate

     generate if(C_NUM_MONITOR_SLOTS > 6 && C_ENABLE_TRACE == 1) begin:GEN_SLOT6_TRACE
              //Flag Generator instantiation for slot6
       axi_perf_mon_v5_0_12_flags_gen_trace
       #(
         .C_FAMILY                  (C_FAMILY),
         .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S6), 
         .C_LOG_WIDTH               (C_SLOT_6_LOG_WIDTH),
         .C_FLAG_WIDTH              (C_SLOT_N_FLAG_WIDTH), 
         .C_AXI_ADDR_WIDTH          (C_SLOT_6_AXI_ADDR_WIDTH), 
         .C_AXI_DATA_WIDTH          (C_SLOT_6_AXI_DATA_WIDTH), 
         .C_AXI_ID_WIDTH            (C_SLOT_6_AXI_ID_WIDTH), 
         .C_AXI_PROTOCOL            (C_SLOT_6_AXI_PROTOCOL), 
         .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
         .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
         .C_EN_WR_ADD_FLAG          (C_EN_WR_ADD_FLAG), 
         .C_EN_FIRST_WRITE_FLAG     (C_EN_FIRST_WRITE_FLAG), 
         .C_EN_LAST_WRITE_FLAG      (C_EN_LAST_WRITE_FLAG), 
         .C_EN_RESPONSE_FLAG        (C_EN_RESPONSE_FLAG), 
         .C_EN_RD_ADD_FLAG          (C_EN_RD_ADD_FLAG), 
         .C_EN_FIRST_READ_FLAG      (C_EN_FIRST_READ_FLAG), 
         .C_EN_LAST_READ_FLAG       (C_EN_LAST_READ_FLAG), 
         .C_EN_EXT_EVENTS_FLAG      (C_EN_EXT_EVENTS_FLAG), 
         .C_EN_ALL_TRACE            (C_EN_ALL_TRACE), 
         .C_EN_AXI_DEBUG            (C_EN_AXI_DEBUG) 
        ) flags_generator_inst_6
        (
         .clk                       (core_aclk),
         .rst_n                     (core_aresetn),
         .Data_In                   (Slot_6_Sync_Data_Out),
         .Data_Valid                (Slot_6_Sync_Data_Valid), 
         .Ext_Trig                  (slot_6_ext_trig),
         .Ext_Trig_Stop             (slot_6_ext_trig_stop),
         .Use_Ext_Trig_Log          (Use_Ext_Trig_Log_sync),                 
         .Log_Data                  (Slot_6_Log),
         .Log_En                    (Slot_6_Log_En),
         .Ext_Data_in               (Ext_Event6_Sync_Data_Out),
         .Ext_Data_Valid            (Ext_Event6_Sync_Data_Valid),
         .Trace_Ctrl_bits           (Trace_ctrl_reg[27:24]),
         .Ext_Event_Flags           (Ext_Event6_Flags)
        );

      end
      else begin:GEN_SLOT6_NO_TRACE
        assign Slot_6_Log = 0;
        assign Slot_6_Log_En = 1'b0;
        assign Ext_Event6_Flags = 0;
      end
      endgenerate


     //-- Slot 7
     generate
     if(C_NUM_MONITOR_SLOTS > 7 ) begin :GEN_SLOT7_MON_FIFO
           axi_perf_mon_v5_0_12_mon_fifo
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
           .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S7),
           .C_FIFO_ENABLE             (C_SLOT_7_FIFO_ENABLE) 
          ) mon_fifo_inst_7
          (
           .Mon_clk                   (SLOT_7_clk),
           .Mon_rst_n                 (SLOT_7_Arst_n),
           .Data_In                   (Slot_7_Data_In),
           //.mon_en                    (Metrics_Cnt_En_sync),
           .CORE_ACLK                 (core_aclk),
           .CORE_ARESETN              (core_aresetn),
           .Sync_Data_Out             (Slot_7_Sync_Data_Out),
           .Sync_Data_Valid           (Slot_7_Sync_Data_Valid)
          );
     end
     else begin:GEN_SLOT7_NO_MON_FIFO
        assign Slot_7_Sync_Data_Out = 0;
     end
     endgenerate

     generate
     if(C_NUM_MONITOR_SLOTS > 7 && C_ENABLE_PROFILE ==  1) begin :GEN_SLOT7

                
          // Metric calculator instance for slot7
          axi_perf_mon_v5_0_12_metric_calc_profile 
           #(
             .C_AXIID                   (C_SLOT_7_AXI_ID_WIDTH    ),
             .C_AXIADDR                 (C_SLOT_7_AXI_ADDR_WIDTH  ),
             .C_AXIDATA                 (C_SLOT_7_AXI_DATA_WIDTH  ),
             .C_AXI_SUB_PROTOCOL        (C_SLOT_7_AXI_SUB_PROTOCOL),
             .C_OUTSTAND_DEPTH          (C_MAX_OUTSTAND_DEPTH),
             .C_METRIC_COUNT_WIDTH      (C_METRIC_COUNT_WIDTH),
             .C_MON_FIFO_WIDTH          (C_MON_FIFO_DWIDTH_S7)
           ) metric_calc_inst7
           (
             .clk                       (core_aclk ),
             .rst_n                     (core_aresetn),
             .Data_In                   (Slot_7_Sync_Data_Out),
             .Data_Valid                (Slot_7_Sync_Data_Valid), 
             .Metrics_Cnt_En            (Metrics_Cnt_En_sync),
             .Metrics_Cnt_Reset         (Metrics_Cnt_Reset_sync),
             .Use_Ext_Trig              (Use_Ext_Trig_sync),
             .Ext_Trig                  (slot_7_ext_trig),
             .Ext_Trig_Stop             (slot_7_ext_trig_stop),
             .Wr_Lat_Start              (Wr_Lat_Start),  //0 Address Issue 1 Address acceptance
             .Wr_Lat_End                (Wr_Lat_End),  //1 First write   0 Last write  
             .Rd_Lat_Start              (Rd_Lat_Start),  //0 Address Issue 1 Address acceptance 
             .Rd_Lat_End                (Rd_Lat_End),  //1 First Read    0 Last Read
             .Wtrans_Cnt_En             (Wtrans_Cnt_En[7]),
             .Rtrans_Cnt_En             (Rtrans_Cnt_En[7]),
             .Write_Byte_Cnt            (S7_Write_Byte_Cnt),
             .Read_Byte_Cnt             (S7_Read_Byte_Cnt),
             .Read_Byte_Cnt_En          (S7_Read_Byte_Cnt_En),
             .Write_Beat_Cnt_En         (Write_Beat_Cnt_En[7]),
             .Read_Beat_Cnt_En          (Read_Beat_Cnt_En[7]),
             .Read_Latency              (S7_Read_Latency),
             .Write_Latency             (S7_Write_Latency),
             .Read_Latency_En           (Read_Latency_En[7]),    
             .Write_Latency_En          (Write_Latency_En[7])   ,
             .Max_Write_Latency         (S7_Max_Write_Latency),                   
             .Min_Write_Latency         (S7_Min_Write_Latency),                   
             .Max_Read_Latency          (S7_Max_Read_Latency),                   
             .Min_Read_Latency          (S7_Min_Read_Latency)                   
           );
     end
     else begin :GEN_NO_SLOT7
         assign S7_Write_Byte_Cnt    = 0;
         assign S7_Read_Byte_Cnt     = 0;
         assign S7_Read_Byte_Cnt_En  = 0;
         assign S7_Read_Latency      = 0;
         assign S7_Write_Latency     = 0;
     end
     endgenerate 

       wire [2:0] Ext_Event7_Data_In;// = {ext_event_7_cnt_start,ext_event_7_cnt_stop,ext_event_7};
       wire [2:0] Ext_Event7_Sync_Data_Out;
       wire       Ext_Event7_Sync_Data_Valid;
    
      generate if (C_EN_AXI_DEBUG == 0 && C_EN_EXT_EVENTS_FLAG == 1 && C_NUM_MONITOR_SLOTS > 7 && C_ENABLE_TRACE == 1) begin:GEN_SLOT7_EXT_TRACE
       assign Ext_Event7_Data_In = {ext_event_7_cnt_start,ext_event_7_cnt_stop,ext_event_7};
       // External Event3 through monitor FIFO
       axi_perf_mon_v5_0_12_mon_fifo
           #(
             .C_FAMILY                  (C_FAMILY),
             .C_REG_ALL_MONITOR_SIGNALS (C_REG_ALL_MONITOR_SIGNALS),
             .C_MON_FIFO_DATA_WIDTH     (3),
             .C_FIFO_ENABLE             (C_EXT_EVENT7_FIFO_ENABLE) 
            ) mon_fifo_ext_event7_inst
            (
             .Mon_clk                   (ext_clk_7),
             .Mon_rst_n                 (ext_rstn_7),
             .Data_In                   (Ext_Event7_Data_In),
             //.mon_en                    (Metrics_Cnt_En_sync),
             .CORE_ACLK                 (core_aclk),
             .CORE_ARESETN              (core_aresetn),
             .Sync_Data_Out             (Ext_Event7_Sync_Data_Out),
             .Sync_Data_Valid           (Ext_Event7_Sync_Data_Valid)
            );
        end
        else begin
          assign Ext_Event7_Sync_Data_Out = 0;
          assign Ext_Event7_Sync_Data_Valid = 0;
        end
    endgenerate

     generate if(C_NUM_MONITOR_SLOTS > 7 && C_ENABLE_TRACE == 1) begin:GEN_SLOT7_TRACE
       //Flag Generator instantiation for slot7
       axi_perf_mon_v5_0_12_flags_gen_trace
       #(
         .C_FAMILY                  (C_FAMILY),
         .C_MON_FIFO_DATA_WIDTH     (C_MON_FIFO_DWIDTH_S7), 
         .C_LOG_WIDTH               (C_SLOT_7_LOG_WIDTH),
         .C_FLAG_WIDTH              (C_SLOT_N_FLAG_WIDTH), 
         .C_AXI_ADDR_WIDTH          (C_SLOT_7_AXI_ADDR_WIDTH), 
         .C_AXI_DATA_WIDTH          (C_SLOT_7_AXI_DATA_WIDTH), 
         .C_AXI_ID_WIDTH            (C_SLOT_7_AXI_ID_WIDTH), 
         .C_AXI_PROTOCOL            (C_SLOT_7_AXI_PROTOCOL), 
         .C_SHOW_AXI_IDS            (C_SHOW_AXI_IDS),
         .C_SHOW_AXI_LEN            (C_SHOW_AXI_LEN),
         .C_EN_WR_ADD_FLAG          (C_EN_WR_ADD_FLAG), 
         .C_EN_FIRST_WRITE_FLAG     (C_EN_FIRST_WRITE_FLAG), 
         .C_EN_LAST_WRITE_FLAG      (C_EN_LAST_WRITE_FLAG), 
         .C_EN_RESPONSE_FLAG        (C_EN_RESPONSE_FLAG), 
         .C_EN_RD_ADD_FLAG          (C_EN_RD_ADD_FLAG), 
         .C_EN_FIRST_READ_FLAG      (C_EN_FIRST_READ_FLAG), 
         .C_EN_LAST_READ_FLAG       (C_EN_LAST_READ_FLAG), 
         .C_EN_EXT_EVENTS_FLAG      (C_EN_EXT_EVENTS_FLAG), 
         .C_EN_ALL_TRACE            (C_EN_ALL_TRACE), 
         .C_EN_AXI_DEBUG            (C_EN_AXI_DEBUG) 
        ) flags_generator_inst_7
        (
         .clk                       (core_aclk),
         .rst_n                     (core_aresetn),
         .Data_In                   (Slot_7_Sync_Data_Out),
         .Data_Valid                (Slot_7_Sync_Data_Valid), 
         .Ext_Trig                  (slot_7_ext_trig),
         .Ext_Trig_Stop             (slot_7_ext_trig_stop),
         .Use_Ext_Trig_Log          (Use_Ext_Trig_Log_sync),                 
         .Log_Data                  (Slot_7_Log),
         .Log_En                    (Slot_7_Log_En),
         .Ext_Data_in               (Ext_Event7_Sync_Data_Out),
         .Ext_Data_Valid            (Ext_Event7_Sync_Data_Valid),
         .Trace_Ctrl_bits           (Trace_ctrl_reg[31:28]),
         .Ext_Event_Flags           (Ext_Event7_Flags)
        );

      end
      else begin:GEN_SLOT7_NO_TRACE
        assign Slot_7_Log = 0;
        assign Slot_7_Log_En = 1'b0;
        assign Ext_Event7_Flags = 0;
      end
      endgenerate

    
   generate if(C_ENABLE_PROFILE ==  1) begin :GEN_METRIC_COUNT_PROFILE
   // Resets metric count through control register bit or through sampled interval  control register
   // When ever sample counter expires or when sample register is read 
   wire Metrics_Cnt_Reset_Final = Metrics_Cnt_Reset_sync | (Sample_Interval_Cnt_Lapse & Reset_On_Sample_Int_Lapse_sync)
                                  | (Lat_Sample_Reg & Reset_On_Sample_Int_Lapse_sync);
  

   //-- metric counters instantiation
     axi_perf_mon_v5_0_12_metric_counters_profile 
    #(
      .C_FAMILY                    (C_FAMILY            ),
      .C_NUM_MONITOR_SLOTS         (C_NUM_MONITOR_SLOTS ),
      .C_NUM_OF_COUNTERS           (C_NUM_OF_COUNTERS   ), 
      .C_NUM_OF_COUNTERS_EXTND     (C_NUM_OF_COUNTERS_EXTND), 
      .C_METRIC_COUNT_WIDTH        (C_METRIC_COUNT_WIDTH),
      .C_HAVE_SAMPLED_METRIC_CNT   (C_HAVE_SAMPLED_METRIC_CNT)
    ) metric_counters_inst
    (
      .clk                           (core_aclk ),
      .rst_n                         (core_aresetn),
      .Sample_rst_n                  (Sample_rst_n), 
      .Sample_En                     (Sample_En),
      .Lat_Addr_11downto2            (Lat_Addr_11downto2),
      .Wtrans_Cnt_En                 (Wtrans_Cnt_En),
      .Rtrans_Cnt_En                 (Rtrans_Cnt_En),
      .S0_Write_Byte_Cnt             (S0_Write_Byte_Cnt),
      .S1_Write_Byte_Cnt             (S1_Write_Byte_Cnt),
      .S2_Write_Byte_Cnt             (S2_Write_Byte_Cnt),
      .S3_Write_Byte_Cnt             (S3_Write_Byte_Cnt),
      .S4_Write_Byte_Cnt             (S4_Write_Byte_Cnt),
      .S5_Write_Byte_Cnt             (S5_Write_Byte_Cnt),
      .S6_Write_Byte_Cnt             (S6_Write_Byte_Cnt),
      .S7_Write_Byte_Cnt             (S7_Write_Byte_Cnt),
      .S0_Read_Byte_Cnt              (S0_Read_Byte_Cnt),
      .S1_Read_Byte_Cnt              (S1_Read_Byte_Cnt),
      .S2_Read_Byte_Cnt              (S2_Read_Byte_Cnt),
      .S3_Read_Byte_Cnt              (S3_Read_Byte_Cnt),
      .S4_Read_Byte_Cnt              (S4_Read_Byte_Cnt),
      .S5_Read_Byte_Cnt              (S5_Read_Byte_Cnt),
      .S6_Read_Byte_Cnt              (S6_Read_Byte_Cnt),
      .S7_Read_Byte_Cnt              (S7_Read_Byte_Cnt),
      .S0_Read_Byte_Cnt_En           (S0_Read_Byte_Cnt_En),
      .S1_Read_Byte_Cnt_En           (S1_Read_Byte_Cnt_En),
      .S2_Read_Byte_Cnt_En           (S2_Read_Byte_Cnt_En),
      .S3_Read_Byte_Cnt_En           (S3_Read_Byte_Cnt_En),
      .S4_Read_Byte_Cnt_En           (S4_Read_Byte_Cnt_En),
      .S5_Read_Byte_Cnt_En           (S5_Read_Byte_Cnt_En),
      .S6_Read_Byte_Cnt_En           (S6_Read_Byte_Cnt_En),
      .S7_Read_Byte_Cnt_En           (S7_Read_Byte_Cnt_En),
      .Write_Beat_Cnt_En             (Write_Beat_Cnt_En),
      .Read_Beat_Cnt_En              (Read_Beat_Cnt_En),
      .S0_Read_Latency               (S0_Read_Latency),
      .S1_Read_Latency               (S1_Read_Latency),
      .S2_Read_Latency               (S2_Read_Latency),
      .S3_Read_Latency               (S3_Read_Latency),
      .S4_Read_Latency               (S4_Read_Latency),
      .S5_Read_Latency               (S5_Read_Latency),
      .S6_Read_Latency               (S6_Read_Latency),
      .S7_Read_Latency               (S7_Read_Latency),
      .S0_Min_Read_Latency           (S0_Min_Read_Latency),
      .S1_Min_Read_Latency           (S1_Min_Read_Latency),
      .S2_Min_Read_Latency           (S2_Min_Read_Latency),
      .S3_Min_Read_Latency           (S3_Min_Read_Latency),
      .S4_Min_Read_Latency           (S4_Min_Read_Latency),
      .S5_Min_Read_Latency           (S5_Min_Read_Latency),
      .S6_Min_Read_Latency           (S6_Min_Read_Latency),
      .S7_Min_Read_Latency           (S7_Min_Read_Latency),
      .S0_Max_Read_Latency           (S0_Max_Read_Latency),
      .S1_Max_Read_Latency           (S1_Max_Read_Latency),
      .S2_Max_Read_Latency           (S2_Max_Read_Latency),
      .S3_Max_Read_Latency           (S3_Max_Read_Latency),
      .S4_Max_Read_Latency           (S4_Max_Read_Latency),
      .S5_Max_Read_Latency           (S5_Max_Read_Latency),
      .S6_Max_Read_Latency           (S6_Max_Read_Latency),
      .S7_Max_Read_Latency           (S7_Max_Read_Latency),
      .S0_Write_Latency              (S0_Write_Latency),
      .S1_Write_Latency              (S1_Write_Latency),
      .S2_Write_Latency              (S2_Write_Latency),
      .S3_Write_Latency              (S3_Write_Latency),
      .S4_Write_Latency              (S4_Write_Latency),
      .S5_Write_Latency              (S5_Write_Latency),
      .S6_Write_Latency              (S6_Write_Latency),
      .S7_Write_Latency              (S7_Write_Latency),
      .S0_Min_Write_Latency          (S0_Min_Write_Latency),
      .S1_Min_Write_Latency          (S1_Min_Write_Latency),
      .S2_Min_Write_Latency          (S2_Min_Write_Latency),
      .S3_Min_Write_Latency          (S3_Min_Write_Latency),
      .S4_Min_Write_Latency          (S4_Min_Write_Latency),
      .S5_Min_Write_Latency          (S5_Min_Write_Latency),
      .S6_Min_Write_Latency          (S6_Min_Write_Latency),
      .S7_Min_Write_Latency          (S7_Min_Write_Latency),
      .S0_Max_Write_Latency          (S0_Max_Write_Latency),
      .S1_Max_Write_Latency          (S1_Max_Write_Latency),
      .S2_Max_Write_Latency          (S2_Max_Write_Latency),
      .S3_Max_Write_Latency          (S3_Max_Write_Latency),
      .S4_Max_Write_Latency          (S4_Max_Write_Latency),
      .S5_Max_Write_Latency          (S5_Max_Write_Latency),
      .S6_Max_Write_Latency          (S6_Max_Write_Latency),
      .S7_Max_Write_Latency          (S7_Max_Write_Latency),
      .Read_Latency_En               (Read_Latency_En),    
      .Write_Latency_En              (Write_Latency_En),   
      .Metrics_Cnt_En                (Metrics_Cnt_En_sync),
      .Metrics_Cnt_Reset             (Metrics_Cnt_Reset_Final),
      .Metric_Ram_Data_In            (Metric_Ram_Data_In) 
    );

    end
    else begin: GEN_NO_METRIC_CNT_PROFILE
      assign Metric_Ram_Data_In = 0;
    end
    endgenerate


  //-- synchronizing Interval_Cnt_En and Interval_Cnt_Ld and reset to metric counters
    generate    
    if (C_AXI4LITE_CORE_CLK_ASYNC == 1 && C_ENABLE_PROFILE ==  1) begin : GEN_INTERVAL_CNT_SYNC
      // Synchronizing external trigger
      //-- Double Flop synchronization
      axi_perf_mon_v5_0_12_cdc_sync
      #(
         .c_cdc_type      (1             ),   
         .c_flop_input    (0             ),  
         .c_reset_state   (1             ),  
         .c_single_bit    (0             ),  
         .c_vector_width  (3             ),  
         .c_mtbf_stages   (4             )  
       )sample_interval_cnt_cdc_sync 
       (
         .prmry_aclk      (s_axi_aclk                                                              ),
         .prmry_rst_n     (s_axi_aresetn                                                           ),
         .prmry_in        (1'b0                                                                    ),
         .prmry_vect_in   ({Reset_On_Sample_Int_Lapse,Interval_Cnt_Ld, Interval_Cnt_En}            ),
         .scndry_aclk     (core_aclk                                                               ),
         .scndry_rst_n    (core_aresetn                                                            ),
         .prmry_ack       (                                                                        ),
         .scndry_out      (                                                                        ),
         .scndry_vect_out ({Reset_On_Sample_Int_Lapse_sync,Interval_Cnt_Ld_sync, Interval_Cnt_En_sync}) 
        );
    end 
    else begin : GEN_INTERVAL_CNT_NO_SYNC
        assign Interval_Cnt_Ld_sync           = Interval_Cnt_Ld;
        assign Interval_Cnt_En_sync           = Interval_Cnt_En;
        assign Reset_On_Sample_Int_Lapse_sync = Reset_On_Sample_Int_Lapse;
    end 
    endgenerate 
     
   wire Interval_Cnt_En_i  = Interval_Cnt_En_sync & Metrics_Cnt_En_sync;

   //-- Sample Interval Counter
   generate
   if(C_HAVE_SAMPLED_METRIC_CNT == 1) begin :GEN_SAMPLE_METRIC_CNT
       axi_perf_mon_v5_0_12_samp_intl_cnt
       #(
             .C_FAMILY                      (C_FAMILY),
             .C_METRICS_SAMPLE_COUNT_WIDTH  (C_METRICS_SAMPLE_COUNT_WIDTH)
        ) sample_interval_counter_inst
        (
             .clk                       (core_aclk     ),
             .rst_n                     (core_aresetn  ),
             .Interval_Cnt_En           (Interval_Cnt_En_i  ),
             .Interval_Cnt_Ld           (Interval_Cnt_Ld_sync  ),
             .Interval_Cnt_Ld_Val       (Sample_Interval  ),
             .Sample_Interval_Cnt       (Sample_Interval_Cnt  ),
             .Sample_Interval_Cnt_Lapse (Sample_Interval_Cnt_Lapse) 
        );
    
   end
   else begin :GEN_NO_SAMPLE_METRIC_CNT
       assign Sample_Interval_Cnt_Lapse = 1'b0;

   end
   endgenerate

   //-- Streaming FIFO Logic in Trace mode
   generate if(C_ENABLE_TRACE == 1) begin:GEN_TRACE_LOG

        axi_perf_mon_v5_0_12_strm_fifo_wr_logic
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_NUM_MONITOR_SLOTS       (C_NUM_MONITOR_SLOTS),
           .C_SW_SYNC_DATA_WIDTH      (C_SW_SYNC_DATA_WIDTH),
           .C_SLOT_0_LOG_WIDTH        (C_SLOT_0_LOG_WIDTH+log_wid_mark), 
           .C_SLOT_1_LOG_WIDTH        (C_SLOT_1_LOG_WIDTH+log_wid_mark), 
           .C_SLOT_2_LOG_WIDTH        (C_SLOT_2_LOG_WIDTH+log_wid_mark), 
           .C_SLOT_3_LOG_WIDTH        (C_SLOT_3_LOG_WIDTH+log_wid_mark), 
           .C_SLOT_4_LOG_WIDTH        (C_SLOT_4_LOG_WIDTH+log_wid_mark), 
           .C_SLOT_5_LOG_WIDTH        (C_SLOT_5_LOG_WIDTH+log_wid_mark), 
           .C_SLOT_6_LOG_WIDTH        (C_SLOT_6_LOG_WIDTH), 
           .C_SLOT_7_LOG_WIDTH        (C_SLOT_7_LOG_WIDTH), 
           .C_FIFO_AXIS_TDATA_WIDTH   (C_FIFO_AXIS_TDATA_WIDTH),
           .C_EN_AXI_DEBUG            (C_EN_AXI_DEBUG),
           //.C_EN_ALL_TRACE            (C_EN_ALL_TRACE), 
           .C_EN_TRIGGER              (C_EN_TRIGGER)
          ) streaming_fifo_write_logic_inst
          (
           .clk                       (core_aclk),
           .rst_n                     (core_aresetn),
           .Event_Log_En              (Event_Log_En_sync),
           .Slot_0_Log                (Slot_0_Log_Marked),
           .Slot_0_Log_En             (Slot_0_Log_En_Marked),
           .Slot_1_Log                (Slot_1_Log_Marked),
           .Slot_1_Log_En             (Slot_1_Log_En_Marked),
           .Slot_2_Log                (Slot_2_Log_Marked),
           .Slot_2_Log_En             (Slot_2_Log_En_Marked),
           .Slot_3_Log                (Slot_3_Log_Marked),
           .Slot_3_Log_En             (Slot_3_Log_En_Marked),
           .Slot_4_Log                (Slot_4_Log_Marked),
           .Slot_4_Log_En             (Slot_4_Log_En_Marked),
           .Slot_5_Log                (Slot_5_Log_Marked),
           .Slot_5_Log_En             (Slot_5_Log_En_Marked),
           .Slot_6_Log                (Slot_6_Log),
           .Slot_6_Log_En             (Slot_6_Log_En),
           .Slot_7_Log                (Slot_7_Log),
           .Slot_7_Log_En             (Slot_7_Log_En),
           .SW_Data_Log_En            (SW_Data_Log_En ),
           .SW_Data                   (SW_Data        ),
           .SW_Data_Wr_En             (SW_Data_Wr_En  ),
           .Ext_Event0_Flags          (Ext_Event0_Flags),
           .Ext_Event1_Flags          (Ext_Event1_Flags),
           .Ext_Event2_Flags          (Ext_Event2_Flags),
           .Ext_Event3_Flags          (Ext_Event3_Flags),
           .Ext_Event4_Flags          (Ext_Event4_Flags),
           .Ext_Event5_Flags          (Ext_Event5_Flags),
           .Ext_Event6_Flags          (Ext_Event6_Flags),
           .Ext_Event7_Flags          (Ext_Event7_Flags),
           .Fifo_Full                 (Streaming_Fifo_Full   ),
           .Fifo_Empty                (Streaming_Fifo_Empty  ),
           .Fifo_Wr_En                (Streaming_Fifo_Wr_En  ),
           //.Trace_Ctrl_reg_bits       (Trace_ctrl_reg),
           .Fifo_Wr_Data              (Streaming_Fifo_Wr_Data),
           .trigger                   (trigger)
          );

         assign stream_fifo_rst_n = ~(Streaming_FIFO_Reset_sync) & core_aresetn;

         // Sync/ Async streaming FIFO
         axi_perf_mon_v5_0_12_async_stream_fifo
         #(
           .C_FAMILY                  (C_FAMILY),
           .C_FIFO_DEPTH              (C_FIFO_AXIS_DEPTH),
           .C_DATA_WIDTH              (C_FIFO_AXIS_TDATA_WIDTH),
           .C_AXIS_DWIDTH_ROUND_TO_32 (C_AXIS_DWIDTH_ROUND_TO_32),
           .C_USE_BLOCKMEM            (1),                   // 1 Use bram
           .C_COMMON_CLOCK            (C_FIFO_AXIS_SYNC),    //1 sync fifo 0 async fifo
           .C_LOG_DATA_OFFLD          (C_LOG_DATA_OFFLD)  ,
           .S_AXI_OFFLD_ID_WIDTH      (S_AXI_OFFLD_ID_WIDTH),
           .C_EN_TRIGGER              (C_EN_TRIGGER)  
          ) async_stream_fifo_inst
          (
           .Wr_clk                    (core_aclk),
           .Wr_rst_n                  (stream_fifo_rst_n),
           .fifo_wr_en                (Streaming_Fifo_Wr_En),
           .eventlog_cur_cnt          (eventlog_cur_cnt),
           .fifo_full_out             (Streaming_Fifo_Full),
           .fifo_empty_out            (Streaming_Fifo_Empty),
           .Fifo_Data_In              (Streaming_Fifo_Wr_Data),
           .m_axis_aclk               (m_axis_aclk),
           .m_axis_aresetn            (m_axis_aresetn),
           .m_axis_tvalid             (m_axis_tvalid),
           .m_axis_tready             (m_axis_tready),
           .m_axis_tdata              (m_axis_tdata),
           .s_axi_offld_aclk          (s_axi_offld_aclk    ),
           .s_axi_offld_aresetn       (s_axi_offld_aresetn ),
           .s_axi_offld_araddr        (s_axi_offld_araddr  ),
           .s_axi_offld_arvalid       (s_axi_offld_arvalid ),
           .s_axi_offld_arlen         (s_axi_offld_arlen   ),
           .s_axi_offld_arid          (s_axi_offld_arid    ),
           .s_axi_offld_arready       (s_axi_offld_arready ),
           .s_axi_offld_rready        (s_axi_offld_rready  ),
           .s_axi_offld_rdata         (s_axi_offld_rdata   ),
           .s_axi_offld_rresp         (s_axi_offld_rresp   ),
           .s_axi_offld_rvalid        (s_axi_offld_rvalid  ),
           .s_axi_offld_rid           (s_axi_offld_rid     ),
           .s_axi_offld_rlast         (s_axi_offld_rlast   ),
           .trigger                   (trigger) 
          );
         assign m_axis_tstrb = { {(C_FIFO_AXIS_TDATA_WIDTH/8){1'b1}} } ;
         assign m_axis_tid = 0;

        //-- Edge detection of fifo full
          always @(posedge core_aclk) begin
              if (core_aresetn == RST_ACTIVE) begin
                  Streaming_Fifo_Full_D1 <= 1'b0;
              end
              else begin
                  Streaming_Fifo_Full_D1 <= Streaming_Fifo_Full;
              end
          end
       
          assign Streaming_Fifo_Full_Edge = Streaming_Fifo_Full & (!Streaming_Fifo_Full_D1);

     end
     else begin :GEN_NO_TRACE_LOG
         assign m_axis_tdata  = 0;
         assign m_axis_tvalid = 0;
         assign m_axis_tstrb = 0;
         assign m_axis_tid = 0;
         assign Streaming_Fifo_Full_Edge = 0;
     end
     endgenerate 
  

endmodule


//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename:       axi_perf_mon_v5_0_12_acc_sample_profile.v
// Version :       v5.0
// Description:    Accumulator module accumulates metrics and samples
//                 into sampled metric counter if sampling trigger is set
// Verilog-Standard:verilog-2001
//---------------------------------------------------------------------------
// Structure:   
// --  axi_perf_mon_v5_0_12_top.v
// --  axi_perf_mon_v5_0_12_profile.v
//        \-- axi_perf_mon_v5_0_12_metric_counters_profile.v
//          \--axi_perf_mon_v5_0_12_acc_sample_profile.v
//-----------------------------------------------------------------------------
// Author:     NLR 
// History:
// NLR     02/10/2013      First Version
// ^^^^^^
//-----------------------------------------------------------------------------
`timescale 1ns/1ps
(* DowngradeIPIdentifiedWarnings="yes" *)

module axi_perf_mon_v5_0_12_acc_sample_profile 
#(
   parameter                  C_FAMILY                   = "nofamily",
   parameter                  DWIDTH                     = 32,
   parameter                  C_HAVE_SAMPLED_METRIC_CNT  = 1
)
(
   input                      clk,
   input                      rst_n,
   input                      Sample_rst_n,

   input                      Enable,   
   input                      Reset,   

   input  [(DWIDTH - 1):0]    Add_in,  
   input                      Add_in_Valid,  
   input                      Accumulate, 
   input                      Sample_En,
   output [(DWIDTH - 1):0]    Accumulator,  
   output [(DWIDTH - 1):0]    Sample_Accumulator  
);



//-------------------------------------------------------------------
// Parameter Declaration
//-------------------------------------------------------------------
localparam RST_ACTIVE = 1'b0;

//-------------------------------------------------------------------
// Signal Declaration
//-------------------------------------------------------------------
reg [DWIDTH:0]           Accum_i;  
reg [DWIDTH-1:0]         Samp_Metric_Cnt;  

//-------------------------------------------------------------------
// Begin architecture
//-------------------------------------------------------------------

//-- Accumulator
always @(posedge clk) begin 
   if (rst_n == RST_ACTIVE) begin
       Accum_i <= 0;
   end
   else begin
       if (Reset == 1'b1) begin
           Accum_i <= 0;
       end
       else if (Enable == 1'b1 && Add_in_Valid == 1'b1 && Accumulate == 1'b1) begin
           Accum_i <= Accum_i + {1'b0, Add_in};
       end
       else if (Enable == 1'b1 && Add_in_Valid == 1'b1) begin
           Accum_i <= Add_in ;
       end
       else begin
           Accum_i <= Accum_i;
       end
   end
end 

   assign Accumulator = Accum_i[DWIDTH -1:0];
   assign Overflow    = Accum_i[DWIDTH] ;

//-- Sampled Metric Counter
generate
if (C_HAVE_SAMPLED_METRIC_CNT == 1)  begin : GEN_SAMPLE_METRIC_CNT
    always @(posedge clk) begin 
       if (rst_n == RST_ACTIVE) begin
           Samp_Metric_Cnt  <= 0;
       end
       else begin
           if (Sample_rst_n == RST_ACTIVE) begin
             Samp_Metric_Cnt  <= 0;
           end
           else if (Sample_En == 1'b1) begin
             Samp_Metric_Cnt  <= Accum_i[DWIDTH -1:0];
           end
           else begin
             Samp_Metric_Cnt  <= Samp_Metric_Cnt;
           end
       end
    end 
    assign Sample_Accumulator = Samp_Metric_Cnt;
end    
else begin : GEN_NO_SAMPLE_METRIC_CNT
    assign Sample_Accumulator = 0;
end
endgenerate



endmodule








//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename     : axi_perf_mon_v5_0_12_register_module_profile.v
// Version      : v5.0
// Description  : register module having all the registers of axi performance
//                monitor read and write logic. Address decoding is also
//                implemented in this module based on which the corresponding 
//                read and write enables being generated
// Verilog-Standard:verilog-2001  
//-----------------------------------------------------------------------------
// Structure:   
//
//  axi_perf_mon_v5_0_12_top.v
//      \-- axi_perf_mon_v5_0_12_register_module_profile.v
//
//-----------------------------------------------------------------------------
// Author :   NLR 
// History: 
// NLR       10/02/2013      First Version   
// ~~~~~~
//-----------------------------------------------------------------------------
`timescale 1ns/1ps
(* DowngradeIPIdentifiedWarnings="yes" *)

module axi_perf_mon_v5_0_12_register_module_profile 
#(
   parameter                              C_FAMILY                     = "virtex7",
   // AXI port dependant parameters
   parameter                              C_S_AXI_ADDR_WIDTH           = 32,
   parameter                              C_S_AXI_DATA_WIDTH           = 32,

   parameter                              C_NUM_MONITOR_SLOTS          = 1,
   parameter                              C_NUM_OF_COUNTERS            = 6,
   parameter                              C_NUM_INTR_INPUTS            = 2,
   parameter                              C_ENABLE_PROFILE             = 1,  //-- enables/disables perf mon counting logic
   parameter                              C_ENABLE_TRACE               = 0,  //-- enables/disables perf mon log logic
   parameter                              C_EN_ALL_TRACE               = 0,  //-- enables/disables perf mon log logic
   parameter                              C_METRICS_SAMPLE_COUNT_WIDTH = 32,
   parameter                              C_SW_SYNC_DATA_WIDTH         = 32,  //-- Width of SW data register
   parameter                              C_AXIS_DWIDTH_ROUND_TO_32    = 64, // AXI Streaming FIFO width rounded to next 32bit
   parameter                              C_AXI4LITE_CORE_CLK_ASYNC    = 1   //-- disable synchronizers incase its 0 
)
(
   input                                             S_AXI_ACLK,
   input                                             S_AXI_ARESETN,

   // Controls to the IP/IPIF modules
   input [(C_S_AXI_ADDR_WIDTH - 1):0]                Bus2IP_Addr,  
   input [(C_S_AXI_DATA_WIDTH - 1):0]                Bus2IP_Data,    
   input [((C_S_AXI_DATA_WIDTH / 8)-1):0]            Bus2IP_BE, 
   input                                             Bus2IP_Burst,   
   input                                             Bus2IP_RdCE,   
   input                                             Bus2IP_WrCE,   
   output reg [(C_S_AXI_DATA_WIDTH - 1):0]           IP2Bus_Data, 
   output reg                                        IP2Bus_DataValid,
   output                                            IP2Bus_Error,

   input                                             CORE_ACLK,
   input                                             CORE_ARESETN,

   // Metric Counters - in core clk domain
   input [31:0]                                      Metric_Ram_Data_In,    

   // Sample Interval Register - in axi clk domain
   output [(C_METRICS_SAMPLE_COUNT_WIDTH - 1):0]     Sample_Interval,    

   // Sample Interval Control Register - in axi clk domain
   output                                            Interval_Cnt_En,
   output                                            Interval_Cnt_Ld,
   output                                            Reset_On_Sample_Int_Lapse,

   // Interrupt Register Enables - in axi clk domain
   output reg                                        Global_Intr_En,
   output                                            Intr_Reg_IER_Wr_En,
   output                                            Intr_Reg_ISR_Wr_En,

   // Interrupt Registers - in axi clk domain
   input [(C_NUM_INTR_INPUTS - 1):0]                 Intr_Reg_IER,    
   input [(C_NUM_INTR_INPUTS - 1):0]                 Intr_Reg_ISR,    
   //Stream FIFO:
   //fifo_rd_en in axi-mm/axis clock domain 
   //fifo_wr_en in core clock domain 
   input                                             fifo_rd_en,
   input                                             fifo_wr_en,
   //rd: clk,rst will be either stream/aximm 
   //wr: clk,rst will be core_aclk
   input                                             eventlog_rd_clk ,
   input                                             eventlog_rd_rstn,
   input [31:0]                                      eventlog_cur_cnt,

   output  [C_SW_SYNC_DATA_WIDTH-1:0]                SW_Data,    
   output                                            SW_Data_Wr_En,    

   // Control Register - in axi clk domain
   output reg                                        Streaming_FIFO_Reset,
   output reg                                        Event_Log_En,
   output reg                                        Metrics_Cnt_En,
   output reg                                        Metrics_Cnt_Reset,
   output reg                                        Use_Ext_Trigger,
   output reg                                        Use_Ext_Trigger_Log,
   // Flag enable register - in core clk domain
   output                                            Lat_Sample_Reg,
   output                                            Wr_Lat_Start,
   output                                            Wr_Lat_End,
   output                                            Rd_Lat_Start,
   output                                            Rd_Lat_End,
   output reg [31:0]                                 Trace_ctrl_reg,
   output [9:0]                                      Lat_Addr_11downto2
);


//-------------------------------------------------------------------
// Parameter Declaration
//-------------------------------------------------------------------
localparam RST_ACTIVE = 1'b0;
localparam TIME_DIFF_LOAD_VALUE = 32'h0001;

//-------------------------------------------------------------------
// Metric count ram declaration
//-------------------------------------------------------------------
//(* ram_style = "block" *) reg [31:0] Metric_ram_CDCR [255:0];
 reg [31:0]                       Metric_ram_CDCR [1023:0];
 reg [9:0]                        Lat_Addr_11downto2_CDC;
 wire [31:0]                      Metric_ram_Out;
 wire [C_NUM_INTR_INPUTS-1:0]     Intr_Reg_IER_Int;

// Signal and Register Declaration-PR#741428
  wire [31:0] sync_eventlog_cur_cnt;


//-------------------------------------------------------------------
// Signal and Register Declaration
//-------------------------------------------------------------------
wire                                Rd_En_sync;
wire                                RValid;
wire [31:0]                         Sample_Interval_i;    

reg  [C_S_AXI_DATA_WIDTH-1:0]       IP2Bus_Data_Int;
reg                                 Lat_Addr_7downto4_is_0x0    ; 
reg                                 Lat_Addr_7downto4_is_0x1    ; 
reg                                 Lat_Addr_7downto4_is_0x2    ; 
reg                                 Lat_Addr_7downto4_is_0x3    ; 
reg                                 Lat_Addr_7downto4_is_0x4    ; 
reg                                 Lat_Addr_7downto4_is_0x5    ; 
reg                                 Lat_Addr_7downto4_is_0x6    ; 
reg                                 Lat_Addr_7downto4_is_0x7    ; 
reg                                 Lat_Addr_7downto4_is_0x8    ; 
reg                                 Lat_Addr_7downto4_is_0x9    ; 
reg                                 Lat_Addr_3downto0_is_0x0;
reg                                 Lat_Addr_3downto0_is_0x4;
reg                                 Lat_Addr_3downto0_is_0x8;
reg                                 Lat_Addr_3downto0_is_0xC;
reg                                 Lat_Control_Set_Rd_En       ; 
reg                                 Lat_Trace_Filter_Rd_En       ; 
reg                                 Lat_Sample_Interval_Rd_En   ; 
reg                                 Lat_Intr_Reg_Set_Rd_En      ; 
reg                                 Lat_Intr_Reg_GIE_Rd_En      ; 
reg                                 Lat_Intr_Reg_IER_Rd_En      ; 
reg                                 Lat_Intr_Reg_ISR_Rd_En      ; 
reg                                 Lat_Status_Reg_Set_Rd_En  ; 
reg                                 Lat_Status_Reg_FOC_Rd_En  ; 
reg                                 Lat_Status_Reg_WIF_Rd_En  ; 
reg                                 Lat_Sel_Reg_Set_Rd_En       ; 
reg                                 Lat_Metric_Cnt_Reg_Set_Rd_En; 
reg                                 Lat_Samp_Metric_Cnt_Reg_Set_Rd_En; 
reg                                 Lat_Event_Log_Set_Rd_En     ; 

reg                                 Lat_Enlog_Reg_Set_Rd_En;
reg                                 Lat_Sample_Reg_Rd_En;
reg                                 Lat_Sample_Reg_Rd_En_d3;
reg                                 Lat_Sample_Reg_Rd_En_d1;
wire                                Lat_Sample_Reg_Rd_En_d2;

wire                               SW_Data_Wr_En_int;
reg [31:0]                         Sample_Interval_i_reg_CDC;
// latency start and end points
reg                                Wr_Lat_Start_CDC;
reg                                Wr_Lat_End_CDC;
reg                                Rd_Lat_Start_CDC;
reg                                Rd_Lat_End_CDC;
//Sample register read interval counter enable 
reg  [31:0]                        Sample_Time_Diff_Reg;  
wire [31:0]                        Sample_Time_Diff_Reg_int;  
reg                                Sample_Reg_Rd_First;  
wire [31:0]                        Sample_Time_Diff;  
wire                               prmry_ack2;  
wire                               prmry_ack3;  
wire                               prmry_ack4;  
wire                               prmry_ack5;  
wire                               scndry_out1;  
wire                               scndry_vect_out2;  
wire                               scndry_vect_out3;  
wire                               scndry_vect_out4;  
wire [31:0]                        Control_Reg;
reg                                Interval_Cnt_En_int;
reg                                Interval_Cnt_Ld_int;
reg                                Reset_On_Sample_Int_Lapse_int;
//-------------------------------------------------------------------
// Begin architecture
//-------------------------------------------------------------------
assign IP2Bus_Error = 0;      // No error conditions hence tieng off the error signal to 0 
wire Addr_15downto8_is_0x00 = (Bus2IP_Addr[15:8] == 8'h00) ? 1'b1 : 1'b0;
wire Addr_15downto8_is_0x01 = (Bus2IP_Addr[15:8] == 8'h01) ? 1'b1 : 1'b0;
wire Addr_15downto8_is_0x02 = (Bus2IP_Addr[15:8] == 8'h02) ? 1'b1 : 1'b0;
wire Addr_15downto8_is_0x03 = (Bus2IP_Addr[15:8] == 8'h03) ? 1'b1 : 1'b0;
wire Addr_15downto8_is_0x04 = (Bus2IP_Addr[15:8] == 8'h04) ? 1'b1 : 1'b0;
wire Addr_15downto8_is_0x05 = (Bus2IP_Addr[15:8] == 8'h05) ? 1'b1 : 1'b0;
wire Addr_15downto8_is_0x06 = (Bus2IP_Addr[15:8] == 8'h06) ? 1'b1 : 1'b0;
wire Addr_15downto8_is_0x07 = (Bus2IP_Addr[15:8] == 8'h07) ? 1'b1 : 1'b0;
wire Addr_15downto8_is_0x08 = (Bus2IP_Addr[15:8] == 8'h08) ? 1'b1 : 1'b0;
wire Addr_15downto8_is_0x09 = (Bus2IP_Addr[15:8] == 8'h09) ? 1'b1 : 1'b0;
wire Addr_15downto8_is_0x0A = (Bus2IP_Addr[15:8] == 8'h0A) ? 1'b1 : 1'b0;


wire Addr_7downto0_is_0x00  = (Bus2IP_Addr[7:0] == 8'h00) ? 1'b1 : 1'b0;
wire Addr_7downto0_is_0x04  = (Bus2IP_Addr[7:0] == 8'h04) ? 1'b1 : 1'b0;
wire Addr_7downto0_is_0x08  = (Bus2IP_Addr[7:0] == 8'h08) ? 1'b1 : 1'b0;

wire Addr_7downto4_is_0x0   = (Bus2IP_Addr[7:4] == 4'h0) ? 1'b1 : 1'b0;
wire Addr_7downto4_is_0x1   = (Bus2IP_Addr[7:4] == 4'h1) ? 1'b1 : 1'b0;
wire Addr_7downto4_is_0x2   = (Bus2IP_Addr[7:4] == 4'h2) ? 1'b1 : 1'b0;
wire Addr_7downto4_is_0x3   = (Bus2IP_Addr[7:4] == 4'h3) ? 1'b1 : 1'b0;
wire Addr_7downto4_is_0x4   = (Bus2IP_Addr[7:4] == 4'h4) ? 1'b1 : 1'b0;
wire Addr_7downto4_is_0x5   = (Bus2IP_Addr[7:4] == 4'h5) ? 1'b1 : 1'b0;
wire Addr_7downto4_is_0x6   = (Bus2IP_Addr[7:4] == 4'h6) ? 1'b1 : 1'b0;
wire Addr_7downto4_is_0x7   = (Bus2IP_Addr[7:4] == 4'h7) ? 1'b1 : 1'b0;
wire Addr_7downto4_is_0x8   = (Bus2IP_Addr[7:4] == 4'h8) ? 1'b1 : 1'b0;
wire Addr_7downto4_is_0x9   = (Bus2IP_Addr[7:4] == 4'h9) ? 1'b1 : 1'b0;
wire Addr_7downto4_is_0xb   = (Bus2IP_Addr[7:4] == 4'hb) ? 1'b1 : 1'b0;

wire Addr_3downto0_is_0x0   = (Bus2IP_Addr[3:0] == 4'h0) ? 1'b1 : 1'b0;
wire Addr_3downto0_is_0x4   = (Bus2IP_Addr[3:0] == 4'h4) ? 1'b1 : 1'b0;
wire Addr_3downto0_is_0x8   = (Bus2IP_Addr[3:0] == 4'h8) ? 1'b1 : 1'b0;
wire Addr_3downto0_is_0xC   = (Bus2IP_Addr[3:0] == 4'hC) ? 1'b1 : 1'b0;


wire Metric_Cnt_Rd_Add       = Addr_15downto8_is_0x01 || Addr_15downto8_is_0x05 || 
                               Addr_15downto8_is_0x07 || Addr_15downto8_is_0x09;
wire Sample_Metric_Cnt_Rd_Add = Addr_15downto8_is_0x02 || Addr_15downto8_is_0x06 || 
                                Addr_15downto8_is_0x08 || Addr_15downto8_is_0x0A;

wire min_max_latency_add =  Addr_7downto4_is_0x5 | Addr_7downto4_is_0xb;
wire Metric_Cnt_Rd_Add_extnd         = Metric_Cnt_Rd_Add & min_max_latency_add;
wire Sample_Metric_Cnt_Rd_Add_extnd  = Sample_Metric_Cnt_Rd_Add & min_max_latency_add;

//-------------------------------------------------------------------------------
//-- Write enables and read enables generation
//-------------------------------------------------------------------------------
//-- Write enable for Trace filtering Register 0x408
wire Trace_Filter_Wr_En = (C_EN_ALL_TRACE == 1) ?(Bus2IP_WrCE && Addr_15downto8_is_0x04 && Addr_7downto0_is_0x08):1'b0;
//-- Read enable for Trace filtering Register 0x408
wire Trace_Filter_Rd_En = (C_EN_ALL_TRACE == 1) ?(Bus2IP_RdCE && Addr_15downto8_is_0x04 && Addr_7downto0_is_0x08):1'b0;


//-- Write enable for Control Register
wire Control_Set_Wr_En = Bus2IP_WrCE && Addr_15downto8_is_0x03 && Addr_7downto0_is_0x00;

//-- Read enable for Control Register
wire Control_Set_Rd_En = Bus2IP_RdCE && Addr_15downto8_is_0x03 && Addr_7downto0_is_0x00;

//-- Write enable for Sample Interval Registers
wire Sample_Interval_Wr_En = Bus2IP_WrCE && Addr_15downto8_is_0x00 && Addr_7downto4_is_0x2;

//-- Read enable for Sample Interval Registers
wire Sample_Interval_Rd_En = Bus2IP_RdCE && Addr_15downto8_is_0x00 && Addr_7downto4_is_0x2;
wire Sample_Reg_Rd_En = Bus2IP_RdCE && Addr_15downto8_is_0x00 && Addr_7downto4_is_0x2 && Addr_3downto0_is_0xC;

//-- Write enables for Interrupt Registers
wire Intr_Reg_Set_Wr_En = Bus2IP_WrCE && Addr_15downto8_is_0x00 && Addr_7downto4_is_0x3;
wire Intr_Reg_GIE_Wr_En = Intr_Reg_Set_Wr_En && Addr_3downto0_is_0x0;
assign Intr_Reg_IER_Wr_En = Intr_Reg_Set_Wr_En && Addr_3downto0_is_0x4;
assign Intr_Reg_ISR_Wr_En = Intr_Reg_Set_Wr_En && Addr_3downto0_is_0x8;

//-- Read enables for Interrupt Registers
wire Intr_Reg_Set_Rd_En = Bus2IP_RdCE && Addr_15downto8_is_0x00 && Addr_7downto4_is_0x3;
wire Intr_Reg_GIE_Rd_En = Intr_Reg_Set_Rd_En && Addr_3downto0_is_0x0;
wire Intr_Reg_IER_Rd_En = Intr_Reg_Set_Rd_En && Addr_3downto0_is_0x4;
wire Intr_Reg_ISR_Rd_En = Intr_Reg_Set_Rd_En && Addr_3downto0_is_0x8;

//-- Write enables for status Registers
//  -- 0x0:FOC: Fifo Occupancy 
//  -- 0x4:WIF: Words in FIFO.
wire Status_Reg_Set_Wr_En = Bus2IP_WrCE && Addr_15downto8_is_0x00 && Addr_7downto4_is_0x5;
wire Status_Reg_FOC_Wr_En = Status_Reg_Set_Wr_En && Addr_3downto0_is_0x0;
//-- Read enables for status Registers
wire Status_Reg_Set_Rd_En = Bus2IP_RdCE && Addr_15downto8_is_0x00 && Addr_7downto4_is_0x5;
wire Status_Reg_FOC_Rd_En = Status_Reg_Set_Rd_En && Addr_3downto0_is_0x0;
wire Status_Reg_WIF_Rd_En = Status_Reg_Set_Rd_En && Addr_3downto0_is_0x4;


//-- Read enables for Metric Cnt Registers
wire Metric_Cnt_Reg_Set_Rd_En  = Bus2IP_RdCE && ((Metric_Cnt_Rd_Add && Addr_3downto0_is_0x0) |(Metric_Cnt_Rd_Add_extnd));

//-- Read enables for Sampled Metric Cnt Registers
wire Samp_Metric_Cnt_Reg_Set_Rd_En  = Bus2IP_RdCE && ((Sample_Metric_Cnt_Rd_Add && Addr_3downto0_is_0x0)| (Sample_Metric_Cnt_Rd_Add_extnd));

//-- Write enable for Event Log Registers
wire Event_Log_Set_Wr_En    = Bus2IP_WrCE && Addr_15downto8_is_0x04 && Addr_7downto0_is_0x04;

//-- Read enable for Event Log Registers
wire Event_Log_Set_Rd_En    = Bus2IP_RdCE && Addr_15downto8_is_0x04 && Addr_7downto0_is_0x04;

//-- Control Register
always @(posedge S_AXI_ACLK) begin 
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       Metrics_Cnt_En        <= 1'b0;
       Metrics_Cnt_Reset     <= 1'b0;
       Event_Log_En          <= 1'b0;
       Streaming_FIFO_Reset  <= 1'b0;
       Use_Ext_Trigger       <= 1'b0;
       Use_Ext_Trigger_Log   <= 1'b0;
       Wr_Lat_Start_CDC      <= 1'b0;
       Wr_Lat_End_CDC        <= 1'b0;
       Rd_Lat_Start_CDC      <= 1'b0;
       Rd_Lat_End_CDC        <= 1'b0;
   end
   else begin 
       if (Control_Set_Wr_En == 1'b1) begin
           Metrics_Cnt_En        <= Bus2IP_Data[0];
           Metrics_Cnt_Reset     <= Bus2IP_Data[1];
           Use_Ext_Trigger       <= Bus2IP_Data[2];
           Wr_Lat_Start_CDC      <= Bus2IP_Data[4];
           Wr_Lat_End_CDC        <= Bus2IP_Data[5];
           Rd_Lat_Start_CDC      <= Bus2IP_Data[6];
           Rd_Lat_End_CDC        <= Bus2IP_Data[7];
           Event_Log_En          <= Bus2IP_Data[8];
           Use_Ext_Trigger_Log   <= Bus2IP_Data[9];
           Streaming_FIFO_Reset  <= Bus2IP_Data[25];
       end
       else begin
           Metrics_Cnt_En        <= Metrics_Cnt_En;
           Metrics_Cnt_Reset     <= Metrics_Cnt_Reset;
           Use_Ext_Trigger       <= Use_Ext_Trigger;
           Wr_Lat_Start_CDC      <= Wr_Lat_Start_CDC;
           Wr_Lat_End_CDC        <= Wr_Lat_End_CDC;
           Rd_Lat_Start_CDC      <= Rd_Lat_Start_CDC;
           Rd_Lat_End_CDC        <= Rd_Lat_End_CDC;
           Event_Log_En          <= Event_Log_En;
           Use_Ext_Trigger_Log   <= Use_Ext_Trigger_Log;
           Streaming_FIFO_Reset  <= Streaming_FIFO_Reset;
       end
   end
end 

assign  Wr_Lat_Start = Wr_Lat_Start_CDC;
assign  Wr_Lat_End   = Wr_Lat_End_CDC;
assign  Rd_Lat_Start = Rd_Lat_Start_CDC;
assign  Rd_Lat_End   = Rd_Lat_End_CDC;


//-- Trace Control Register
always @(posedge S_AXI_ACLK) begin 
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       Trace_ctrl_reg      <= 32'hFFFFFFFF;
       //Slot0_used        <= 1'b0;
       //Slot0_wr_events   <= 1'b0;
       //Slot0_rd_events   <= 1'b0;
       //Slot0_ext_events  <= 1'b0;
       //Slot1_used        <= 1'b0;
       //Slot1_wr_events   <= 1'b0;
       //Slot1_rd_events   <= 1'b0;
       //Slot1_ext_events  <= 1'b0;
       //Slot2_used        <= 1'b0;
       //Slot2_wr_events   <= 1'b0;
       //Slot2_rd_events   <= 1'b0;
       //Slot2_ext_events  <= 1'b0;
       //Slot3_used        <= 1'b0;
       //Slot3_wr_events   <= 1'b0;
       //Slot3_rd_events   <= 1'b0;
       //Slot3_ext_events  <= 1'b0;
       //Slot4_used        <= 1'b0;
       //Slot4_wr_events   <= 1'b0;
       //Slot4_rd_events   <= 1'b0;
       //Slot4_ext_events  <= 1'b0;
       //Slot5_used        <= 1'b0;
       //Slot5_wr_events   <= 1'b0;
       //Slot5_rd_events   <= 1'b0;
       //Slot5_ext_events  <= 1'b0;
       //Slot6_used        <= 1'b0;
       //Slot6_wr_events   <= 1'b0;
       //Slot6_rd_events   <= 1'b0;
       //Slot6_ext_events  <= 1'b0;
       //Slot7_used        <= 1'b0;
       //Slot7_wr_events   <= 1'b0;
       //Slot7_rd_events   <= 1'b0;
       //Slot7_ext_events  <= 1'b0;

   end
   else begin 
       if (Trace_Filter_Wr_En == 1'b1) begin
       Trace_ctrl_reg      <= Bus2IP_Data;
      // Slot0_used        <= Bus2IP_Data[0];
      // Slot0_wr_events   <= Bus2IP_Data[1];
      // Slot0_rd_events   <= Bus2IP_Data[2];
      // Slot0_ext_events  <= Bus2IP_Data[3];
      // Slot1_used        <= Bus2IP_Data[4];
      // Slot1_wr_events   <= Bus2IP_Data[5];
      // Slot1_rd_events   <= Bus2IP_Data[6];
      // Slot1_ext_events  <= Bus2IP_Data[7];
      // Slot2_used        <= Bus2IP_Data[8];
      // Slot2_wr_events   <= Bus2IP_Data[9];
      // Slot2_rd_events   <= Bus2IP_Data[10];
      // Slot2_ext_events  <= Bus2IP_Data[11];
      // Slot3_used        <= Bus2IP_Data[12];
      // Slot3_wr_events   <= Bus2IP_Data[13];
      // Slot3_rd_events   <= Bus2IP_Data[14];
      // Slot3_ext_events  <= Bus2IP_Data[15];
      // Slot4_used        <= Bus2IP_Data[16];
      // Slot4_wr_events   <= Bus2IP_Data[17];
      // Slot4_rd_events   <= Bus2IP_Data[18];
      // Slot4_ext_events  <= Bus2IP_Data[19];
      // Slot5_used        <= Bus2IP_Data[20];
      // Slot5_wr_events   <= Bus2IP_Data[21];
      // Slot5_rd_events   <= Bus2IP_Data[22];
      // Slot5_ext_events  <= Bus2IP_Data[23];
      // Slot6_used        <= Bus2IP_Data[24];
      // Slot6_wr_events   <= Bus2IP_Data[25];
      // Slot6_rd_events   <= Bus2IP_Data[26];
      // Slot6_ext_events  <= Bus2IP_Data[27];
      // Slot7_used        <= Bus2IP_Data[28];
      // Slot7_wr_events   <= Bus2IP_Data[];
      // Slot7_rd_events   <= Bus2IP_Data[];
      // Slot7_ext_events  <= Bus2IP_Data[];
       end
       else begin
         Trace_ctrl_reg <= Trace_ctrl_reg;
       end
   end
end 

//-- sample register read edge detection logic. 
//-- This will b used in core_aclk domain
generate
    if(C_AXI4LITE_CORE_CLK_ASYNC == 1 && C_ENABLE_PROFILE == 1) begin :GEN_SAMPLE_REG_ASYNC

    // Synchronizing sample register read enable 
    //-- Double Flop synchronization
    axi_perf_mon_v5_0_12_cdc_sync
    #(
       .c_cdc_type      (1             ),   
       .c_flop_input    (0             ),  
       .c_reset_state   (1             ),  
       .c_single_bit    (1             ),  
       .c_vector_width  (1             ),  
       .c_mtbf_stages   (4             )  
     ) sample_reg_read_inst 
     (
       .prmry_aclk      (S_AXI_ACLK              ),
       .prmry_rst_n     (S_AXI_ARESETN           ),
       .prmry_in        (Lat_Sample_Reg_Rd_En    ),
       .prmry_vect_in   (1'b0                    ),
       .scndry_aclk     (CORE_ACLK               ),
       .scndry_rst_n    (CORE_ARESETN            ),
       .prmry_ack       (                        ),
       .scndry_out      (Lat_Sample_Reg_Rd_En_d2 ),
       .scndry_vect_out (                        ) 
      );

       always @(posedge CORE_ACLK) begin 
         if (CORE_ARESETN == RST_ACTIVE) begin
            Lat_Sample_Reg_Rd_En_d3      <= 0;
         end
         else begin
            Lat_Sample_Reg_Rd_En_d3      <= Lat_Sample_Reg_Rd_En_d2;
         end
       end 

     //-- This rising edge pulse will be used to sample metric counts into sampled metric counts
     assign Lat_Sample_Reg =  Lat_Sample_Reg_Rd_En_d2 && ~Lat_Sample_Reg_Rd_En_d3;
  
    end
    else begin :GEN_SAMPLE_REG_SYNC

      always @(posedge CORE_ACLK) begin 
         if (CORE_ARESETN == RST_ACTIVE) begin
            Lat_Sample_Reg_Rd_En_d1      <= 0;
         end
         else begin
            Lat_Sample_Reg_Rd_En_d1      <= Lat_Sample_Reg_Rd_En;
         end
      end 
     
     //-- This rising edge pulse will be used to sample metric counts into sampled metric counts
      assign Lat_Sample_Reg= Lat_Sample_Reg_Rd_En && ~Lat_Sample_Reg_Rd_En_d1; 
    end

   endgenerate


  generate
    if( C_ENABLE_PROFILE == 1) begin :GEN_SAMPLE_PROFILE

   //-- Free running Counter after first read of sample register
   //-- The number of clocks is in S_AXI_ACLK domain
   axi_perf_mon_v5_0_12_counter 
     #(
          .C_FAMILY             (C_FAMILY),
          .C_NUM_BITS           (32),
	  .COUNTER_LOAD_VALUE   (32'h00000000)
      ) sample_reg_counter_inst 
      (
          .clk                  (S_AXI_ACLK),
          .rst_n                (S_AXI_ARESETN),
          .Load_In              (TIME_DIFF_LOAD_VALUE),
          .Count_Enable         (Sample_Reg_Rd_First),
          .Count_Load           (1'b0),
          .Count_Down           (1'b0),
          .Count_Out            (Sample_Time_Diff),
          .Carry_Out            ( )  //Overflow is left to the software as they have to find the difference
                                     //Between two sample register reads
      );  
   
   
   //-- Sample time capture 
   always @(posedge S_AXI_ACLK) begin 
      if (S_AXI_ARESETN == RST_ACTIVE) begin
          Sample_Time_Diff_Reg<= 0;
          Sample_Reg_Rd_First <= 0;
      end
      else begin
          if (Sample_Reg_Rd_En == 1'b1) begin
             Sample_Time_Diff_Reg   <= Sample_Time_Diff;
             Sample_Reg_Rd_First    <= 1;
          end
          else begin
             Sample_Time_Diff_Reg<= Sample_Time_Diff_Reg;
             Sample_Reg_Rd_First <= Sample_Reg_Rd_First;
          end
      end
   end 
     assign Sample_Time_Diff_Reg_int = Sample_Time_Diff_Reg;

   //-- Sample Interval LSB Register
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Sample_Interval_i_reg_CDC <= 0;
       end
       else begin
           if ((Sample_Interval_Wr_En == 1'b1) && (Addr_3downto0_is_0x4 == 1'b1)) begin
               Sample_Interval_i_reg_CDC <= Bus2IP_Data[31:0];
           end
           else begin
               Sample_Interval_i_reg_CDC <= Sample_Interval_i_reg_CDC;
           end
       end
    end 
      assign Sample_Interval_i = Sample_Interval_i_reg_CDC;
      assign Sample_Interval = Sample_Interval_i;
    
    //-- Sample Interval Control Register
    always @(posedge S_AXI_ACLK) begin 
       if (S_AXI_ARESETN == RST_ACTIVE) begin
           Interval_Cnt_En_int             <= 1'b0;
           Interval_Cnt_Ld_int             <= 1'b0;
           Reset_On_Sample_Int_Lapse_int   <= 1'b1;
       end
       else begin
           if ((Sample_Interval_Wr_En == 1'b1) && (Addr_3downto0_is_0x8 == 1'b1)) begin
               Interval_Cnt_En_int             <= Bus2IP_Data[0];
               Interval_Cnt_Ld_int             <= Bus2IP_Data[1];
               Reset_On_Sample_Int_Lapse_int   <= Bus2IP_Data[8];
           end
           else begin
               Interval_Cnt_En_int             <= Interval_Cnt_En_int     ;
               Interval_Cnt_Ld_int             <= Interval_Cnt_Ld_int     ;
               Reset_On_Sample_Int_Lapse_int   <= Reset_On_Sample_Int_Lapse_int;
           end
       end
    end 
        assign Interval_Cnt_En  = Interval_Cnt_En_int;
        assign Interval_Cnt_Ld  = Interval_Cnt_Ld_int;
        assign Reset_On_Sample_Int_Lapse = Reset_On_Sample_Int_Lapse_int;
   end
   else begin:GEN_NOSAMPLE_PROFILE
     assign Sample_Time_Diff_Reg_int  = 0;
     assign Sample_Interval_i         = 0;
     assign Sample_Interval           = 0;
     assign Interval_Cnt_En           = 0;
     assign Interval_Cnt_Ld           = 0;
     assign Reset_On_Sample_Int_Lapse = 1;
   end
   endgenerate

   //-- Global Interrupt Enable Register
   always @(posedge S_AXI_ACLK) begin 
      if (S_AXI_ARESETN == RST_ACTIVE) begin
          Global_Intr_En <= 1'b0;
      end
      else begin
          if ((Intr_Reg_GIE_Wr_En == 1'b1)) begin
              Global_Intr_En <= Bus2IP_Data[0];
          end
          else begin
              Global_Intr_En <= Global_Intr_En;
          end
      end
   end 

generate
   if( C_ENABLE_PROFILE == 1 && C_ENABLE_TRACE == 1) begin :GEN_CNTRL_REG
   //--IER register read data
   assign Intr_Reg_IER_Int = Intr_Reg_IER;
   //--Control Register read
   assign Control_Reg = { {6{1'b0}}, Streaming_FIFO_Reset, 1'b0,
                            {8{1'b0}}, 
                            {6{1'b0}}, Use_Ext_Trigger_Log, Event_Log_En,
                            Rd_Lat_End_CDC,Rd_Lat_Start_CDC,Wr_Lat_End_CDC,Wr_Lat_Start_CDC,
                            1'b0,Use_Ext_Trigger,Metrics_Cnt_Reset, Metrics_Cnt_En };
end
else if(C_ENABLE_PROFILE == 1) begin:GEN_CNTRL_REG_PROFILE
   //--IER register read data
   assign Intr_Reg_IER_Int = {1'b0,Intr_Reg_IER[0]};
   assign Control_Reg = { {24{1'b0}},
                            Rd_Lat_End_CDC,Rd_Lat_Start_CDC,Wr_Lat_End_CDC,Wr_Lat_Start_CDC,
                            1'b0,Use_Ext_Trigger,Metrics_Cnt_Reset, Metrics_Cnt_En };

end
else if(C_ENABLE_TRACE == 1) begin:GEN_CNTRL_REG_TRACE
   assign Intr_Reg_IER_Int = {Intr_Reg_IER[1],1'b0};
   assign Control_Reg = { {6{1'b0}}, Streaming_FIFO_Reset, 1'b0,
                          {14{1'b0}}, 
                          Use_Ext_Trigger_Log, Event_Log_En,{8{1'b0}}};
end
endgenerate
     



   generate if(C_ENABLE_TRACE == 1'b1) begin: GEN_PROFILE_MODE 

       reg [31:0] SW_Data_reg;
       reg  SW_Data_Wr_En_reg;

       //-- Software-written Data Register
       always @(posedge S_AXI_ACLK) begin 
          if (S_AXI_ARESETN == RST_ACTIVE) begin
              SW_Data_reg       <= 0;
              SW_Data_Wr_En_reg <= 1'b0;
          end
          else begin
              if ((Event_Log_Set_Wr_En == 1'b1) && (Addr_3downto0_is_0x4 == 1'b1)) begin
                  SW_Data_reg       <= Bus2IP_Data[C_SW_SYNC_DATA_WIDTH-1:0];
                  SW_Data_Wr_En_reg <= 1'b1;
              end
              else begin
                  SW_Data_reg       <= SW_Data_reg;
                  SW_Data_Wr_En_reg <= 1'b0;
              end
          end
       end 
       assign SW_Data = SW_Data_reg;
       assign SW_Data_Wr_En_int = SW_Data_Wr_En_reg;
    end
    else begin :GEN_NO_LOG_DATA_REG
      assign SW_Data                 = 0;
      assign SW_Data_Wr_En_int       = 0;
    end

endgenerate

      

 // Synchronizing SW_Data write enable signal 
 //--Double Flop synchronization
 generate
    if(C_AXI4LITE_CORE_CLK_ASYNC == 1 && C_ENABLE_TRACE == 1) begin :GEN_SW_DATA_ASYNC

    axi_perf_mon_v5_0_12_cdc_sync
    #(
       .c_cdc_type      (1             ),   
       .c_flop_input    (0             ),  
       .c_reset_state   (1             ),  
       .c_single_bit    (1             ),  
       .c_vector_width  (1             ),  
       .c_mtbf_stages   (4             )  
     ) sw_data_wr_en_inst 
     (
       .prmry_aclk      (S_AXI_ACLK        ),
       .prmry_rst_n     (S_AXI_ARESETN     ),
       .prmry_in        (SW_Data_Wr_En_int ),
       .prmry_vect_in   (1'b0              ),
       .scndry_aclk     (CORE_ACLK         ),
       .scndry_rst_n    (CORE_ARESETN      ),
       .prmry_ack       (                  ),
       .scndry_out      (SW_Data_Wr_En     ),
       .scndry_vect_out (                  ) 
      );
    end
    else begin :GEN_SW_DATA_SYNC
      assign  SW_Data_Wr_En = SW_Data_Wr_En_int; 
    end

   endgenerate



//-- Address Latched on RdEn
always @(posedge S_AXI_ACLK) begin 
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       Lat_Addr_7downto4_is_0x0          <= 1'b0;
       Lat_Addr_7downto4_is_0x1          <= 1'b0;
       Lat_Addr_7downto4_is_0x2          <= 1'b0;
       Lat_Addr_7downto4_is_0x3          <= 1'b0;
       Lat_Addr_7downto4_is_0x4          <= 1'b0;
       Lat_Addr_7downto4_is_0x5          <= 1'b0;
       Lat_Addr_7downto4_is_0x6          <= 1'b0;
       Lat_Addr_7downto4_is_0x7          <= 1'b0;
       Lat_Addr_7downto4_is_0x8          <= 1'b0;
       Lat_Addr_7downto4_is_0x9          <= 1'b0;

       Lat_Addr_3downto0_is_0x0          <= 1'b0;
       Lat_Addr_3downto0_is_0x4          <= 1'b0;
       Lat_Addr_3downto0_is_0x8          <= 1'b0;
       Lat_Addr_3downto0_is_0xC          <= 1'b0;
       Lat_Control_Set_Rd_En             <= 1'b0;
       Lat_Trace_Filter_Rd_En            <= 1'b0;
       Lat_Sample_Interval_Rd_En         <= 1'b0;
       Lat_Sample_Reg_Rd_En              <= 1'b0;
       Lat_Intr_Reg_Set_Rd_En            <= 1'b0; 
       Lat_Intr_Reg_GIE_Rd_En            <= 1'b0; 
       Lat_Intr_Reg_IER_Rd_En            <= 1'b0; 
       Lat_Intr_Reg_ISR_Rd_En            <= 1'b0; 
       Lat_Status_Reg_Set_Rd_En          <= 1'b0; 
       Lat_Status_Reg_FOC_Rd_En          <= 1'b0; 
       Lat_Status_Reg_WIF_Rd_En          <= 1'b0; 
       Lat_Metric_Cnt_Reg_Set_Rd_En      <= 1'b0; 
       Lat_Samp_Metric_Cnt_Reg_Set_Rd_En <= 1'b0; 
       Lat_Event_Log_Set_Rd_En           <= 1'b0; 
       Lat_Addr_11downto2_CDC            <= 0;
   end
   else begin
       if ((Bus2IP_RdCE == 1'b1)) begin
           Lat_Addr_7downto4_is_0x0          <= Addr_7downto4_is_0x0;
           Lat_Addr_7downto4_is_0x1          <= Addr_7downto4_is_0x1;
           Lat_Addr_7downto4_is_0x2          <= Addr_7downto4_is_0x2;
           Lat_Addr_7downto4_is_0x3          <= Addr_7downto4_is_0x3;
           Lat_Addr_7downto4_is_0x4          <= Addr_7downto4_is_0x4;
           Lat_Addr_7downto4_is_0x5          <= Addr_7downto4_is_0x5;
           Lat_Addr_7downto4_is_0x6          <= Addr_7downto4_is_0x6;
           Lat_Addr_7downto4_is_0x7          <= Addr_7downto4_is_0x7;
           Lat_Addr_7downto4_is_0x8          <= Addr_7downto4_is_0x8;
           Lat_Addr_7downto4_is_0x9          <= Addr_7downto4_is_0x9;
 
           Lat_Addr_3downto0_is_0x0          <= Addr_3downto0_is_0x0;
           Lat_Addr_3downto0_is_0x4          <= Addr_3downto0_is_0x4;
           Lat_Addr_3downto0_is_0x8          <= Addr_3downto0_is_0x8;
           Lat_Addr_3downto0_is_0xC          <= Addr_3downto0_is_0xC;

           Lat_Control_Set_Rd_En             <= Control_Set_Rd_En;
           Lat_Trace_Filter_Rd_En            <= Trace_Filter_Rd_En;
           Lat_Sample_Interval_Rd_En         <= Sample_Interval_Rd_En;
           Lat_Sample_Reg_Rd_En              <= Sample_Reg_Rd_En;
           Lat_Intr_Reg_Set_Rd_En            <= Intr_Reg_Set_Rd_En; 
           Lat_Intr_Reg_GIE_Rd_En            <= Intr_Reg_GIE_Rd_En; 
           Lat_Intr_Reg_IER_Rd_En            <= Intr_Reg_IER_Rd_En; 
           Lat_Intr_Reg_ISR_Rd_En            <= Intr_Reg_ISR_Rd_En; 
           Lat_Status_Reg_Set_Rd_En          <= Status_Reg_Set_Rd_En  ; 
           Lat_Status_Reg_FOC_Rd_En          <= Status_Reg_FOC_Rd_En  ; 
           Lat_Status_Reg_WIF_Rd_En          <= Status_Reg_WIF_Rd_En  ; 
           Lat_Metric_Cnt_Reg_Set_Rd_En      <= Metric_Cnt_Reg_Set_Rd_En; 
           Lat_Samp_Metric_Cnt_Reg_Set_Rd_En <= Samp_Metric_Cnt_Reg_Set_Rd_En; 
           Lat_Event_Log_Set_Rd_En           <= Event_Log_Set_Rd_En; 
           Lat_Addr_11downto2_CDC            <= Bus2IP_Addr[11:2];
       end
       else begin
           Lat_Addr_7downto4_is_0x0          <= Lat_Addr_7downto4_is_0x0;
           Lat_Addr_7downto4_is_0x1          <= Lat_Addr_7downto4_is_0x1;
           Lat_Addr_7downto4_is_0x2          <= Lat_Addr_7downto4_is_0x2;
           Lat_Addr_7downto4_is_0x3          <= Lat_Addr_7downto4_is_0x3;
           Lat_Addr_7downto4_is_0x4          <= Lat_Addr_7downto4_is_0x4;
           Lat_Addr_7downto4_is_0x5          <= Lat_Addr_7downto4_is_0x5;
           Lat_Addr_7downto4_is_0x6          <= Lat_Addr_7downto4_is_0x6;
           Lat_Addr_7downto4_is_0x7          <= Lat_Addr_7downto4_is_0x7;
           Lat_Addr_7downto4_is_0x8          <= Lat_Addr_7downto4_is_0x8;
           Lat_Addr_7downto4_is_0x9          <= Lat_Addr_7downto4_is_0x9;
 
           Lat_Addr_3downto0_is_0x0          <= Lat_Addr_3downto0_is_0x0;
           Lat_Addr_3downto0_is_0x4          <= Lat_Addr_3downto0_is_0x4;
           Lat_Addr_3downto0_is_0x8          <= Lat_Addr_3downto0_is_0x8;
           Lat_Addr_3downto0_is_0xC          <= Lat_Addr_3downto0_is_0xC;

           Lat_Control_Set_Rd_En             <= Lat_Control_Set_Rd_En;
           Lat_Trace_Filter_Rd_En            <= Lat_Trace_Filter_Rd_En;
           Lat_Sample_Interval_Rd_En         <= Lat_Sample_Interval_Rd_En;
           Lat_Sample_Reg_Rd_En              <= Lat_Sample_Reg_Rd_En;
           Lat_Intr_Reg_Set_Rd_En            <= Lat_Intr_Reg_Set_Rd_En; 
           Lat_Intr_Reg_GIE_Rd_En            <= Lat_Intr_Reg_GIE_Rd_En; 
           Lat_Intr_Reg_IER_Rd_En            <= Lat_Intr_Reg_IER_Rd_En; 
           Lat_Intr_Reg_ISR_Rd_En            <= Lat_Intr_Reg_ISR_Rd_En; 
           Lat_Status_Reg_Set_Rd_En          <= Lat_Status_Reg_Set_Rd_En ; 
           Lat_Status_Reg_FOC_Rd_En          <= Lat_Status_Reg_FOC_Rd_En ; 
           Lat_Status_Reg_WIF_Rd_En          <= Lat_Status_Reg_WIF_Rd_En ; 
           Lat_Metric_Cnt_Reg_Set_Rd_En      <= Lat_Metric_Cnt_Reg_Set_Rd_En; 
           Lat_Samp_Metric_Cnt_Reg_Set_Rd_En <= Lat_Samp_Metric_Cnt_Reg_Set_Rd_En; 
           Lat_Event_Log_Set_Rd_En           <= Lat_Event_Log_Set_Rd_En; 
           Lat_Addr_11downto2_CDC            <= Lat_Addr_11downto2_CDC;
       end
   end
end 

assign Lat_Addr_11downto2 = Lat_Addr_11downto2_CDC;

//-- synchronizing RdEn to core clk domain
//-- Pulse synchronization
    axi_perf_mon_v5_0_12_cdc_sync
    #(
       .c_cdc_type      (0    ),   
       .c_flop_input    (0    ),  
       .c_reset_state   (1    ),  
       .c_single_bit    (1    ),  
       .c_vector_width  (1    ),  
       .c_mtbf_stages   (4    )  
     )cdc_sync_inst1 
     (
       .prmry_aclk      (S_AXI_ACLK       ),
       .prmry_rst_n     (S_AXI_ARESETN    ),
       .prmry_in        (Bus2IP_RdCE      ),
       .prmry_vect_in   (1'b0             ),
       .scndry_aclk     (CORE_ACLK        ),
       .scndry_rst_n    (CORE_ARESETN     ),
       .prmry_ack       (                 ),
       .scndry_out      (Rd_En_sync       ),
       .scndry_vect_out (                 ) 
      );

//-- synchronizing Rd_En_sync to AXI clk domain
//-- Pulse synchronization
     axi_perf_mon_v5_0_12_cdc_sync
    #(
       .c_cdc_type      (0    ),   
       .c_flop_input    (0    ),  
       .c_reset_state   (1    ),  
       .c_single_bit    (1    ),  
       .c_vector_width  (1    ),  
       .c_mtbf_stages   (4    )  
     )cdc_sync_inst2 
     (
       .prmry_aclk      (CORE_ACLK          ),
       .prmry_rst_n     (CORE_ARESETN       ),
       .prmry_in        (Rd_En_sync         ),
       .prmry_vect_in   (1'b0               ),
       .scndry_aclk     (S_AXI_ACLK         ),
       .scndry_rst_n    (S_AXI_ARESETN      ),
       .prmry_ack       (                   ),
       .scndry_out      (RValid             ),
       .scndry_vect_out (                   ) 
      );

//-- Data Valid generation 
always @(posedge S_AXI_ACLK) begin
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       IP2Bus_DataValid <= 1'b0;
   end
   else begin
       IP2Bus_DataValid <= RValid;
   end  
end


//-- Register Read Logic
always @(posedge S_AXI_ACLK) begin
   if (S_AXI_ARESETN == RST_ACTIVE) begin
       IP2Bus_Data <= 0;
   end
   else begin
       if (RValid == 1'b1) begin
           if (Lat_Sample_Interval_Rd_En == 1'b1) begin
               if (Lat_Addr_3downto0_is_0x4 == 1'b1) begin
                   IP2Bus_Data      <= Sample_Interval_i[31:0];   
               end
               else if (Lat_Addr_3downto0_is_0x8 == 1'b1) begin
                   IP2Bus_Data      <= {{23{1'b0}},Reset_On_Sample_Int_Lapse,{6{1'b0}},
                                        Interval_Cnt_Ld, Interval_Cnt_En};   
               end
               else if(Lat_Addr_3downto0_is_0xC == 1'b1) begin
                   IP2Bus_Data      <= Sample_Time_Diff_Reg_int; 
               end
               else begin
                   IP2Bus_Data      <= 0;
               end
           end
           else if (Lat_Control_Set_Rd_En == 1'b1) begin
               IP2Bus_Data      <= Control_Reg;   
           end
           else if (Lat_Intr_Reg_Set_Rd_En == 1'b1) begin
               if (Lat_Intr_Reg_GIE_Rd_En == 1'b1) begin
                   IP2Bus_Data  <= { {31{1'b0}}, Global_Intr_En};   
               end
               else if (Lat_Intr_Reg_IER_Rd_En == 1'b1) begin
                   IP2Bus_Data  <= { {(31-C_NUM_INTR_INPUTS){1'b0}}, Intr_Reg_IER_Int,1'b0};   
               end
               else if (Lat_Intr_Reg_ISR_Rd_En == 1'b1) begin
                   IP2Bus_Data  <= { {(31-C_NUM_INTR_INPUTS){1'b0}}, Intr_Reg_ISR,1'b0};   
               end
               else begin
                   IP2Bus_Data  <= 0;
               end
           end
           else if (Lat_Status_Reg_Set_Rd_En == 1'b1) begin
               if (Lat_Status_Reg_FOC_Rd_En == 1'b1) begin
                   IP2Bus_Data      <= sync_eventlog_cur_cnt;
               end
               else if (Lat_Status_Reg_WIF_Rd_En == 1'b1) begin
                   IP2Bus_Data      <= (C_AXIS_DWIDTH_ROUND_TO_32/32);
               end
               else begin
                   IP2Bus_Data      <= 0;
               end
           end
           else if (Lat_Event_Log_Set_Rd_En == 1'b1) begin
               if (Lat_Addr_3downto0_is_0x4 == 1'b1) begin
                   IP2Bus_Data     <= SW_Data;   
               end
               else begin
                   IP2Bus_Data     <= 0;
               end
           end
           else if (Lat_Metric_Cnt_Reg_Set_Rd_En == 1'b1 || Lat_Samp_Metric_Cnt_Reg_Set_Rd_En == 1'b1) begin
             IP2Bus_Data  <= Metric_ram_Out;
           end
           else if (Lat_Trace_Filter_Rd_En == 1'b1) begin
           IP2Bus_Data <= {1'b1,Trace_ctrl_reg[30:28],1'b1,Trace_ctrl_reg[26:24],1'b1,Trace_ctrl_reg[22:20],1'b1,Trace_ctrl_reg[18:16],1'b1,Trace_ctrl_reg[14:12],1'b1,Trace_ctrl_reg[10:8],1'b1,Trace_ctrl_reg[6:4],1'b1,Trace_ctrl_reg[2:0]};
           end
           else begin
               IP2Bus_Data <= 0;
           end
       end
       else begin
           IP2Bus_Data <= 0;
       end
   end  
end


generate
if (C_ENABLE_PROFILE == 1) begin : GEN_METRIC_RAM

//----------------------------------------------------------------------------------
// Loading Metric counts in RAM memory
//----------------------------------------------------------------------------------
reg [31:0] Metric_ram_Out_Reg_CDCR;

always @(posedge CORE_ACLK) begin 
    if(Rd_En_sync == 1'b1) begin
        Metric_ram_CDCR[Lat_Addr_11downto2_CDC] <= Metric_Ram_Data_In;
    end
    Metric_ram_Out_Reg_CDCR <= Metric_ram_CDCR[Lat_Addr_11downto2_CDC];
end 
    assign Metric_ram_Out = Metric_ram_Out_Reg_CDCR;
end 
else begin : GEN_NO_METRICRAM  
   assign Metric_ram_Out = 0; 
end    
endgenerate
//PR#741428
//Synchronize event log read data count to register
// interface clock

    axi_perf_mon_v5_0_12_cdc_sync
    #(
       .c_cdc_type      (1             ),   
       .c_flop_input    (0             ),  
       .c_reset_state   (1             ),  
       .c_single_bit    (0             ),  
       .c_vector_width  (32            ),  
       .c_mtbf_stages   (4             )  
     ) eventlog_fifo_rden 
     (
       .prmry_aclk      (eventlog_rd_clk       ),
       .prmry_rst_n     (eventlog_rd_rstn      ),
       .prmry_in        (1'b0                  ),
       .prmry_vect_in   (eventlog_cur_cnt      ),
       .scndry_aclk     (S_AXI_ACLK            ),
       .scndry_rst_n    (S_AXI_ARESETN         ),
       .prmry_ack       (                      ),
       .scndry_out      (                      ),
       .scndry_vect_out (sync_eventlog_cur_cnt ) 
      );


endmodule


//-------------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename   :     axi_perf_mon_v5_0_12_metric_calc_profile.v 
// Version    :     v5.0
// Description:      Metric calculator module generates different metric count
//                   enables which will be used in metric counter 
// Verilog-Standard:  Verilog 2001 
//-----------------------------------------------------------------------------
// Structure:
//  axi_perf_mon.v
//      \-- axi_perf_mon_v5_0_12_metric_calc_profile.v
//-----------------------------------------------------------------------------
// Author :  NLR  
// History: 
// NLR       02/10/2012      First Version
// ^^^^^^
//-----------------------------------------------------------------------------
`timescale 1ns/1ps
(* DowngradeIPIdentifiedWarnings="yes" *)

module axi_perf_mon_v5_0_12_metric_calc_profile 
  #(
    parameter C_AXIID                  = 4,
    parameter C_AXIADDR                = 32,
    parameter C_AXIDATA                = 32,
    parameter C_OUTSTAND_DEPTH         = 1,
    parameter C_AXI_SUB_PROTOCOL       = "AXI4LITE",
    parameter C_METRIC_COUNT_WIDTH     = 32,
    parameter C_MON_FIFO_WIDTH         = 126
    )
   (
    //AXI Signals
    input                                 clk,        
    input                                 rst_n,  
    input [C_MON_FIFO_WIDTH -1:0]         Data_In,
    input                                 Data_Valid,
    // Register inputs
    input                                 Metrics_Cnt_En,
    input                                 Metrics_Cnt_Reset,
    // External Trigger inputs
    input                                 Use_Ext_Trig,
    input                                 Ext_Trig,
    input                                 Ext_Trig_Stop,
    input                                 Wr_Lat_Start,  //1 Address Issue 0 Address acceptance
    input                                 Wr_Lat_End,    //1 First write   0 Last write  
    input                                 Rd_Lat_Start,  //1 Address Issue 0 Address acceptance 
    input                                 Rd_Lat_End,    //1 First Read    0 Last Read
    /// Metric outputs
    output reg                            Wtrans_Cnt_En,
    output reg                            Rtrans_Cnt_En,
    output reg [C_METRIC_COUNT_WIDTH-1:0] Write_Byte_Cnt,
    //output     [C_METRIC_COUNT_WIDTH-1:0] Write_Beat_Cnt,
    output reg [C_METRIC_COUNT_WIDTH-1:0] Read_Byte_Cnt,
    output reg                            Read_Byte_Cnt_En,
    output reg                            Write_Beat_Cnt_En,
    output reg                            Read_Beat_Cnt_En,
    output     [C_METRIC_COUNT_WIDTH-1:0] Read_Latency,
    output     [C_METRIC_COUNT_WIDTH-1:0] Write_Latency,
    output                                Read_Latency_En,
    output                                Write_Latency_En,
    output     [C_METRIC_COUNT_WIDTH-1:0] Max_Write_Latency,                   
    output     [C_METRIC_COUNT_WIDTH-1:0] Min_Write_Latency,                   
    output     [C_METRIC_COUNT_WIDTH-1:0] Max_Read_Latency,                   
    output     [C_METRIC_COUNT_WIDTH-1:0] Min_Read_Latency                   
    );

    //Parameter Declarations
    localparam RST_ACTIVE              = 0; 

    //Register declarations
    reg Write_going_on;
    reg Read_going_on;
    reg [C_METRIC_COUNT_WIDTH-1:0] Write_Byte_Cnt1;
    reg [C_METRIC_COUNT_WIDTH-1:0] Write_Byte_Cnt2;

    reg Ext_Trig_Metric_en;
    reg [1:0] Ext_Triggers_Sync_d1;
    reg Write_Beat_Cnt_En1;

    //wire declaration

    wire                   RREADY;
    wire                   RVALID;
    wire                   RLAST ;
    wire [1:0]             RRESP;
    wire [C_AXIID-1:0]     RID;
    wire                   ARREADY;
    wire                   ARVALID;
    wire [1:0]             ARBURST;
    wire [2:0]             ARSIZE;
    wire [7:0]             F1AR_Wr_Data;
    wire [7:0]             F1AR_Rd_Data;
    wire [7:0]             F1_ARSIZE;
    wire                   F1AR_Rd_En;
    wire                   F1AR_Wr_En;
    wire [7:0]             ARLEN;
    wire [C_AXIADDR-1:0]   ARADDR;
    wire [C_AXIID-1:0]     ARID;
    wire                   BREADY;
    wire                   BVALID;
    wire [1:0]             BRESP;
    wire [C_AXIID-1:0]     BID;
    wire                   WREADY;
    wire                   WVALID;
    wire                   WLAST;
    wire [C_AXIDATA/8-1:0] WSTRB;
    wire                   AWREADY;
    wire                   AWVALID;
    wire [1:0]             AWBURST;
    wire [2:0]             AWSIZE;
    wire [7:0]             AWLEN;
    wire [C_AXIADDR-1:0]   AWADDR;
    wire [C_AXIID-1:0]     AWID; 

    wire [C_METRIC_COUNT_WIDTH-1:0] zeros = 0;
    wire [C_METRIC_COUNT_WIDTH-1:0] wr_byte_cnt; 
    wire [C_METRIC_COUNT_WIDTH-1:0] wr_byte_cnt1; 

    wire [C_METRIC_COUNT_WIDTH-1:0] Write_Latency_Cnt_Out;
    reg  [C_METRIC_COUNT_WIDTH-1:0] Write_Latency_Cnt_Out_D1;
    reg  [C_METRIC_COUNT_WIDTH-1:0] Write_Latency_Cnt_Out_D2;
    wire [C_METRIC_COUNT_WIDTH-1:0] Read_Latency_Cnt_Out;
    reg [C_METRIC_COUNT_WIDTH:0] Read_Latency_Cnt_Out_D1;
    reg [C_METRIC_COUNT_WIDTH:0] Read_Latency_Cnt_Out_D2;
    // read and write latency counter overflow signals
    wire Write_Latency_Cnt_Ovf;
    wire Read_Latency_Cnt_Ovf;

    // read and write latency counter enable signals 
    reg  Read_Latency_En_Int;
    reg  Write_Latency_En_Int;

    // Write Latency FIFO control signals
    reg  Wr_Latency_Fifo_Wr_En;
//    reg  Wr_Latency_Fifo_Rd_En;
    reg  Wr_Latency_Fifo_Rd_En_D1;
    reg  Wr_Latency_Fifo_Rd_En_D2;

    // Read Latency FIFO control signals
    reg  Rd_Latency_Fifo_Wr_En;
    reg  Rd_Latency_Fifo_Rd_En;
    reg  Rd_Latency_Fifo_Rd_En_D1;
    reg  Rd_Latency_Fifo_Rd_En_D2;

    // Write and read latency signals
    reg [C_METRIC_COUNT_WIDTH-1:0] Write_Latency_Int;
    reg [C_METRIC_COUNT_WIDTH-1:0] Read_Latency_Int;

    // read and write latency counter data signals
    reg [C_METRIC_COUNT_WIDTH-1:0] Wr_Latency_Fifo_Wr_Data;
    reg [C_METRIC_COUNT_WIDTH:0] Rd_Latency_Fifo_Wr_Data;
    reg [C_METRIC_COUNT_WIDTH-1:0] Max_Write_Latency_Int;
    reg [C_METRIC_COUNT_WIDTH-1:0] Min_Write_Latency_Int;
    reg [C_METRIC_COUNT_WIDTH-1:0] Max_Read_Latency_Int;
    reg [C_METRIC_COUNT_WIDTH-1:0] Min_Read_Latency_Int;
//    reg Write_Latency_One;            
    reg Write_Latency_One_D1;            
    reg Read_Latency_One;            
    reg Read_Latency_One_D1;  
   // reg [4:0]      Wr_Latency_Occupancy;
    reg [4:0]      Rd_Latency_Occupancy;

//    wire Wr_Latency_Fifo_Rd_En_out;
    wire Rd_Latency_Fifo_Rd_En_out;
      
    wire [C_METRIC_COUNT_WIDTH-1:0] Wr_Latency_Fifo_Rd_Data;
    reg  [C_METRIC_COUNT_WIDTH-1:0] Wr_Latency_Fifo_Rd_Data_D1;
    wire [C_METRIC_COUNT_WIDTH:0] Rd_Latency_Fifo_Rd_Data;
    reg  [C_METRIC_COUNT_WIDTH:0] Rd_Latency_Fifo_Rd_Data_D1;
    wire Wr_Latency_Fifo_Full; 
    wire Wr_Latency_Fifo_Empty; 
    wire Rd_Latency_Fifo_Full; 
    wire Rd_Latency_Fifo_Empty; 
    wire Wr_Latcnt_rst_n; 
    wire Rd_Latcnt_rst_n; 
    wire [C_METRIC_COUNT_WIDTH-1:0] ONE = 1;
    wire [C_METRIC_COUNT_WIDTH-1:0] TWO = {{(C_METRIC_COUNT_WIDTH-2){1'b0}},2'b10};
    wire [C_METRIC_COUNT_WIDTH-1:0] ALL_ONES = {C_METRIC_COUNT_WIDTH{1'b1}} ;
    wire [1:0] Ext_Triggers = {Ext_Trig_Stop,Ext_Trig}; 
    wire [1:0] Ext_Triggers_Sync;
    wire Ext_Trig_Sync_Out;
    wire Ext_Trig_Stop_Sync_Out;
    reg Wr_Id_Fifo_Wr_En;
    reg Wr_Id_Fifo_Rd_En;
    reg Wr_Id_Fifo_Wr_Data;
    wire Wr_Id_Fifo_Rd_Data;
    wire Wr_Id_Fifo_Empty;
    //reg wid_match;
    wire wid_match;
    //reg Write_access_done;
    reg Wr_Add_Issue;
    reg No_Wr_Ready;
    //reg Read_access_done;
    reg Rd_Add_Issue;
    reg No_Rd_Ready;
    reg First_Write_reg;
    reg Last_Write_reg;
    reg First_Read_reg;
    reg Last_Read_reg;
    reg Write_Latency_Ovf;
    reg Read_Latency_Ovf;
    wire Wr_cnt_ld;
    wire Rd_cnt_ld;

      
wire rst_int_n1 = rst_n &  ~(Metrics_Cnt_Reset);
    reg rst_int_n;
    always @(posedge clk) begin
      rst_int_n <= rst_int_n1;
    end
   
   // Function to find number of '1' in 4-bit strobe


function [2:0] count_4;
    input [3:0] strobe;            //Strobe
    begin
    case (strobe) 
            4'b0001, 4'b0010, 4'b0100, 4'b1000:
              count_4 = 3'b001;
            4'b0011, 4'b0110, 4'b1100, 4'b1001, 4'b0101, 4'b1010 :
              count_4 = 3'b010;
            4'b0111, 4'b1011, 4'b1101, 4'b1110 :
              count_4 = 3'b011;
            4'b1111 :
              count_4 = 3'b100;
            default :
              count_4 = 3'b000;
    endcase
    end
    endfunction

   // Function to find number of '1' in 8-bit strobe
    function [3:0] count_8;
    input [7:0] strobe;         //Strobe
    //input valid;                //Data valid
    integer j;
    reg [2:0] count_1;
    reg [2:0] count_2;
    begin
      count_1 = count_4(strobe[3:0]);
      count_2 = count_4(strobe[7:4]);
      count_8 = count_1+count_2;
    end
    endfunction

   // Function to find number of '1' in 16-bit strobe
    function [4:0] count_16;
    input [15:0] strobe;      //Strobe
    //input valid;              //Data valid
    integer j;
    reg [3:0] count_1;
    reg [3:0] count_2;
    begin
      count_1 = count_8(strobe[7:0]);
      count_2 = count_8(strobe[15:8]);
      count_16 = count_1+count_2;
    end
    endfunction

   // Function to find number of '1' in 32-bit strobe
    function [5:0] count_32;
    input [31:0] strobe;    //Strobe
    //input valid;            //Data valid
    integer j;
    reg [4:0] count_1;
    reg [4:0] count_2;
    begin
      count_1 = count_16(strobe[15:0]);
      count_2 = count_16(strobe[31:16]);
      count_32 = count_1+count_2;
    end
    endfunction

   // Function to find number of '1' in 64-bit strobe
    function [6:0] count_64;
    input [63:0] strobe;   //Strobe
    //input valid;           //Data valid
    integer j;
    reg [5:0] count_1;
    reg [5:0] count_2;
    begin
      count_1  = count_32(strobe[31:0]);
      count_2  = count_32(strobe[63:32]);
      count_64 = count_1+count_2;
    end
    endfunction

   // Function to find number of '1' in 128-bit strobe
    function [7:0] count_128;
    input [127:0] strobe;    //Strobe
    //input valid;             //Data Valid
    reg [6:0] count_1;
    reg [6:0] count_2;
    begin
      count_1  = count_64(strobe[63:0]);
      count_2  = count_64(strobe[127:64]);
      count_128 = count_1+count_2;
    end
    endfunction


 // Synchronizing external trigger
 //--Level synchronization
    axi_perf_mon_v5_0_12_cdc_sync
    #(
       .c_cdc_type      (1             ),   
       .c_flop_input    (0             ),  
       .c_reset_state   (1             ),  
       .c_single_bit    (0             ),  
       .c_vector_width  (2             ),  
       .c_mtbf_stages   (4             )  
     )ext_trig_cdc_sync 
     (
       .prmry_aclk      (1'b0                ), //Not used as there is no setting for c_flop_input 
       .prmry_rst_n     (1'b1                ),
       .prmry_in        (1'b0                ),
       .prmry_vect_in   (Ext_Triggers        ),
       .scndry_aclk     (clk                 ),
       .scndry_rst_n    (rst_int_n           ),
       .prmry_ack       (                    ),
       .scndry_out      (                    ),
       .scndry_vect_out (Ext_Triggers_Sync   ) 
      );

   always @(posedge clk) begin
      if (rst_int_n == RST_ACTIVE) begin
          Ext_Triggers_Sync_d1 <= 0;
      end
      else begin
          Ext_Triggers_Sync_d1 <= Ext_Triggers_Sync;
      end
   end
  
   // Positive edge detection for the trigger start and stop 
   assign Ext_Trig_Sync_Out = Ext_Triggers_Sync[0] & ~(Ext_Triggers_Sync_d1[0]); 
   assign Ext_Trig_Stop_Sync_Out = Ext_Triggers_Sync[1] & ~(Ext_Triggers_Sync_d1[1]); 

   always @(posedge clk) begin
      if (rst_int_n == RST_ACTIVE) begin
          Ext_Trig_Metric_en <= 0;
      end
      else begin
          if(Use_Ext_Trig == 1'b0 || Ext_Trig_Stop_Sync_Out == 1'b1) begin
            Ext_Trig_Metric_en <=  1'b0;
          end
          else if(Ext_Trig_Sync_Out == 1'b1) begin
            Ext_Trig_Metric_en <=  1'b1;
          end
          else begin
            Ext_Trig_Metric_en <= Ext_Trig_Metric_en;
          end
      end
   end

   wire Metrics_Cnt_En_Int = Use_Ext_Trig?(Metrics_Cnt_En&Ext_Trig_Metric_en):Metrics_Cnt_En;

   assign Metrics_Cnt_En_Out = Metrics_Cnt_En_Int;

    // AXI Events from parallel FIFO data
    assign RREADY  = Data_In[0];
    assign RVALID  = Data_In[1];
    assign RLAST   = Data_In[2];
    assign RRESP   = Data_In[4:3];
    assign RID     = Data_In[C_AXIID+4:5];
    assign ARREADY = Data_In[C_AXIID+5];
    assign ARVALID = Data_In[C_AXIID+6];
    assign ARBURST = Data_In[C_AXIID+8:C_AXIID+7];
    assign ARSIZE  = Data_In[C_AXIID+11:C_AXIID+9];
    assign ARLEN   = Data_In[C_AXIID+19:C_AXIID+12];
    assign ARADDR  = Data_In[C_AXIADDR+C_AXIID+19:C_AXIID+20];
    assign ARID    = Data_In[(C_AXIADDR+(2*C_AXIID)+19):(C_AXIADDR+C_AXIID+20)];
    assign BREADY  = Data_In[(C_AXIADDR+(2*C_AXIID)+20)];
    assign BVALID  = Data_In[(C_AXIADDR+(2*C_AXIID)+21)];
    assign BRESP   = Data_In[(C_AXIADDR+(2*C_AXIID)+23):(C_AXIADDR+(2*C_AXIID)+22)];
    assign BID     = Data_In[(C_AXIADDR+(3*C_AXIID)+23):(C_AXIADDR+(2*C_AXIID)+24)];
    assign WREADY  = Data_In[(C_AXIADDR+(3*C_AXIID)+24)];
    assign WVALID  = Data_In[(C_AXIADDR+(3*C_AXIID)+25)];
    assign WLAST   = Data_In[(C_AXIADDR+(3*C_AXIID)+26)];
    assign WSTRB   = Data_In[(C_AXIADDR+(C_AXIDATA/8)+(3*C_AXIID)+26):(C_AXIADDR+(3*C_AXIID)+27)];
    assign AWREADY = Data_In[(C_AXIADDR+(C_AXIDATA/8)+(3*C_AXIID)+27)];
    assign AWVALID = Data_In[(C_AXIADDR+(C_AXIDATA/8)+(3*C_AXIID)+28)];
    assign AWBURST = Data_In[(C_AXIADDR+(C_AXIDATA/8)+(3*C_AXIID)+30):(C_AXIADDR+(C_AXIDATA/8)+(3*C_AXIID)+29)];
    assign AWSIZE  = Data_In[(C_AXIADDR+(C_AXIDATA/8)+(3*C_AXIID)+33):(C_AXIADDR+(C_AXIDATA/8)+(3*C_AXIID)+31)];
    assign AWLEN   = Data_In[(C_AXIADDR+(C_AXIDATA/8)+(3*C_AXIID)+41):(C_AXIADDR+(C_AXIDATA/8)+(3*C_AXIID)+34)];
    assign AWADDR  = Data_In[((2*C_AXIADDR)+(C_AXIDATA/8)+(3*C_AXIID)+41):(C_AXIADDR+(C_AXIDATA/8)+(3*C_AXIID)+42)];
    assign AWID    = Data_In[((2*C_AXIADDR)+(C_AXIDATA/8)+(4*C_AXIID)+41):((2*C_AXIADDR)+(C_AXIDATA/8)+(3*C_AXIID)+42)]; 

    //AXI Memory map imp events capture 
    wire Wr_Addr_Lat = AWREADY & AWVALID & Data_Valid;
    wire Wr_Idle = WVALID & ~(WREADY) & Data_Valid;
    wire First_Write = WVALID & WREADY & ~(Write_going_on) & Data_Valid;
    wire Last_Write  = WLAST & WVALID & WREADY & Data_Valid;
    wire Response    = BVALID & BREADY & Data_Valid;
    wire Rd_Addr_Lat = ARREADY & ARVALID & Data_Valid;
    wire Rd_Idle     = RVALID & ~(RREADY) & Data_Valid;
    wire First_Read  = RVALID & RREADY & ~(Read_going_on) & Data_Valid;
    wire Last_Read   = RLAST & RVALID & RREADY & Data_Valid;
    wire Write_Beat  = WVALID & WREADY & Data_Valid;
    wire Read_Beat   = RVALID & RREADY & Data_Valid; 
    wire [C_METRIC_COUNT_WIDTH-1:0] rd_byte_cnt = C_AXIDATA/8;
    reg [8:0] num_read_beat;
    reg [8:0] num_rd_beats;
    reg Last_Read_buf;

/*------------------Read Beat COunt Calculations for narrow reads KAR-----*/
     always @(posedge clk) begin 
       if (rst_int_n == RST_ACTIVE) begin
          num_read_beat      <= 0;
          num_rd_beats      <= 0;
          Last_Read_buf <= 0;
       end
       else begin
          Last_Read_buf <= Last_Read;         
           if(Read_Beat == 1'b1 && Last_Read == 1'b1) begin
             num_rd_beats <= num_read_beat + 1'b1;
             num_read_beat <= 0;//num_read_beat + 1'b1;
           end
           else if(Read_Beat == 1'b1 && Last_Read == 1'b0) begin
             num_read_beat <= num_read_beat + 1'b1;
           end
     end
     end

// function size_val;
//     input [2:0] siz;
//     begin
//       size_val = (siz == 3'b000) ? 1 : ((siz == 3'b001) ? 2 : ((siz == 3'b010) ? 4 : ((siz == 3'b011) ? 8 : ((siz == 3'b100) ? 16 : ((siz == 3'b101) ? 32 : ((siz == 3'b110) ? 64 :  128) ) ) ) ) );
//     end
// endfunction

assign F1AR_Wr_En = Rd_Addr_Lat;
//assign F1AR_Wr_Data = 2**ARSIZE;
//generate if(C_AXI_SUB_PROTOCOL != "AXI4LITE") begin : GEN_ARSIZE_AXI4

generate if(C_AXIDATA == 8 && C_AXI_SUB_PROTOCOL != "AXI4LITE") begin : GEN_8BIT_F1AR
       assign F1AR_Wr_Data = 8'h01;
    end
    endgenerate
generate if(C_AXIDATA == 16 && C_AXI_SUB_PROTOCOL != "AXI4LITE") begin : GEN_16BIT_F1AR
       assign F1AR_Wr_Data = (ARSIZE == 3'b000 ? 8'h01 : 8'h02);
    end
    endgenerate
generate if(C_AXIDATA == 32 && C_AXI_SUB_PROTOCOL != "AXI4LITE") begin : GEN_32BIT_F1AR
       assign F1AR_Wr_Data = (ARSIZE == 3'b000 ? 8'h01 : (ARSIZE == 3'b001 ? 8'h02 : 8'h04));
    end
    endgenerate
generate if(C_AXIDATA == 64 && C_AXI_SUB_PROTOCOL != "AXI4LITE") begin : GEN_64BIT_F1AR
       assign F1AR_Wr_Data = (ARSIZE == 3'b000 ? 8'h01 : (ARSIZE == 3'b001 ? 8'h02 : (ARSIZE == 3'b010 ? 8'h04 : 8'h08)));
    end
    endgenerate
generate if(C_AXIDATA == 128 && C_AXI_SUB_PROTOCOL != "AXI4LITE") begin : GEN_128BIT_F1AR
       assign F1AR_Wr_Data = (ARSIZE == 3'b000 ? 8'h01 : (ARSIZE == 3'b001 ? 8'h02 : (ARSIZE == 3'b010 ? 8'h04 : (ARSIZE == 3'b011 ? 8'h08 : 8'h10))));
    end
    endgenerate
generate if(C_AXIDATA == 256 && C_AXI_SUB_PROTOCOL != "AXI4LITE") begin : GEN_256BIT_F1AR
 assign F1AR_Wr_Data = (ARSIZE == 3'b000 ? 8'h01 : (ARSIZE == 3'b001 ? 8'h02 : (ARSIZE == 3'b010 ? 8'h04 : (ARSIZE == 3'b011 ? 8'h08 : (ARSIZE == 3'b100 ? 8'h10 : 8'h20)))));
    end
    endgenerate
generate if(C_AXIDATA == 512 && C_AXI_SUB_PROTOCOL != "AXI4LITE") begin : GEN_512BIT_F1AR
       assign F1AR_Wr_Data = (ARSIZE == 3'b000 ? 8'h01 : (ARSIZE == 3'b001 ? 8'h02 : (ARSIZE == 3'b010 ? 8'h04 : (ARSIZE == 3'b011 ? 8'h08 : (ARSIZE == 3'b100 ? 8'h10 : (ARSIZE == 3'b101 ? 8'h20 : 8'h40 ))))));
    end
    endgenerate
generate if(C_AXIDATA == 1024 && C_AXI_SUB_PROTOCOL != "AXI4LITE") begin : GEN_1024BIT_F1AR
       assign F1AR_Wr_Data = (ARSIZE == 3'b000 ? 8'h01 : (ARSIZE == 3'b001 ? 8'h02 : (ARSIZE == 3'b010 ? 8'h04 : (ARSIZE == 3'b011 ? 8'h08 : (ARSIZE == 3'b100 ? 8'h10 : (ARSIZE == 3'b101 ? 8'h20 : (ARSIZE == 3'b110 ? 8'h40 : (ARSIZE == 3'b111 ? 8'h80 : 8'h80))))))));
    end
    endgenerate

//assign F1AR_Wr_Data = (ARSIZE == 3'b000 ? 8'h01 : (ARSIZE == 3'b001 ? 8'h02 : (ARSIZE == 3'b010 ? 8'h04 : (ARSIZE == 3'b011 ? 8'h08 : (ARSIZE == 3'b100 ? 8'h10 : (ARSIZE == 3'b101 ? 8'h20 : (ARSIZE == 3'b110 ? 8'h40 : (ARSIZE == 3'b111 ? 8'h80 : 8'h04))))))));

generate if(C_AXI_SUB_PROTOCOL != "AXI4LITE") begin : GEN_ARSIZE_FIFO

assign F1AR_Rd_En = Last_Read;
assign F1_ARSIZE = F1AR_Rd_Data;

axi_perf_mon_v5_0_12_sync_fifo 
     #(
        .WIDTH      (8), 
        .DEPTH_LOG2 (5) 
     ) F1_ARSIZE_NARROW
     (
       .rst_n    (rst_int_n),
       .clk      (clk),
       .wren     (F1AR_Wr_En   ),
       .rden     (F1AR_Rd_En   ),
       .din      (F1AR_Wr_Data ),
       .dout     (F1AR_Rd_Data ),
       .full     (           ),
       .empty    (           )
     );
    end
    endgenerate
generate if(C_AXI_SUB_PROTOCOL == "AXI4LITE") begin : GEN_ARSIZE_AXI4FIFO

assign F1AR_Rd_En = 0;
assign F1_ARSIZE = 0;

        end
    endgenerate
/*------------------END Read Beat COunt Calculations for narrow reads KAR-----*/
 
    // Registering First_Write and Last_Write to use in latency calculations
    always @(posedge clk) begin
      if (rst_int_n == RST_ACTIVE) begin
          First_Write_reg <= 1'b0; 
          Last_Write_reg <= 1'b0; 
          First_Read_reg <= 1'b0; 
          Last_Read_reg <= 1'b0; 
      end
      else begin
          First_Write_reg <= First_Write; 
          Last_Write_reg  <= Last_Write; 
          First_Read_reg  <= First_Read; 
          Last_Read_reg   <= Last_Read; 
      end
   end
 
    // Write data byte counts for different data widths of the bus 

    generate if(C_AXIDATA == 32) begin : GEN_32BIT_BYTECNT
       assign wr_byte_cnt = {zeros[C_METRIC_COUNT_WIDTH-1:3],count_4(WSTRB)}; 
       assign wr_byte_cnt1 = 0;
    end
    endgenerate

    generate if(C_AXIDATA == 64) begin : GEN_64BIT_BYTECNT
       assign wr_byte_cnt = {zeros[C_METRIC_COUNT_WIDTH-1:4],count_8(WSTRB)}; 
       assign wr_byte_cnt1 = 0;
    end
    endgenerate

    generate if(C_AXIDATA == 128) begin : GEN_128BIT_BYTECNT
       assign wr_byte_cnt = {zeros[C_METRIC_COUNT_WIDTH-1:5],count_16(WSTRB)}; 
       assign wr_byte_cnt1 = 0;
    end
    endgenerate

    generate if(C_AXIDATA == 256) begin : GEN_256BIT_BYTECNT
       assign wr_byte_cnt = {zeros[C_METRIC_COUNT_WIDTH-1:6],count_32(WSTRB)}; 
       assign wr_byte_cnt1 = 0;
    end
    endgenerate

    generate if(C_AXIDATA == 512) begin : GEN_512BIT_BYTECNT
       assign wr_byte_cnt = {zeros[C_METRIC_COUNT_WIDTH-1:6],count_32(WSTRB[31:0])}; 
       assign wr_byte_cnt1 = {zeros[C_METRIC_COUNT_WIDTH-1:6],count_32(WSTRB[63:32])}; 
    end
    endgenerate

    generate if(C_AXIDATA == 1024) begin : GEN_1024BIT_BYTECNT
       assign wr_byte_cnt = {zeros[C_METRIC_COUNT_WIDTH-1:8],count_64(WSTRB[63:0])}; 
       assign wr_byte_cnt1 = {zeros[C_METRIC_COUNT_WIDTH-1:8],count_64(WSTRB[127:64])}; 
    end
    endgenerate
    
    always @(posedge clk) begin
      if (rst_int_n == RST_ACTIVE) begin
        Wr_Add_Issue <= 1'b0;
        No_Wr_Ready <= 1'b0;
      end
      else if(Wr_Lat_Start == 1'b0) begin    // If address issue as start point 
        if(AWVALID == 1'b1 && AWREADY == 1'b1 && No_Wr_Ready == 1'b0 && Data_Valid == 1'b1) begin //Address issue&accept
          Wr_Add_Issue <= 1'b1;
          No_Wr_Ready <= 1'b0;
        end
        else if(AWVALID == 1'b1 && AWREADY == 1'b1 && No_Wr_Ready == 1'b1 && Data_Valid == 1'b1) begin//No_Wr_Readyreset
          Wr_Add_Issue <= 1'b0;
          No_Wr_Ready <= 1'b0;
        end
        else if(AWVALID == 1'b1 && AWREADY == 1'b0 && No_Wr_Ready == 1'b0 && Data_Valid == 1'b1)begin //Address issue
          Wr_Add_Issue <= 1'b1;
          No_Wr_Ready <=  1'b1;
        end
        else if(AWVALID == 1'b0 && Data_Valid == 1'b1) begin //No valid address
          Wr_Add_Issue <= 1'b0;
          No_Wr_Ready <=  1'b0;
        end
        else begin //This is to stop address issue assertion when there is no AWREADY
          Wr_Add_Issue <= 1'b0;  
          No_Wr_Ready <=  No_Wr_Ready;
        end
      end
      else begin
        Wr_Add_Issue <= 1'b0;
        No_Wr_Ready <= 1'b0;
      end
    end  

    //Read address issuance logic
    always @(posedge clk) begin
      if (rst_int_n == RST_ACTIVE) begin
          Rd_Add_Issue <= 1'b0;
          No_Rd_Ready  <= 1'b0;
      end
      else if(Rd_Lat_Start == 1'b0) begin  //If address issue as start point
        if(ARVALID == 1'b1 && ARREADY == 1'b1 && No_Rd_Ready == 1'b0 && Data_Valid == 1'b1) begin //Address issue&accept
          Rd_Add_Issue <= 1'b1;
          No_Rd_Ready  <= 1'b0;
        end
        else if(ARVALID==1'b1 && ARREADY==1'b1 && No_Rd_Ready==1'b1 && Data_Valid==1'b1)begin//Resetting No_Rd_Ready 
          Rd_Add_Issue <= 1'b0;
          No_Rd_Ready  <=  1'b0;
        end
        else if(ARVALID == 1'b1 && ARREADY == 1'b0 && No_Rd_Ready == 1'b0 && Data_Valid == 1'b1)begin //Address issue 
          Rd_Add_Issue <= 1'b1;
          No_Rd_Ready  <=  1'b1;
        end
        else if(ARVALID == 1'b0 && Data_Valid == 1'b1) begin // No valid address
          Rd_Add_Issue <= 1'b0;
          No_Rd_Ready  <=  1'b0;
        end
        else begin 
          Rd_Add_Issue <= 1'b0;  //This is to stop address issue assertion when there is no ARREADY
          No_Rd_Ready  <= No_Rd_Ready;
        end
      end
      else begin
        Rd_Add_Issue <= 1'b0;
        No_Rd_Ready  <= 1'b0;
      end
    end  

    //Latency start and end points selection based on control register
    //Default latency calculation is from write/read address issue to last write/read
    wire wr_latency_start = Wr_Lat_Start?Wr_Addr_Lat:Wr_Add_Issue;
    wire First_Write_sel  = Wr_Lat_Start?First_Write:First_Write_reg;
    wire Last_Write_sel   = Wr_Lat_Start?Last_Write:Last_Write_reg;
    wire wr_latency_end   = Wr_Lat_End?First_Write_sel:Last_Write_sel;
    wire First_Read_sel   = Rd_Lat_Start?First_Read:First_Read_reg;
    wire Last_Read_sel   = Rd_Lat_End?Last_Read:Last_Read_reg;
    wire rd_latency_start = Rd_Lat_Start?Rd_Addr_Lat:Rd_Add_Issue;
    wire rd_latency_end  = Rd_Lat_End?First_Read_sel:Last_Read_sel;
    wire [C_METRIC_COUNT_WIDTH-1:0] Latency_Load_value = ONE;

    //-- Write_going_on for First_Write_Flag generation
    always @(posedge clk) begin 
       if (rst_int_n == RST_ACTIVE) begin
           Write_going_on <= 1'b0;
       end
       else begin
           if (Last_Write == 1'b1) begin
               Write_going_on <= 1'b0;
           end
           else if (First_Write == 1'b1)  begin
               Write_going_on <= 1'b1;
           end
           else begin
               Write_going_on <= Write_going_on;
           end
       end
    end 

//    //-- Write latency calculation 
//     always @(posedge clk) begin 
//       if(rst_int_n == RST_ACTIVE) begin
//           Wr_Latency_Fifo_Wr_En   <= 1'b0;
//           Wr_Latency_Fifo_Wr_Data <= 0;
//       end
//       else begin // Id ignoring 
//           if(wr_latency_start == 1'b1) begin 
//              Wr_Latency_Fifo_Wr_En   <= ~ Wr_Latency_Fifo_Full;
//	      if(Wr_cnt_ld == 1'b1) begin
//                Wr_Latency_Fifo_Wr_Data <= ONE;
//              end
//	      else begin
//                Wr_Latency_Fifo_Wr_Data <= Write_Latency_Cnt_Out;
//              end 
//           end
//           else begin
//              Wr_Latency_Fifo_Wr_En   <= 1'b0;
//              Wr_Latency_Fifo_Wr_Data <= Wr_Latency_Fifo_Wr_Data;
//           end
//       end
//    end
//
//   // Reading the FIFO loaded with the count when write started 
//   always @(posedge clk) begin 
//       if(rst_int_n == RST_ACTIVE) begin
//           Wr_Latency_Fifo_Rd_En          <= 1'b0;
//           Wr_Latency_Fifo_Rd_En_D1       <= 1'b0;
//           Wr_Latency_Fifo_Rd_En_D2       <= 1'b0;
//           Write_Latency_Cnt_Out_D1       <= 0;  
//           Write_Latency_Cnt_Out_D2       <= 0;  
//           Write_Latency_One              <= 0;       //when write end comes with in one clock 
//           Write_Latency_One_D1           <= 0;
//           Wr_Latency_Fifo_Rd_Data_D1     <= 0;
//       end
//       else begin   
//           Wr_Latency_Fifo_Rd_En_D1       <= Wr_Latency_Fifo_Rd_En;
//           Wr_Latency_Fifo_Rd_En_D2       <= Wr_Latency_Fifo_Rd_En_D1;
//           Write_Latency_Cnt_Out_D1       <= Write_Latency_Cnt_Out;  
//           Write_Latency_Cnt_Out_D2       <= Write_Latency_Cnt_Out_D1;  
//           Write_Latency_One_D1           <= Write_Latency_One && ~Wr_Latency_Fifo_Empty;
//           Wr_Latency_Fifo_Rd_Data_D1     <= Wr_Latency_Fifo_Rd_Data;
//           if(wr_latency_end==1'b1 ) begin 
//              Wr_Latency_Fifo_Rd_En       <=  ~ Wr_Latency_Fifo_Empty;
//              Write_Latency_One           <=  Wr_Latency_Fifo_Empty;
//           end
//           else begin
//              Wr_Latency_Fifo_Rd_En       <= 1'b0;
//              Write_Latency_One           <= 0;
//           end
//       end
//    end
//    assign Wr_Latency_Fifo_Rd_En_out = Wr_Latency_Fifo_Rd_En |  Write_Latency_One_D1;
    
//K K START 
// New architecture for id based filtering calculation.
// Take 4 FIFOs: 
// F1: To store awid match/not match information
// F2: To store first write on write channel for each transaction.
// F3: Time stamp at latency start point
// F4: Time stamp at latency end   point
// How this works:
// Write to F1 awid match information when a Address detected
// Write to F2 when the first write on write channel detected
// Write to F3 when "latency start point" detected
// Write to F4 when "latency end   point" detected
// 
// Read F1&F2 when both are not empty
// Generate wid-match if Rd.data.F1 = 1 and Rd.data.F2 = 1
//  use this as qualifier to generate beat cnt,idle cnt, wlast cnt. 
//  Delay the corresponding beat,idle,wlast data based on above read.
//
// Read F3&F4 when both are not empty
//  use wid-match generated above to qualify if we need calculate latency
//  if(wid.match)
//    update min/max/total latency
//  else no update  
//

//F1
//Delay Write_Beat,Wr_Idle,Last_Write based on above FIFOs read data
//availability
//
//reg  Write_Beat_d1;//,Write_Beat_d2,Write_Beat_d3,Write_Beat_d4;
////reg  Wr_Idle_d1,Wr_Idle_d2,Wr_Idle_d3,Wr_Idle_d4;
////reg  Last_Write_d1;
////,Last_Write_d2;
//reg  [C_METRIC_COUNT_WIDTH-1:0] wr_byte_cnt_d1;
////reg [C_METRIC_COUNT_WIDTH-1:0] wr_byte_cnt_d2;
////reg [C_METRIC_COUNT_WIDTH-1:0] wr_byte_cnt_d3;
////reg [C_METRIC_COUNT_WIDTH-1:0] wr_byte_cnt_d4;
//reg  Last_Write_d1;//,Last_Write_d2,Last_Write_d3,Last_Write_d4,Last_Write_cnt2;
//always @(posedge clk) begin
//  if (rst_int_n == RST_ACTIVE) begin
//      Write_Beat_d1  <= 1'b0;
//     // Write_Beat_d2  <= 1'b0;
//     // Write_Beat_d3  <= 1'b0;
//     // Write_Beat_d4  <= 1'b0;
//     // Write_Beat_reg <= 1'b0;
//     // Wr_Idle_d1     <= 1'b0;
//     // Wr_Idle_d2     <= 1'b0;
//     // Wr_Idle_d3     <= 1'b0;
//     // Wr_Idle_d4     <= 1'b0;
//     // Wr_Idle_reg    <= 1'b0;
//      Last_Write_d1  <= 1'b0;
//     // Last_Write_d2  <= 1'b0;
//     // Last_Write_d3  <= 1'b0;
//     // Last_Write_d4  <= 1'b0;
//     // Last_Write_reg <= 1'b0;
//     // Last_Write_cnt2 <= 1'b0;
//      wr_byte_cnt_d1 <= 1'b0;
//      //wr_byte_cnt_d2 <= 1'b0;
//      //wr_byte_cnt_d3 <= 1'b0;
//      //wr_byte_cnt_d4 <= 1'b0;
//      //wr_byte_cnt_reg <= 1'b0;
//  end else begin
//      Write_Beat_d1  <= Write_Beat;
//      //Write_Beat_d2  <= Write_Beat_d1;
//      //Write_Beat_d3  <= Write_Beat_d2;
//      //Write_Beat_d4  <= Write_Beat_d3;
//      //Write_Beat_reg <= Write_Beat_d4;
//      //Wr_Idle_d1     <= Wr_Idle;
//      //Wr_Idle_d2     <= Wr_Idle_d1;
//      //Wr_Idle_d3     <= Wr_Idle_d2;
//      //Wr_Idle_d4     <= Wr_Idle_d3;
//      //Wr_Idle_reg    <= Wr_Idle_d4;
//      Last_Write_d1  <= Last_Write;
//      //Last_Write_d2  <= Last_Write_d1;
//      //Last_Write_d3  <= Last_Write_d2;
//      //Last_Write_d4  <= Last_Write_d3;
//      //Last_Write_reg <= Last_Write_d4;
//      //if(Wr_Lat_Start == 1'b0 && Wr_Lat_End == 1'b0)
//      //Last_Write_cnt2 <= Last_Write_d3;
//      //else
//      //Last_Write_cnt2 <= Last_Write_d4;
//      wr_byte_cnt_d1 <= wr_byte_cnt;
//      //wr_byte_cnt_d2 <= wr_byte_cnt_d1;
//      //wr_byte_cnt_d3 <= wr_byte_cnt_d2;
//      //wr_byte_cnt_d4 <= wr_byte_cnt_d3;
//      //wr_byte_cnt_reg <= wr_byte_cnt_d4;
//  end
//end

//Latency Fifos
wire F3_Wr_En,F3_Rd_En;
reg F34_Rd_Vld;
wire F34_Rd_En;
//reg F3_Rd_En;
wire [C_METRIC_COUNT_WIDTH:0] F3_Wr_Data;
wire [C_METRIC_COUNT_WIDTH:0] F3_Rd_Data;
reg wr_latency_start_d1;//,awid_match_d1;
//reg wr_latency_start_d2,awid_match_d2;
always @(posedge clk) begin
if (rst_int_n == RST_ACTIVE) begin
        wr_latency_start_d1 <= 1'b0;
     //   wr_latency_start_d2 <= 1'b0;
        //awid_match_d1 <= 1'b0;
        //awid_match_d2 <= 1'b0;
    end else begin
        wr_latency_start_d1 <= wr_latency_start;
   //     wr_latency_start_d2 <= wr_latency_start_d1;
        //awid_match_d1 <= awid_match_lat;
        //awid_match_d2 <= awid_match_d1;
    end
end
assign F3_Wr_En   = wr_latency_start_d1; 
assign F3_Wr_Data = {Write_Latency_Cnt_Ovf,Write_Latency_Cnt_Out}; 

 
    axi_perf_mon_v5_0_12_sync_fifo 
     #(
        .WIDTH      (C_METRIC_COUNT_WIDTH+1),
        .DEPTH_LOG2 (5)
     ) F3_WR_LAT_START
     (
       .rst_n    (rst_int_n),
       .clk      (clk),
       .wren     (F3_Wr_En   ),
       .rden     (F3_Rd_En   ),
       .din      (F3_Wr_Data ),
       .dout     (F3_Rd_Data ),
       .full     (           ),
       .empty    (F3_Empty   )
     );


wire F4_Wr_En,F4_Rd_En;
wire [C_METRIC_COUNT_WIDTH:0] F4_Wr_Data;
wire [C_METRIC_COUNT_WIDTH:0] F4_Rd_Data;
reg wr_latency_end_d1;//,wr_latency_end_d2;

always @(posedge clk) begin
if (rst_int_n == RST_ACTIVE) begin
        wr_latency_end_d1 <= 1'b0;
        //wr_latency_end_d2 <= 1'b0;
    end else begin
        wr_latency_end_d1 <= wr_latency_end;
        //wr_latency_end_d2 <= wr_latency_end_d1;
    end
end


//assign F4_Wr_En   = ((Wr_Lat_Start || Wr_Lat_End) == 1'b0)?wr_latency_end:wr_latency_end_d1; 
assign F4_Wr_En   = wr_latency_end_d1; 
assign F4_Wr_Data = {Write_Latency_Cnt_Ovf,Write_Latency_Cnt_Out}; 

 
    axi_perf_mon_v5_0_12_sync_fifo 
     #(
        .WIDTH      (C_METRIC_COUNT_WIDTH+1),
        .DEPTH_LOG2 (5)
     ) F4_WR_LAT_END
     (
       .rst_n    (rst_int_n),
       .clk      (clk),
       .wren     (F4_Wr_En   ),
       .rden     (F4_Rd_En   ),
       .din      (F4_Wr_Data ),
       .dout     (F4_Rd_Data ),
       .full     (           ),
       .empty    (F4_Empty   )
     );

//Rd F3,F4 and update latency if wid_matches 
assign F34_Rd_En = (F3_Empty == 1'b0) && (F4_Empty == 1'b0);
assign F3_Rd_En = F34_Rd_En;
assign F4_Rd_En = F34_Rd_En;

  always @(posedge clk) begin
    if (rst_int_n == RST_ACTIVE) begin
        F34_Rd_Vld <= 1'b0;
    end else begin
        F34_Rd_Vld <= F34_Rd_En;
    end
  end

//wire [C_METRIC_COUNT_WIDTH-1:0] Wr_Lat_Cnt_Diff;
reg update_min_Wr_Lat;
reg update_max_Wr_Lat;


//Below logic is for timing violation fix Wr_Lat_Cnt_Diff_reg F34_Rd_Vld_reg 
reg F34_Rd_Vld_reg; 
reg [C_METRIC_COUNT_WIDTH-1:0] Wr_Lat_Cnt_Diff_reg;
always @(posedge clk) begin
    if (rst_int_n == RST_ACTIVE) begin
      F34_Rd_Vld_reg       <= 0;
      Wr_Lat_Cnt_Diff_reg  <= 0;
    end else begin
      if(F34_Rd_Vld) begin
       if(F4_Rd_Data[C_METRIC_COUNT_WIDTH] ^ F3_Rd_Data[C_METRIC_COUNT_WIDTH]) begin
          if(F3_Rd_Data[C_METRIC_COUNT_WIDTH-1:0]>F4_Rd_Data[C_METRIC_COUNT_WIDTH-1:0]) begin
              Wr_Lat_Cnt_Diff_reg  <= (~(F3_Rd_Data[C_METRIC_COUNT_WIDTH-1:0]) + F4_Rd_Data[C_METRIC_COUNT_WIDTH-1:0])+1'b1;//:(F4_Rd_Data - F3_Rd_Data);;
          end else begin
              Wr_Lat_Cnt_Diff_reg <= (~F4_Rd_Data[C_METRIC_COUNT_WIDTH-1:0]) + F3_Rd_Data[C_METRIC_COUNT_WIDTH-1:0]+1'b1;
          end
      end
      else begin
        if(F3_Rd_Data[C_METRIC_COUNT_WIDTH-1:0]>F4_Rd_Data[C_METRIC_COUNT_WIDTH-1:0]) begin
             Wr_Lat_Cnt_Diff_reg  <= (F3_Rd_Data[C_METRIC_COUNT_WIDTH-1:0] - F4_Rd_Data[C_METRIC_COUNT_WIDTH-1:0]);//:(F4_Rd_Data - F3_Rd_Data);;
        end else begin
            Wr_Lat_Cnt_Diff_reg  <= F4_Rd_Data[C_METRIC_COUNT_WIDTH-1:0] - F3_Rd_Data[C_METRIC_COUNT_WIDTH-1:0];
        end
     end
    end
      F34_Rd_Vld_reg <= F34_Rd_Vld;
    end
  end
reg [C_METRIC_COUNT_WIDTH-1:0] Wr_Lat_Cnt_Diff_reg1;
reg F34_Rd_Vld_reg_d2;//,wid_match_reg_d2;
always @(posedge clk) begin
    if (rst_int_n == RST_ACTIVE) begin
      update_min_Wr_Lat    <= 0;
      update_max_Wr_Lat    <= 0;
      Wr_Lat_Cnt_Diff_reg1  <= 0;
    end else begin
      if(F34_Rd_Vld_reg) begin
       update_min_Wr_Lat    <= Wr_Lat_Cnt_Diff_reg < Min_Write_Latency_Int;
	    update_max_Wr_Lat    <= Wr_Lat_Cnt_Diff_reg > Max_Write_Latency_Int;
     end
     Wr_Lat_Cnt_Diff_reg1  <= Wr_Lat_Cnt_Diff_reg;
     F34_Rd_Vld_reg_d2 <= F34_Rd_Vld_reg;
     //wid_match_reg_d2  <= wid_match_reg;
    end
end
  //Total wr.latency
  always @(posedge clk) begin
    if (rst_int_n == RST_ACTIVE) begin
        Write_Latency_Int <= 1'b0;
        Write_Latency_En_Int <= 1'b0;
    end else if(F34_Rd_Vld_reg_d2) begin
        Write_Latency_Int <= Wr_Lat_Cnt_Diff_reg1;
        Write_Latency_En_Int <= Metrics_Cnt_En_Int;
    end else
        Write_Latency_En_Int <= 1'b0;
  end

//Min wr.latency
  always @(posedge clk) begin
    if (rst_int_n == RST_ACTIVE) begin
      Min_Write_Latency_Int    <= ALL_ONES;
    end else if(F34_Rd_Vld_reg_d2 && update_min_Wr_Lat) begin
      Min_Write_Latency_Int    <= Wr_Lat_Cnt_Diff_reg1;
    end
  end

//Max wr.latency
  always @(posedge clk) begin
    if (rst_int_n == RST_ACTIVE) begin
      Max_Write_Latency_Int    <= 0;
    end else if(F34_Rd_Vld_reg_d2 && update_max_Wr_Lat) begin
      Max_Write_Latency_Int    <= Wr_Lat_Cnt_Diff_reg1;
    end
  end
    assign Min_Write_Latency = Min_Write_Latency_Int;
    assign Max_Write_Latency = Max_Write_Latency_Int;
    assign Write_Latency    = Write_Latency_Int;     //Actual Latency
    assign Write_Latency_En = Write_Latency_En_Int; //Latency Valid

///*------------------Registering Beat Count metric  for all scenarios------------------*/
// reg [C_METRIC_COUNT_WIDTH-1:0] Write_Beat_Cnt_i;  
// reg [C_METRIC_COUNT_WIDTH-1:0] Write_Byte_Cnt_i;  
// reg Beat_fifo_Wr_en;  
// reg [(C_METRIC_COUNT_WIDTH*2)-1:0] Beat_fifo_Wr_data;  
// wire [(C_METRIC_COUNT_WIDTH*2)-1:0] FBC1_Rd_Data;  
// wire FBC1_Empty;  
// wire FBC_Empty;  
// wire FBC_Rd_Data;  
//  always @(posedge clk) begin 
//       if (rst_int_n == RST_ACTIVE) begin
//           Write_Beat_Cnt_i     <= { {31{1'b0}}, 1'b1 };
//           Write_Byte_Cnt_i     <= zeros;
//           Beat_fifo_Wr_en <= 1'b0;
//       end
//       else begin
//           if(Last_Write_d1) begin
//           Beat_fifo_Wr_en <= 1'b1;
//           Beat_fifo_Wr_data <= {(Write_Byte_Cnt_i+wr_byte_cnt_d1),Write_Beat_Cnt_i};
//           Write_Byte_Cnt_i     <=  zeros;
//           Write_Beat_Cnt_i     <=  { {31{1'b0}}, 1'b1 };
//           end
//           else if(Write_Beat_d1) begin
//           Beat_fifo_Wr_en <= 1'b0;
//           Write_Beat_Cnt_i     <=  Write_Beat_Cnt_i+1'b1;
//           Write_Byte_Cnt_i     <=  Write_Byte_Cnt_i+wr_byte_cnt_d1;
//          end
//          else
//           Beat_fifo_Wr_en <= 1'b0;
//    end 
//  end
//    axi_perf_mon_v5_0_12_sync_fifo 
//     #(
//        .WIDTH      (C_METRIC_COUNT_WIDTH*2),
//        .DEPTH_LOG2 (5)
//     ) FBC_WR_BEAT_CNT
//     (
//       .rst_n    (rst_int_n),
//       .clk      (clk),
//       .wren     (Beat_fifo_Wr_en   ),
//       .rden     (FBC_Rd_En   ),
//       .din      (Beat_fifo_Wr_data ),
//       .dout     (FBC1_Rd_Data ),
//       .full     (           ),
//       .empty    (FBC1_Empty   )
//     );
//
////assign F1_Wr_En   = Wr_Add_Issue;//wr_latency_start; 
////assign F1_Wr_Data = awid_match_d1 || ~(En_Id_Based);
//   axi_perf_mon_v5_0_12_sync_fifo 
//     #(
//        .WIDTH      (1), 
//        .DEPTH_LOG2 (5) 
//     ) BEAT_CNT_AWID_MATCH
//     (
//       .rst_n    (rst_int_n),
//       .clk      (clk),
//       .wren     (F1_Wr_En   ),
//       .rden     (FBC_Rd_En   ),
//       .din      (F1_Wr_Data ),
//       .dout     (FBC_Rd_Data ),
//       .full     (           ),
//       .empty    (FBC_Empty   )
//     );
//assign FBC_Rd_En = (FBC1_Empty == 1'b0) && (FBC_Empty == 1'b0);
//
//reg FBC_Rd_Vld;
//  always @(posedge clk) begin
//    if (rst_int_n == RST_ACTIVE) begin
//        FBC_Rd_Vld <= 1'b0;
//    end else begin
//        FBC_Rd_Vld <= FBC_Rd_En;
//    end
//  end
//
//assign Write_Beat_Cnt_En = (FBC_Rd_Vld)? FBC_Rd_Data: 1'b0;
//assign Write_Beat_Cnt = (FBC_Rd_Vld)? FBC1_Rd_Data[C_METRIC_COUNT_WIDTH-1:0]: zeros;
//assign Write_Byte_Cnt = (FBC_Rd_Vld)? FBC1_Rd_Data[(C_METRIC_COUNT_WIDTH*2)-1:C_METRIC_COUNT_WIDTH]: zeros;

//K K END


// Write latency FIFO occupancy based on write and reads to FIFO
//    always @(posedge clk) begin 
//       if(rst_int_n == RST_ACTIVE) begin
//           Wr_Latency_Occupancy   <= 0;
//       end
//       else begin
//           if(wr_latency_start == 1'b1 && wr_latency_end == 1'b1) begin  
//              Wr_Latency_Occupancy   <= Wr_Latency_Occupancy;
//           end
//           else if(wr_latency_start==1'b1) begin 
//              Wr_Latency_Occupancy   <= Wr_Latency_Occupancy + 1'b1;
//           end
//           else if(wr_latency_end == 1'b1 && Wr_Latency_Occupancy != 0) begin 
//              Wr_Latency_Occupancy   <= Wr_Latency_Occupancy - 1'b1;
//           end
//       end
//    end

     //-- WR latency FIFO Instance to store outstanding transactions
//    axi_perf_mon_v5_0_12_sync_fifo 
//     #(
//        .WIDTH      (C_METRIC_COUNT_WIDTH), // The width of the FIFO data
//        .DEPTH_LOG2 (5                   )  // Specify power-of-2 FIFO depth
//     ) wr_latency_fifo_inst
//     (
//       .rst_n    (rst_int_n),
//       .clk      (clk),
//       .wren     (Wr_Latency_Fifo_Wr_En),
//       .rden     (Wr_Latency_Fifo_Rd_En_out),
//       .din      (Wr_Latency_Fifo_Wr_Data),
//       .dout     (Wr_Latency_Fifo_Rd_Data),
//       .full     (Wr_Latency_Fifo_Full),
//       .empty    (Wr_Latency_Fifo_Empty)
//     );
//
//    //-- Overflow capture of write latency counter for better timing  
//    //To address overflow of the counter between Latency start and end `
//    always @(posedge clk) begin 
//       if(rst_int_n == RST_ACTIVE) begin
//          Write_Latency_Ovf <= 0;
//       end
//       else if(Wr_Latency_Fifo_Rd_En_D1 == 1'b1) begin
//         if(Write_Latency_Cnt_Out_D1 < Wr_Latency_Fifo_Rd_Data) begin
//            Write_Latency_Ovf <= 1'b1;
//         end
//         else begin  
//            Write_Latency_Ovf <= 1'b0; 
//         end
//       end
//    end
 
    //-- Write latency capture from fifo read data with current counter value
  //  always @(posedge clk) begin 
  //     if(rst_int_n == RST_ACTIVE) begin
  //        Write_Latency_Int    <= 0;
  //        Write_Latency_En_Int <= 0;
  //     end
  //     else begin
  //        if(Write_Latency_One_D1 == 1'b1) begin
  //            Write_Latency_Int    <= ONE;
  //            Write_Latency_En_Int <= Metrics_Cnt_En_Int;
  //        end
  //        else if(Wr_Latency_Fifo_Rd_En_D2 == 1'b1) begin
  //            if(Write_Latency_Ovf == 1'b0) begin
  //               Write_Latency_Int    <= Write_Latency_Cnt_Out_D2 - Wr_Latency_Fifo_Rd_Data_D1;
  //               Write_Latency_En_Int <= Metrics_Cnt_En_Int;
  //            end
  //            else begin  //To address overflow of the counter between Latency start and end 
  //               Write_Latency_Int    <= ~(Wr_Latency_Fifo_Rd_Data_D1) +  Write_Latency_Cnt_Out_D2;
  //               Write_Latency_En_Int <= Metrics_Cnt_En_Int;
  //            end
  //        end
  //        else begin
  //          Write_Latency_Int    <= Write_Latency_Int;
  //          Write_Latency_En_Int <= 1'b0;
  //        end
  //     end
  //  end

//   assign Write_Latency    = Write_Latency_Int;     //Actual Latency
  // assign Write_Latency_En = Write_Latency_En_Int; //Latency Valid
 //  wire  Write_Lat_Cnt_en  = Metrics_Cnt_En_Int & Data_Valid; //Counter enable for ID based

    //--Minimum write latency calculation
    //--Valid only if id based latency is selected
  //  always @(posedge clk) begin 
  //     if(rst_int_n == RST_ACTIVE) begin
  //        Min_Write_Latency_Int    <= ALL_ONES;
  //     end
  //     else begin
  //        if(Write_Latency_Int < Min_Write_Latency_Int && Write_Latency_En_Int == 1'b1)begin
  //           Min_Write_Latency_Int    <= Write_Latency_Int;
  //        end
  //        else begin
  //           Min_Write_Latency_Int    <= Min_Write_Latency_Int;
  //        end
  //     end
  //  end

    //assign Min_Write_Latency = Min_Write_Latency_Int;

    //--Maximum write latency calculation
    //--Valid only if id based latency is selected
   // always @(posedge clk) begin 
   //    if(rst_int_n == RST_ACTIVE) begin
   //       Max_Write_Latency_Int    <= 0;
   //    end
   //    else begin
   //       if(Write_Latency_Int > Max_Write_Latency_Int && Write_Latency_En_Int == 1'b1)begin
   //          Max_Write_Latency_Int    <= Write_Latency_Int;
   //       end
   //       else begin
   //          Max_Write_Latency_Int    <= Max_Write_Latency_Int;
   //       end
   //    end
   // end
 
  //assign Max_Write_Latency = Max_Write_Latency_Int;
  
  


  assign Wr_Latcnt_rst_n = rst_int_n;
  //wire  Write_Lat_Cnt_en  = Metrics_Cnt_En_Int & Data_Valid; //Counter enable
  reg Data_valid_reg,Data_valid_reg1,Data_valid_reg2;
 wire Data_valid_wire;
   always @(posedge clk) begin 
       if(rst_int_n == RST_ACTIVE) begin
          Data_valid_reg    <= 1'b0;
          Data_valid_reg1    <= 1'b0;
          //Data_valid_reg2    <= 1'b0;
       end
       else begin
          Data_valid_reg    <= Data_Valid;
          Data_valid_reg1    <= Data_valid_reg;
          //Data_valid_reg2    <= Data_valid_reg1;
       end
    end
  assign Data_valid_wire = Wr_Lat_Start?Data_valid_reg:Data_valid_reg1;
  wire  Write_Lat_Cnt_en  = Metrics_Cnt_En_Int & Data_valid_wire; //Counter enable for ID based

  assign Wr_cnt_ld           = ~(rst_int_n);
  //assign Wr_cnt_ld = ~ (| Wr_Latency_Occupancy);
 
    //--Write latency counter
    //--Counter Instantiation
    //--This counter will be enabled only when id based latency is enabled
    axi_perf_mon_v5_0_12_counter_ovf 
    #(
         .C_FAMILY             ("nofamily"),
         .C_NUM_BITS           (C_METRIC_COUNT_WIDTH),
         .COUNTER_LOAD_VALUE   (32'h00000000)
     ) wr_latency_cnt_inst 
     (
         .clk                  (clk),
         .rst_n                (Wr_Latcnt_rst_n),
         .Load_In              (Latency_Load_value),
         .Count_Enable         (Write_Lat_Cnt_en),
         .Count_Load           (Wr_cnt_ld),
         .Count_Down           (1'b0),
         .Count_Out            (Write_Latency_Cnt_Out),
         .Carry_Out            (Write_Latency_Cnt_Ovf)
     );


    //-- Read_going_on for First_Read_Flag generation
    //-- First read flag is only valid in case of id based latency
    always @(posedge clk) begin 
       if (rst_int_n == RST_ACTIVE) begin
           Read_going_on  <= 1'b0;
       end
       else begin
         if (Last_Read == 1'b1) begin
             Read_going_on  <= 1'b0;
         end
         else if (First_Read == 1'b1) begin 
             Read_going_on  <= 1'b1;
         end
         else begin
             Read_going_on  <= Read_going_on;
         end
       end
    end 

    //-- Read latency calculation 
     always @(posedge clk) begin 
       if(rst_int_n == RST_ACTIVE) begin
           Rd_Latency_Fifo_Wr_En   <= 1'b0;
           Rd_Latency_Fifo_Wr_Data <= 0;
       end
       else begin  
           if(rd_latency_start == 1'b1) begin
              Rd_Latency_Fifo_Wr_En   <= ~ Rd_Latency_Fifo_Full;
	     // if(Rd_cnt_ld == 1'b1) begin
                 Rd_Latency_Fifo_Wr_Data <= ONE;
          //    end
	      //else begin
                Rd_Latency_Fifo_Wr_Data <= {Read_Latency_Cnt_Ovf,Read_Latency_Cnt_Out};
           //   end
           end
           else begin
              Rd_Latency_Fifo_Wr_En   <= 1'b0;
              Rd_Latency_Fifo_Wr_Data <= Rd_Latency_Fifo_Wr_Data;
           end
       end
    end

    // Reading the FIFO loaded with the count when read started 
   always @(posedge clk) begin 
       if(rst_int_n == RST_ACTIVE) begin
           Rd_Latency_Fifo_Rd_En      <= 1'b0;
           Rd_Latency_Fifo_Rd_En_D1   <= 1'b0;
           Rd_Latency_Fifo_Rd_En_D2   <= 1'b0;
           Read_Latency_Cnt_Out_D1    <= 0;
           Read_Latency_Cnt_Out_D2    <= 0;
           Read_Latency_One           <= 0;       //when read response comes with in one clock 
           Read_Latency_One_D1        <= 0;
           Rd_Latency_Fifo_Rd_Data_D1 <= 0;
       end
       else begin
           Rd_Latency_Fifo_Rd_En_D1   <= Rd_Latency_Fifo_Rd_En;
           Rd_Latency_Fifo_Rd_En_D2   <= Rd_Latency_Fifo_Rd_En_D1;
           Read_Latency_Cnt_Out_D1    <= {Read_Latency_Cnt_Ovf,Read_Latency_Cnt_Out};
           Read_Latency_Cnt_Out_D2    <= Read_Latency_Cnt_Out_D1;
           Read_Latency_One_D1        <= Read_Latency_One & ~Rd_Latency_Fifo_Empty;
           Rd_Latency_Fifo_Rd_Data_D1 <= Rd_Latency_Fifo_Rd_Data;
           if(rd_latency_end == 1'b1) begin
              Rd_Latency_Fifo_Rd_En   <=  ~Rd_Latency_Fifo_Empty;
              Read_Latency_One        <=   Rd_Latency_Fifo_Empty; 
           end
           else begin
              Rd_Latency_Fifo_Rd_En   <= 1'b0;
              Read_Latency_One        <= 0;    //when read response comes with in one clock 
           end
       end
    end

    assign Rd_Latency_Fifo_Rd_En_out = Rd_Latency_Fifo_Rd_En | Read_Latency_One_D1;

 //-- Rd latency FIFO Instance to store outstanding transactions
     axi_perf_mon_v5_0_12_sync_fifo 
     #(
        .WIDTH       (C_METRIC_COUNT_WIDTH+1), // The width of the FIFO data
        .DEPTH_LOG2  (5                   )  // Specify power-of-2 FIFO depth
     ) rd_latency_fifo_inst 
     (
       .rst_n    (rst_int_n),
       .clk      (clk),
       .wren     (Rd_Latency_Fifo_Wr_En),
       .rden     (Rd_Latency_Fifo_Rd_En_out),
       .din      (Rd_Latency_Fifo_Wr_Data),
       .dout     (Rd_Latency_Fifo_Rd_Data),
       .full     (Rd_Latency_Fifo_Full),
       .empty    (Rd_Latency_Fifo_Empty)
     );
    
     // Read latency FIFO occupancy based on write and reads to FIFO
    always @(posedge clk) begin 
       if(rst_int_n == RST_ACTIVE) begin
           Rd_Latency_Occupancy   <= 0;
       end
       else begin
           if(rd_latency_start == 1'b1 && rd_latency_end == 1'b1 ) begin 
             Rd_Latency_Occupancy   <= Rd_Latency_Occupancy;
           end
           else if(rd_latency_start==1'b1) begin
              Rd_Latency_Occupancy   <= Rd_Latency_Occupancy + 1'b1;
           end
           else if(rd_latency_end == 1'b1 && Rd_Latency_Occupancy != 0 ) begin
              Rd_Latency_Occupancy   <= Rd_Latency_Occupancy - 1'b1;
           end
       end
    end
   
    //-- Overflow capture of read latency counter for better timing  
    //-- To address overflow of the counter between Latency start and end `
  //  always @(posedge clk) begin 
  //     if(rst_int_n == RST_ACTIVE) begin
  //        Read_Latency_Ovf <= 0;
  //     end
  //     else if(Rd_Latency_Fifo_Rd_En_D1 == 1'b1) begin
  //       if(Read_Latency_Cnt_Out_D1 < Rd_Latency_Fifo_Rd_Data) begin
  //          Read_Latency_Ovf <= 1'b1;
  //       end
  //       else begin  
  //          Read_Latency_Ovf <= 1'b0; 
  //       end
  //     end
  //  end


    //-- Read latency capture from fifo read data with current counter value
    always @(posedge clk) begin 
       if(rst_int_n == RST_ACTIVE) begin
          Read_Latency_Int    <= 0;
          Read_Latency_En_Int <= 0;
       end
       else begin
          if(Read_Latency_One_D1 == 1'b1) begin
             Read_Latency_Int    <= ONE;
             Read_Latency_En_Int <= Metrics_Cnt_En_Int;
          end
         else if(Rd_Latency_Fifo_Rd_En_D1 == 1'b1) begin
           if(Read_Latency_Cnt_Out_D2[C_METRIC_COUNT_WIDTH] ^ Rd_Latency_Fifo_Rd_Data_D1[C_METRIC_COUNT_WIDTH]) begin
             if(Rd_Latency_Fifo_Rd_Data_D1[C_METRIC_COUNT_WIDTH-1:0] > Read_Latency_Cnt_Out_D2[C_METRIC_COUNT_WIDTH-1:0]) begin
                 Read_Latency_Int  <= (~(Rd_Latency_Fifo_Rd_Data_D1[C_METRIC_COUNT_WIDTH-1:0]) + Read_Latency_Cnt_Out_D2[C_METRIC_COUNT_WIDTH-1:0])+1'b1;//:(F4_Rd_Data - F3_Rd_Data);;
             end else begin
              Read_Latency_Int <= (~Read_Latency_Cnt_Out_D2[C_METRIC_COUNT_WIDTH-1:0]) + Rd_Latency_Fifo_Rd_Data_D1[C_METRIC_COUNT_WIDTH-1:0]+1'b1;
             end
           end
          else begin
            if(Rd_Latency_Fifo_Rd_Data_D1[C_METRIC_COUNT_WIDTH-1:0] > Read_Latency_Cnt_Out_D2[C_METRIC_COUNT_WIDTH-1:0]) begin
               Read_Latency_Int  <= (Rd_Latency_Fifo_Rd_Data_D1[C_METRIC_COUNT_WIDTH-1:0] - Read_Latency_Cnt_Out_D2[C_METRIC_COUNT_WIDTH-1:0]);//:(F4_Rd_Data - F3_Rd_Data);;
            end else begin
               Read_Latency_Int  <= Read_Latency_Cnt_Out_D2[C_METRIC_COUNT_WIDTH-1:0] - Rd_Latency_Fifo_Rd_Data_D1[C_METRIC_COUNT_WIDTH-1:0];
            end
          end
               Read_Latency_En_Int <= Metrics_Cnt_En_Int;
        end
          else begin
            Read_Latency_Int    <= Read_Latency_Int;
            Read_Latency_En_Int <= 1'b0;
          end
       end
    end

    assign Read_Latency    = Read_Latency_Int;
    assign Read_Latency_En = Read_Latency_En_Int; 
  //  wire Read_Lat_Cnt_en   = Metrics_Cnt_En_Int & Data_Valid;
 wire Read_Data_valid_wire;
  assign Read_Data_valid_wire = Rd_Lat_Start?Data_Valid:Data_valid_reg;
 
    wire Read_Lat_Cnt_en   = Metrics_Cnt_En_Int & Read_Data_valid_wire;

    //--Minimum read latency calculation
    //--Valid only for ID based latency
    always @(posedge clk) begin 
       if(rst_int_n == RST_ACTIVE) begin
          Min_Read_Latency_Int    <= ALL_ONES;
       end
       else begin
          if(Read_Latency_Int < Min_Read_Latency_Int && Read_Latency_En == 1'b1)begin
             Min_Read_Latency_Int    <= Read_Latency;
          end
          else begin
             Min_Read_Latency_Int    <= Min_Read_Latency_Int;
          end
       end
    end

    assign Min_Read_Latency = Min_Read_Latency_Int;

    //--Maximum read latency calculation
    //--Valid only for ID based latency
    always @(posedge clk) begin 
       if(rst_int_n == RST_ACTIVE) begin
          Max_Read_Latency_Int    <= 0;
       end
       else begin
          if(Read_Latency_Int > Max_Read_Latency_Int && Read_Latency_En == 1'b1)begin
             Max_Read_Latency_Int    <= Read_Latency;
          end
          else begin
             Max_Read_Latency_Int    <= Max_Read_Latency_Int;
          end
       end
    end
 
    assign Max_Read_Latency = Max_Read_Latency_Int;
    assign Rd_Latcnt_rst_n = rst_int_n; 
    assign Rd_cnt_ld        = ~ (rst_int_n);//(|(Rd_Latency_Occupancy));

    //--Read latency counter
    //--Counter Instantiation
    axi_perf_mon_v5_0_12_counter_ovf 
    #(
         .C_FAMILY             ("nofamily"),
         .C_NUM_BITS           (C_METRIC_COUNT_WIDTH),
	      .COUNTER_LOAD_VALUE   (32'h00000000)
     ) rd_latency_cnt_inst 
     (
         .clk                  (clk),
         .rst_n                (Rd_Latcnt_rst_n),
         .Load_In              (Latency_Load_value),
         .Count_Enable         (Read_Lat_Cnt_en),
         .Count_Load           (Rd_cnt_ld),
         .Count_Down           (1'b0),
         .Count_Out            (Read_Latency_Cnt_Out),
         .Carry_Out            (Read_Latency_Cnt_Ovf)
     );

    /*------------------Registering all AXIMM metrics ------------------*/
generate if(C_AXI_SUB_PROTOCOL != "AXI4LITE") begin : GEN_ARSIZE_AXI4
    always @(posedge clk) begin 
       if (rst_int_n == RST_ACTIVE) begin
           Wtrans_Cnt_En     <= 1'b0;
           Rtrans_Cnt_En     <= 1'b0;
           Write_Beat_Cnt_En1 <= 1'b0;
           Write_Beat_Cnt_En <= 1'b0;
           Read_Beat_Cnt_En  <= 1'b0;
           Write_Byte_Cnt    <= 0;
           Write_Byte_Cnt2    <= 0;
           Write_Byte_Cnt1    <= 0;
           Read_Byte_Cnt     <= 0; 
       end
       else begin
           Wtrans_Cnt_En     <=  Wr_Addr_Lat &  Metrics_Cnt_En_Int ;
           Rtrans_Cnt_En     <=  Rd_Addr_Lat &  Metrics_Cnt_En_Int ;
           Write_Beat_Cnt_En1 <= Write_Beat & Metrics_Cnt_En_Int ;
           Write_Beat_Cnt_En <= Write_Beat_Cnt_En1 ;
           Read_Beat_Cnt_En  <= Read_Beat & Metrics_Cnt_En_Int ; 
           Write_Byte_Cnt2    <= (Data_Valid == 1'b1)?wr_byte_cnt:0;
           Write_Byte_Cnt1    <= (Data_Valid == 1'b1)?wr_byte_cnt1:0;
           Write_Byte_Cnt <= Write_Byte_Cnt1 + Write_Byte_Cnt2;
           //Read_Byte_Cnt     <= rd_byte_cnt ; 
          if(Metrics_Cnt_En_Int == 1'b1) begin
           Read_Byte_Cnt     <= F1_ARSIZE * num_rd_beats;//rd_byte_cnt ; 
           Read_Byte_Cnt_En  <= Last_Read_buf;
          end
       end
    end 

   end
    endgenerate

generate if(C_AXI_SUB_PROTOCOL == "AXI4LITE") begin : GEN_ARSIZE_F1
    always @(posedge clk) begin 
       if (rst_int_n == RST_ACTIVE) begin
           Wtrans_Cnt_En     <= 1'b0;
           Rtrans_Cnt_En     <= 1'b0;
           Write_Beat_Cnt_En1 <= 1'b0;
           Write_Beat_Cnt_En <= 1'b0;
           Read_Beat_Cnt_En  <= 1'b0;
           Write_Byte_Cnt    <= 0;
           Write_Byte_Cnt1    <= 0;
           Write_Byte_Cnt2    <= 0;
           Read_Byte_Cnt     <= 0; 
       end
       else begin
           Wtrans_Cnt_En     <=  Wr_Addr_Lat &  Metrics_Cnt_En_Int ;
           Rtrans_Cnt_En     <=  Rd_Addr_Lat &  Metrics_Cnt_En_Int ;
           Write_Beat_Cnt_En1 <= Write_Beat & Metrics_Cnt_En_Int ;
           Write_Beat_Cnt_En <= Write_Beat_Cnt_En1 ;
           Read_Beat_Cnt_En  <= Read_Beat & Metrics_Cnt_En_Int ; 
           Write_Byte_Cnt2    <= (Data_Valid == 1'b1)?wr_byte_cnt:0;
           Write_Byte_Cnt1    <= (Data_Valid == 1'b1)?wr_byte_cnt1:0;
           Write_Byte_Cnt <= Write_Byte_Cnt1 + Write_Byte_Cnt2;
           //Read_Byte_Cnt     <= rd_byte_cnt ; 
           Read_Byte_Cnt     <= rd_byte_cnt ; 
           Read_Byte_Cnt_En  <= Read_Beat & Metrics_Cnt_En_Int;
         end
    end 

   end
    endgenerate


    
endmodule



//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename     : axi_perf_mon_v5_0_12_metric_counters_profile.v
// Version      : v5.0
// Description  : Metric counter module instantiates the accumulators
//                and calculates the metric counts
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
//  axi_perf_mon.v
//      \--
//      \-- axi_perf_mon_v5_0_12_metric_counters_profile.v
//
//-----------------------------------------------------------------------------
// Author:    NLR 
// History: 
// NLR 02/10/2013      First Version  
// ~~~~~~
//-----------------------------------------------------------------------------
`timescale 1ns/1ps
module axi_perf_mon_v5_0_12_metric_counters_profile 
#(
   parameter                       C_FAMILY                   = "virtex7",
   parameter                       C_NUM_MONITOR_SLOTS        = 8,
   parameter                       C_NUM_OF_COUNTERS          = 10,
   parameter                       C_NUM_OF_COUNTERS_EXTND    = 2,
   parameter                       C_METRIC_COUNT_WIDTH       = 32,
   parameter                       C_HAVE_SAMPLED_METRIC_CNT  = 1
)
(
   input                            clk,
   input                            rst_n,
   input                            Sample_rst_n,

   input                            Sample_En,
   input [9:0]                      Lat_Addr_11downto2,
    //-- AXI4 metrics
   input [C_NUM_MONITOR_SLOTS-1:0]  Wtrans_Cnt_En,
   input [C_NUM_MONITOR_SLOTS-1:0]  Rtrans_Cnt_En,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Write_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Read_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Read_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Read_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Read_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Read_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Read_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Read_Byte_Cnt,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Read_Byte_Cnt,
   input                            S0_Read_Byte_Cnt_En,
   input                            S1_Read_Byte_Cnt_En,
   input                            S2_Read_Byte_Cnt_En,
   input                            S3_Read_Byte_Cnt_En,
   input                            S4_Read_Byte_Cnt_En,
   input                            S5_Read_Byte_Cnt_En,
   input                            S6_Read_Byte_Cnt_En,
   input                            S7_Read_Byte_Cnt_En,
   input [C_NUM_MONITOR_SLOTS-1:0]  Write_Beat_Cnt_En,
   input [C_NUM_MONITOR_SLOTS-1:0]  Read_Beat_Cnt_En,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Min_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Min_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Min_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Min_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Min_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Min_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Min_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Min_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Max_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Max_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Max_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Max_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Max_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Max_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Max_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Max_Read_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Min_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Min_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Min_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Min_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Min_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Min_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Min_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Min_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S0_Max_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S1_Max_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S2_Max_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S3_Max_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S4_Max_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S5_Max_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S6_Max_Write_Latency,
   input [C_METRIC_COUNT_WIDTH-1:0] S7_Max_Write_Latency,
   input [C_NUM_MONITOR_SLOTS-1:0]  Read_Latency_En,        
   input [C_NUM_MONITOR_SLOTS-1:0]  Write_Latency_En,        

   //-- Cnt Enable and Reset
   input                            Metrics_Cnt_En,
   input                            Metrics_Cnt_Reset,

   // Metric Counters - in core clk domain
   output reg [31:0]                Metric_Ram_Data_In    
);


//-------------------------------------------------------------------
// Parameter Declaration
//-------------------------------------------------------------------
localparam RST_ACTIVE = 1'b0;

//-------------------------------------------------------------------
// Signal Declarations
//------------------------------------------------------------------
 wire [C_METRIC_COUNT_WIDTH-1:0] accum_in [C_NUM_OF_COUNTERS-1:0];
 wire [C_NUM_OF_COUNTERS-1:0]    accum_in_valid;
 wire [C_METRIC_COUNT_WIDTH-1:0] Metric_Cnt [47:0];
 wire [C_METRIC_COUNT_WIDTH-1:0] Sample_Metric_Cnt [47:0];

 wire [C_METRIC_COUNT_WIDTH-1:0]    accum_in_extnd [C_NUM_OF_COUNTERS_EXTND-1:0];
 wire [C_NUM_OF_COUNTERS_EXTND-1:0]   accum_in_valid_extnd;
 wire [C_METRIC_COUNT_WIDTH-1:0] Metric_Cnt_extnd [15:0];
 wire [C_METRIC_COUNT_WIDTH-1:0] Sample_Metric_Cnt_extnd [15:0];

//-------------------------------------------------------------------
// Begin architecture
//-------------------------------------------------------------------
reg [C_NUM_MONITOR_SLOTS-1:0]  MinMax_Write_Latency_En;
reg [C_NUM_MONITOR_SLOTS-1:0]  MinMax_Read_Latency_En;
   always @(posedge clk) begin
      if (rst_n == RST_ACTIVE) begin
          MinMax_Write_Latency_En <= 0;
          MinMax_Read_Latency_En  <= 0;
      end else begin
          MinMax_Write_Latency_En <= Write_Latency_En;
          MinMax_Read_Latency_En  <= Read_Latency_En;
      end
   end

   assign accum_in[0] = S0_Write_Byte_Cnt;
   assign accum_in[1] = 1'b1;
   assign accum_in[2] = S0_Write_Latency;
   assign accum_in[3] = S0_Read_Byte_Cnt;
   assign accum_in[4] = 1'b1;
   assign accum_in[5] = S0_Read_Latency;
   assign accum_in_valid[0] = Write_Beat_Cnt_En[0];
   assign accum_in_valid[1] = Wtrans_Cnt_En[0];
   assign accum_in_valid[2] = Write_Latency_En[0];
   assign accum_in_valid[3] = S0_Read_Byte_Cnt_En;
   assign accum_in_valid[4] = Rtrans_Cnt_En[0];
   assign accum_in_valid[5] = Read_Latency_En[0];

assign accum_in_extnd[0]  = {S0_Max_Write_Latency[15:0], S0_Min_Write_Latency[15:0] };    
assign accum_in_extnd[1]  = {S0_Max_Read_Latency[15:0] , S0_Min_Read_Latency[15:0]  };  
assign accum_in_valid_extnd[0] = MinMax_Write_Latency_En[0];
assign accum_in_valid_extnd[1] = MinMax_Read_Latency_En[0];

generate if(C_NUM_OF_COUNTERS > 6) begin
   assign accum_in[6] = S1_Write_Byte_Cnt;
   assign accum_in[7] = 1'b1;
   assign accum_in[8] = S1_Write_Latency;
   assign accum_in[9] = S1_Read_Byte_Cnt;
   assign accum_in[10] = 1'b1;
   assign accum_in[11] = S1_Read_Latency;

   assign accum_in_valid[6] = Write_Beat_Cnt_En[1];
   assign accum_in_valid[7] = Wtrans_Cnt_En[1];
   assign accum_in_valid[8] = Write_Latency_En[1];
   assign accum_in_valid[9] = S1_Read_Byte_Cnt_En;
   assign accum_in_valid[10] = Rtrans_Cnt_En[1];
   assign accum_in_valid[11] = Read_Latency_En[1];

assign accum_in_extnd[2]  = {S1_Max_Write_Latency[15:0], S1_Min_Write_Latency[15:0] };    
assign accum_in_extnd[3]  = {S1_Max_Read_Latency[15:0] , S1_Min_Read_Latency[15:0]  };  
assign accum_in_valid_extnd[2] = MinMax_Write_Latency_En[1];
assign accum_in_valid_extnd[3] = MinMax_Read_Latency_En[1];
end
endgenerate

generate if(C_NUM_OF_COUNTERS > 12) begin
   assign accum_in[12] = S2_Write_Byte_Cnt;
   assign accum_in[13] = 1'b1;
   assign accum_in[14] = S2_Write_Latency;
   assign accum_in[15] = S2_Read_Byte_Cnt;
   assign accum_in[16] = 1'b1;
   assign accum_in[17] = S2_Read_Latency;

   assign accum_in_valid[12] = Write_Beat_Cnt_En[2];
   assign accum_in_valid[13] = Wtrans_Cnt_En[2];
   assign accum_in_valid[14] = Write_Latency_En[2];
   assign accum_in_valid[15] = S2_Read_Byte_Cnt_En;
   assign accum_in_valid[16] = Rtrans_Cnt_En[2];
   assign accum_in_valid[17] = Read_Latency_En[2];

assign accum_in_extnd[4]  = {S2_Max_Write_Latency[15:0], S2_Min_Write_Latency[15:0] };    
assign accum_in_extnd[5]  = {S2_Max_Read_Latency[15:0] , S2_Min_Read_Latency[15:0]  };  
assign accum_in_valid_extnd[4] = MinMax_Write_Latency_En[2];
assign accum_in_valid_extnd[5] = MinMax_Read_Latency_En[2];
end
endgenerate

generate if(C_NUM_OF_COUNTERS > 18) begin
  assign accum_in[18] = S3_Write_Byte_Cnt;
  assign accum_in[19] = 1'b1;
  assign accum_in[20] = S3_Write_Latency;
  assign accum_in[21] = S3_Read_Byte_Cnt;
  assign accum_in[22] = 1'b1;
  assign accum_in[23] = S3_Read_Latency;

  assign accum_in_valid[18] = Write_Beat_Cnt_En[3];
  assign accum_in_valid[19] = Wtrans_Cnt_En[3];
  assign accum_in_valid[20] = Write_Latency_En[3];
  assign accum_in_valid[21] = S3_Read_Byte_Cnt_En;
  assign accum_in_valid[22] = Rtrans_Cnt_En[3];
  assign accum_in_valid[23] = Read_Latency_En[3];

assign accum_in_extnd[6]  = {S3_Max_Write_Latency[15:0], S3_Min_Write_Latency[15:0] };    
assign accum_in_extnd[7]  = {S3_Max_Read_Latency[15:0] , S3_Min_Read_Latency[15:0]  };  
assign accum_in_valid_extnd[6] = MinMax_Write_Latency_En[3];
assign accum_in_valid_extnd[7] = MinMax_Read_Latency_En[3];
end
endgenerate

generate if(C_NUM_OF_COUNTERS > 24) begin
  assign accum_in[24] = S4_Write_Byte_Cnt;
  assign accum_in[25] = 1'b1;
  assign accum_in[26] = S4_Write_Latency;
  assign accum_in[27] = S4_Read_Byte_Cnt;
  assign accum_in[28] = 1'b1;
  assign accum_in[29] = S4_Read_Latency;

  assign accum_in_valid[24] = Write_Beat_Cnt_En[4];
  assign accum_in_valid[25] = Wtrans_Cnt_En[4];
  assign accum_in_valid[26] = Write_Latency_En[4];
  assign accum_in_valid[27] = S4_Read_Byte_Cnt_En;
  assign accum_in_valid[28] = Rtrans_Cnt_En[4];
  assign accum_in_valid[29] = Read_Latency_En[4];

assign accum_in_extnd[8]  = {S4_Max_Write_Latency[15:0], S4_Min_Write_Latency[15:0] };    
assign accum_in_extnd[9]  = {S4_Max_Read_Latency[15:0] , S4_Min_Read_Latency[15:0]  };  
assign accum_in_valid_extnd[8] = MinMax_Write_Latency_En[4];
assign accum_in_valid_extnd[9] = MinMax_Read_Latency_En[4];

end
endgenerate

generate if(C_NUM_OF_COUNTERS > 30) begin
  assign accum_in[30] = S5_Write_Byte_Cnt;
  assign accum_in[31] = 1'b1;
  assign accum_in[32] = S5_Write_Latency;
  assign accum_in[33] = S5_Read_Byte_Cnt;
  assign accum_in[34] = 1'b1;
  assign accum_in[35] = S5_Read_Latency;

  assign accum_in_valid[30] = Write_Beat_Cnt_En[5];
  assign accum_in_valid[31] = Wtrans_Cnt_En[5];
  assign accum_in_valid[32] = Write_Latency_En[5];
  assign accum_in_valid[33] = S5_Read_Byte_Cnt_En;
  assign accum_in_valid[34] = Rtrans_Cnt_En[5];
  assign accum_in_valid[35] = Read_Latency_En[5];

assign accum_in_extnd[10] = {S5_Max_Write_Latency[15:0], S5_Min_Write_Latency[15:0] };    
assign accum_in_extnd[11] = {S5_Max_Read_Latency[15:0] , S5_Min_Read_Latency[15:0]  };  
assign accum_in_valid_extnd[10] = MinMax_Write_Latency_En[5];
assign accum_in_valid_extnd[11] = MinMax_Read_Latency_En[5];
end
endgenerate

generate if(C_NUM_OF_COUNTERS > 36) begin
  assign accum_in[36] = S6_Write_Byte_Cnt;
  assign accum_in[37] = 1'b1;
  assign accum_in[38] = S6_Write_Latency;
  assign accum_in[39] = S6_Read_Byte_Cnt;
  assign accum_in[40] = 1'b1;
  assign accum_in[41] = S6_Read_Latency;

  assign accum_in_valid[36] = Write_Beat_Cnt_En[6];
  assign accum_in_valid[37] = Wtrans_Cnt_En[6];
  assign accum_in_valid[38] = Write_Latency_En[6];
  assign accum_in_valid[39] = S6_Read_Byte_Cnt_En;
  assign accum_in_valid[40] = Rtrans_Cnt_En[6];
  assign accum_in_valid[41] = Read_Latency_En[6];

assign accum_in_extnd[12] = {S6_Max_Write_Latency[15:0], S6_Min_Write_Latency[15:0] };    
assign accum_in_extnd[13] = {S6_Max_Read_Latency[15:0] , S6_Min_Read_Latency[15:0]  };  
assign accum_in_valid_extnd[12] = MinMax_Write_Latency_En[6];
assign accum_in_valid_extnd[13] = MinMax_Read_Latency_En[6];
end
endgenerate

generate if(C_NUM_OF_COUNTERS > 42) begin
  assign accum_in[42] = S7_Write_Byte_Cnt;
  assign accum_in[43] = 1'b1;
  assign accum_in[44] = S7_Write_Latency;
  assign accum_in[45] = S7_Read_Byte_Cnt;
  assign accum_in[46] = 1'b1;
  assign accum_in[47] = S7_Read_Latency;

  assign accum_in_valid[42] = Write_Beat_Cnt_En[7];
  assign accum_in_valid[43] = Wtrans_Cnt_En[7];
  assign accum_in_valid[44] = Write_Latency_En[7];
  assign accum_in_valid[45] = S7_Read_Byte_Cnt_En;
  assign accum_in_valid[46] = Rtrans_Cnt_En[7];
  assign accum_in_valid[47] = Read_Latency_En[7];

assign accum_in_extnd[14] = {S7_Max_Write_Latency[15:0], S7_Min_Write_Latency[15:0] };    
assign accum_in_extnd[15] = {S7_Max_Read_Latency[15:0] , S7_Min_Read_Latency[15:0]  };
assign accum_in_valid_extnd[14] = MinMax_Write_Latency_En[7];
assign accum_in_valid_extnd[15] = MinMax_Read_Latency_En[7];

end
endgenerate

//-- Metric Counter
genvar i;
generate
for (i=0; i<C_NUM_OF_COUNTERS; i=i+1) begin : GEN_acc

   axi_perf_mon_v5_0_12_acc_sample_profile 
   #(
     .C_FAMILY                      (C_FAMILY            ),
     .DWIDTH                        (C_METRIC_COUNT_WIDTH),
     .C_HAVE_SAMPLED_METRIC_CNT     (C_HAVE_SAMPLED_METRIC_CNT)
   ) acc_inst_0
   (
      .clk                (clk                        ),
      .rst_n              (rst_n                      ),
      .Sample_rst_n       (Sample_rst_n               ),
      .Enable             (Metrics_Cnt_En             ),   
      .Reset              (Metrics_Cnt_Reset          ) ,   
      .Add_in             (accum_in[i]                ),  
      .Add_in_Valid       (accum_in_valid[i]          ), 
      .Sample_En          (Sample_En                  ), 
      .Accumulate         (1'b1                       ), 
      .Accumulator        (Metric_Cnt[i]              ),
      .Sample_Accumulator (Sample_Metric_Cnt[i]       )
   );
end
endgenerate  

genvar j;
generate for (j=C_NUM_OF_COUNTERS; j<48; j = j+1) begin :GEN_No_acc
  assign Metric_Cnt[j] = 0;
  assign Sample_Metric_Cnt[j] = 0;
end
endgenerate

//-- Metric Counter-extnd
genvar k;
generate
for (k=0; k<C_NUM_OF_COUNTERS_EXTND; k=k+1) begin : GEN_acc_extnd

   axi_perf_mon_v5_0_12_acc_sample_profile 
   #(
     .C_FAMILY                      (C_FAMILY            ),
     .DWIDTH                        (C_METRIC_COUNT_WIDTH),
     .C_HAVE_SAMPLED_METRIC_CNT     (C_HAVE_SAMPLED_METRIC_CNT)
   ) acc_extnd_inst_0
   (
      .clk                (clk                        ),
      .rst_n              (rst_n                      ),
      .Sample_rst_n       (Sample_rst_n               ),
      .Enable             (Metrics_Cnt_En             ),   
      .Reset              (Metrics_Cnt_Reset          ),   
      .Add_in             (accum_in_extnd[k]          ),  
      .Add_in_Valid       (accum_in_valid_extnd[k]    ), 
      .Sample_En          (Sample_En                  ), 
      .Accumulate         (1'b0                       ), 
      .Accumulator        (Metric_Cnt_extnd[k]        ),
      .Sample_Accumulator (Sample_Metric_Cnt_extnd[k] )
   );
end
endgenerate  

genvar l;
generate for (l=C_NUM_OF_COUNTERS_EXTND; l<16; l = l+1) begin :GEN_No_acc_extnd
  assign Metric_Cnt_extnd[l] = 0;
  assign Sample_Metric_Cnt_extnd[l] = 0;
end
endgenerate
wire [11:0] Lat_Addr_11downto0;
assign Lat_Addr_11downto0 = {Lat_Addr_11downto2,2'b00};
always @(*) begin 
      case (Lat_Addr_11downto0)
        12'h100: Metric_Ram_Data_In<= Metric_Cnt[0];   
        12'h110: Metric_Ram_Data_In<= Metric_Cnt[1]; 
        12'h120: Metric_Ram_Data_In<= Metric_Cnt[2]; 
        12'h130: Metric_Ram_Data_In<= Metric_Cnt[3]; 
        12'h140: Metric_Ram_Data_In<= Metric_Cnt[4]; 
        12'h150: Metric_Ram_Data_In<= Metric_Cnt[5]; 
        12'h160: Metric_Ram_Data_In<= Metric_Cnt[6]; 
        12'h170: Metric_Ram_Data_In<= Metric_Cnt[7]; 
        12'h180: Metric_Ram_Data_In<= Metric_Cnt[8]; 
        12'h190: Metric_Ram_Data_In<= Metric_Cnt[9]; 
        12'h1A0: Metric_Ram_Data_In<= Metric_Cnt[10];
        12'h1B0: Metric_Ram_Data_In<= Metric_Cnt[11];
        12'h200: Metric_Ram_Data_In<= Sample_Metric_Cnt[0];   
        12'h210: Metric_Ram_Data_In<= Sample_Metric_Cnt[1]; 
        12'h220: Metric_Ram_Data_In<= Sample_Metric_Cnt[2]; 
        12'h230: Metric_Ram_Data_In<= Sample_Metric_Cnt[3]; 
        12'h240: Metric_Ram_Data_In<= Sample_Metric_Cnt[4]; 
        12'h250: Metric_Ram_Data_In<= Sample_Metric_Cnt[5]; 
        12'h260: Metric_Ram_Data_In<= Sample_Metric_Cnt[6]; 
        12'h270: Metric_Ram_Data_In<= Sample_Metric_Cnt[7]; 
        12'h280: Metric_Ram_Data_In<= Sample_Metric_Cnt[8]; 
        12'h290: Metric_Ram_Data_In<= Sample_Metric_Cnt[9]; 
        12'h2A0: Metric_Ram_Data_In<= Sample_Metric_Cnt[10];
        12'h2B0: Metric_Ram_Data_In<= Sample_Metric_Cnt[11];
        12'h500: Metric_Ram_Data_In<= Metric_Cnt[12];   
        12'h510: Metric_Ram_Data_In<= Metric_Cnt[13]; 
        12'h520: Metric_Ram_Data_In<= Metric_Cnt[14]; 
        12'h530: Metric_Ram_Data_In<= Metric_Cnt[15]; 
        12'h540: Metric_Ram_Data_In<= Metric_Cnt[16]; 
        12'h550: Metric_Ram_Data_In<= Metric_Cnt[17]; 
        12'h560: Metric_Ram_Data_In<= Metric_Cnt[18]; 
        12'h570: Metric_Ram_Data_In<= Metric_Cnt[19]; 
        12'h580: Metric_Ram_Data_In<= Metric_Cnt[20]; 
        12'h590: Metric_Ram_Data_In<= Metric_Cnt[21]; 
        12'h5A0: Metric_Ram_Data_In<= Metric_Cnt[22];
        12'h5B0: Metric_Ram_Data_In<= Metric_Cnt[23];
        12'h600: Metric_Ram_Data_In<= Sample_Metric_Cnt[12];   
        12'h610: Metric_Ram_Data_In<= Sample_Metric_Cnt[13]; 
        12'h620: Metric_Ram_Data_In<= Sample_Metric_Cnt[14]; 
        12'h630: Metric_Ram_Data_In<= Sample_Metric_Cnt[15]; 
        12'h640: Metric_Ram_Data_In<= Sample_Metric_Cnt[16]; 
        12'h650: Metric_Ram_Data_In<= Sample_Metric_Cnt[17]; 
        12'h660: Metric_Ram_Data_In<= Sample_Metric_Cnt[18]; 
        12'h670: Metric_Ram_Data_In<= Sample_Metric_Cnt[19]; 
        12'h680: Metric_Ram_Data_In<= Sample_Metric_Cnt[20]; 
        12'h690: Metric_Ram_Data_In<= Sample_Metric_Cnt[21]; 
        12'h6A0: Metric_Ram_Data_In<= Sample_Metric_Cnt[22];
        12'h6B0: Metric_Ram_Data_In<= Sample_Metric_Cnt[23];
        12'h700: Metric_Ram_Data_In<= Metric_Cnt[24];   
        12'h710: Metric_Ram_Data_In<= Metric_Cnt[25]; 
        12'h720: Metric_Ram_Data_In<= Metric_Cnt[26]; 
        12'h730: Metric_Ram_Data_In<= Metric_Cnt[27]; 
        12'h740: Metric_Ram_Data_In<= Metric_Cnt[28]; 
        12'h750: Metric_Ram_Data_In<= Metric_Cnt[29]; 
        12'h760: Metric_Ram_Data_In<= Metric_Cnt[30]; 
        12'h770: Metric_Ram_Data_In<= Metric_Cnt[31]; 
        12'h780: Metric_Ram_Data_In<= Metric_Cnt[32]; 
        12'h790: Metric_Ram_Data_In<= Metric_Cnt[33]; 
        12'h7A0: Metric_Ram_Data_In<= Metric_Cnt[34];
        12'h7B0: Metric_Ram_Data_In<= Metric_Cnt[35];
        12'h800: Metric_Ram_Data_In<= Sample_Metric_Cnt[24];   
        12'h810: Metric_Ram_Data_In<= Sample_Metric_Cnt[25]; 
        12'h820: Metric_Ram_Data_In<= Sample_Metric_Cnt[26]; 
        12'h830: Metric_Ram_Data_In<= Sample_Metric_Cnt[27]; 
        12'h840: Metric_Ram_Data_In<= Sample_Metric_Cnt[28]; 
        12'h850: Metric_Ram_Data_In<= Sample_Metric_Cnt[29]; 
        12'h860: Metric_Ram_Data_In<= Sample_Metric_Cnt[30]; 
        12'h870: Metric_Ram_Data_In<= Sample_Metric_Cnt[31]; 
        12'h880: Metric_Ram_Data_In<= Sample_Metric_Cnt[32]; 
        12'h890: Metric_Ram_Data_In<= Sample_Metric_Cnt[33]; 
        12'h8A0: Metric_Ram_Data_In<= Sample_Metric_Cnt[34];
        12'h8B0: Metric_Ram_Data_In<= Sample_Metric_Cnt[35];
        12'h900: Metric_Ram_Data_In<= Metric_Cnt[36];   
        12'h910: Metric_Ram_Data_In<= Metric_Cnt[37]; 
        12'h920: Metric_Ram_Data_In<= Metric_Cnt[38]; 
        12'h930: Metric_Ram_Data_In<= Metric_Cnt[39]; 
        12'h940: Metric_Ram_Data_In<= Metric_Cnt[40]; 
        12'h950: Metric_Ram_Data_In<= Metric_Cnt[41]; 
        12'h960: Metric_Ram_Data_In<= Metric_Cnt[42]; 
        12'h970: Metric_Ram_Data_In<= Metric_Cnt[43]; 
        12'h980: Metric_Ram_Data_In<= Metric_Cnt[44]; 
        12'h990: Metric_Ram_Data_In<= Metric_Cnt[45]; 
        12'h9A0: Metric_Ram_Data_In<= Metric_Cnt[46];
        12'h9B0: Metric_Ram_Data_In<= Metric_Cnt[47];
        12'hA00: Metric_Ram_Data_In<= Sample_Metric_Cnt[36];   
        12'hA10: Metric_Ram_Data_In<= Sample_Metric_Cnt[37]; 
        12'hA20: Metric_Ram_Data_In<= Sample_Metric_Cnt[38]; 
        12'hA30: Metric_Ram_Data_In<= Sample_Metric_Cnt[39]; 
        12'hA40: Metric_Ram_Data_In<= Sample_Metric_Cnt[40]; 
        12'hA50: Metric_Ram_Data_In<= Sample_Metric_Cnt[41]; 
        12'hA60: Metric_Ram_Data_In<= Sample_Metric_Cnt[42]; 
        12'hA70: Metric_Ram_Data_In<= Sample_Metric_Cnt[43]; 
        12'hA80: Metric_Ram_Data_In<= Sample_Metric_Cnt[44]; 
        12'hA90: Metric_Ram_Data_In<= Sample_Metric_Cnt[45]; 
        12'hAA0: Metric_Ram_Data_In<= Sample_Metric_Cnt[46];
        12'hAB0: Metric_Ram_Data_In<= Sample_Metric_Cnt[47];
        //PR#780668{
        12'h154: Metric_Ram_Data_In <= Metric_Cnt_extnd[0];
        12'h158: Metric_Ram_Data_In <= Metric_Cnt_extnd[1];
        12'h1b4: Metric_Ram_Data_In <= Metric_Cnt_extnd[2];
        12'h1b8: Metric_Ram_Data_In <= Metric_Cnt_extnd[3];
        12'h554: Metric_Ram_Data_In <= Metric_Cnt_extnd[4];
        12'h558: Metric_Ram_Data_In <= Metric_Cnt_extnd[5];
        12'h5b4: Metric_Ram_Data_In <= Metric_Cnt_extnd[6];
        12'h5b8: Metric_Ram_Data_In <= Metric_Cnt_extnd[7];
        12'h754: Metric_Ram_Data_In <= Metric_Cnt_extnd[8];
        12'h758: Metric_Ram_Data_In <= Metric_Cnt_extnd[9];
        12'h7b4: Metric_Ram_Data_In <= Metric_Cnt_extnd[10];
        12'h7b8: Metric_Ram_Data_In <= Metric_Cnt_extnd[11];
        12'h954: Metric_Ram_Data_In <= Metric_Cnt_extnd[12];
        12'h958: Metric_Ram_Data_In <= Metric_Cnt_extnd[13];
        12'h9b4: Metric_Ram_Data_In <= Metric_Cnt_extnd[14];
        12'h9b8: Metric_Ram_Data_In <= Metric_Cnt_extnd[15];
        12'h254: Metric_Ram_Data_In <= Sample_Metric_Cnt_extnd[0];
        12'h258: Metric_Ram_Data_In <= Sample_Metric_Cnt_extnd[1];
        12'h2b4: Metric_Ram_Data_In <= Sample_Metric_Cnt_extnd[2];
        12'h2b8: Metric_Ram_Data_In <= Sample_Metric_Cnt_extnd[3];
        12'h654: Metric_Ram_Data_In <= Sample_Metric_Cnt_extnd[4];
        12'h658: Metric_Ram_Data_In <= Sample_Metric_Cnt_extnd[5];
        12'h6b4: Metric_Ram_Data_In <= Sample_Metric_Cnt_extnd[6];
        12'h6b8: Metric_Ram_Data_In <= Sample_Metric_Cnt_extnd[7];
        12'h854: Metric_Ram_Data_In <= Sample_Metric_Cnt_extnd[8];
        12'h858: Metric_Ram_Data_In <= Sample_Metric_Cnt_extnd[9];
        12'h8b4: Metric_Ram_Data_In <= Sample_Metric_Cnt_extnd[10];
        12'h8b8: Metric_Ram_Data_In <= Sample_Metric_Cnt_extnd[11];
        12'ha54: Metric_Ram_Data_In <= Sample_Metric_Cnt_extnd[12];
        12'ha58: Metric_Ram_Data_In <= Sample_Metric_Cnt_extnd[13];
        12'hab4: Metric_Ram_Data_In <= Sample_Metric_Cnt_extnd[14];
        12'hab8: Metric_Ram_Data_In <= Sample_Metric_Cnt_extnd[15];
        //PR#780668}
        default:Metric_Ram_Data_In <= 0; 
      endcase
end 

endmodule       


//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename   : axi_perf_mon_v5_0_12_flags_gen_trace.v
// Version    : v5.0
// Description: This module detects the events over AXI interface and generates
//              the flags
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
// axi_perf_mon_v5_0_12_profile.v
//       \-- axi_perf_mon_v5_0_12_flags_gen_trace.v
//-----------------------------------------------------------------------------
// Author:     NLR 
// History:
// NLR         10/02/2013      First Version
// ^^^^^^
//-----------------------------------------------------------------------------
`timescale 1ns/1ps
module axi_perf_mon_v5_0_12_flags_gen_trace 
#(
   parameter C_FAMILY                 = "nofamily",
   parameter C_MON_FIFO_DATA_WIDTH    = 64,
   parameter C_LOG_WIDTH              = 71,
   parameter C_FLAG_WIDTH             = 7,  //-- 7: for AXI4   2: for AXI4S
   //AXI Slot Interface parameters
   parameter C_AXI_ADDR_WIDTH         = 32,
   parameter C_AXI_DATA_WIDTH         = 32,
   parameter C_AXI_ID_WIDTH           = 1,
   parameter C_AXI_PROTOCOL           = "AXI4",
   parameter C_SHOW_AXI_IDS           = 1,
   parameter C_SHOW_AXI_LEN           = 1,
   parameter C_EN_WR_ADD_FLAG         = 1, 
   parameter C_EN_FIRST_WRITE_FLAG    = 1, 
   parameter C_EN_LAST_WRITE_FLAG     = 1, 
   parameter C_EN_RESPONSE_FLAG       = 1, 
   parameter C_EN_RD_ADD_FLAG         = 1, 
   parameter C_EN_FIRST_READ_FLAG     = 1, 
   parameter C_EN_LAST_READ_FLAG      = 1, 
   parameter C_EN_AXI_DEBUG              = 0, 
   parameter C_EN_ALL_TRACE              = 0, 
   parameter C_EN_EXT_EVENTS_FLAG     = 0 
)
(
   input                                  clk,
   input                                  rst_n,

   input [C_MON_FIFO_DATA_WIDTH-1:0]      Data_In,
   input                                  Data_Valid,
   input                                  Ext_Trig,
   input                                  Ext_Trig_Stop,
   input                                  Use_Ext_Trig_Log,
   output [C_LOG_WIDTH-1:0]               Log_Data,
   output                                 Log_En,
   input [2:0]                            Ext_Data_in,
   input                                  Ext_Data_Valid,
   input [3:0]                            Trace_Ctrl_bits,
   output [2:0]                           Ext_Event_Flags
);



//-------------------------------------------------------------------
// Parameter Declaration
//-------------------------------------------------------------------
localparam RST_ACTIVE = 1'b0;
localparam LOG_DATA_WIDTH = (4*C_AXI_ID_WIDTH + 16);  

//-------------------------------------------------------------------
// Signal Declaration
//-------------------------------------------------------------------

 reg                                Write_going_on;    
 reg                                Read_going_on;    
 reg [LOG_DATA_WIDTH-1:0]           Log_Data_int; 
 reg [LOG_DATA_WIDTH-1:0]           Log_Data_int1; 
 reg [C_FLAG_WIDTH-1:0]             Flags;  
 reg [C_FLAG_WIDTH-1:0]             Flags1;  
 reg                                Ext_Trig_log_en;
 reg [1:0]                          Ext_Triggers_Sync_d1;

 wire [1:0] Ext_Triggers = {Ext_Trig_Stop,Ext_Trig}; 
 wire [1:0] Ext_Triggers_Sync;
 wire Ext_Trig_Sync_Out;
 wire Ext_Trig_Stop_Sync_Out;
 wire AWVALID,ARVALID;
 wire Wr_Addr_Lat_Flag,Rd_Addr_Lat_Flag;
//-------------------------------------------------------------------
// Begin architecture
//-------------------------------------------------------------------

assign Log_En = Use_Ext_Trig_Log? ((|Flags) && Ext_Trig_log_en): (C_EN_AXI_DEBUG ? (| Flags1) : | Flags);  // Bit wise or of flags to generate fifo write enable

   // Synchronizing external trigger
   //-- Double Flop synchronization
    axi_perf_mon_v5_0_12_cdc_sync
    #(
       .c_cdc_type      (1             ),   
       .c_flop_input    (0             ),  
       .c_reset_state   (1             ),  
       .c_single_bit    (0             ),  
       .c_vector_width  (2             ),  
       .c_mtbf_stages   (4             )  
     )ext_trig_cdc_sync 
     (
       .prmry_aclk      (1'b0                ),
       .prmry_rst_n     (1'b1                ),
       .prmry_in        (1'b0                ),
       .prmry_vect_in   (Ext_Triggers        ),
       .scndry_aclk     (clk                 ),
       .scndry_rst_n    (rst_n               ),
       .prmry_ack       (                    ),
       .scndry_out      (                    ),
       .scndry_vect_out (Ext_Triggers_Sync   ) 
      );

   always @(posedge clk) begin
      if (rst_n == RST_ACTIVE) begin
          Ext_Triggers_Sync_d1 <= 0;
      end
      else begin
          Ext_Triggers_Sync_d1 <= Ext_Triggers_Sync;
      end
   end
  
   // Positive edge detection for the trigger start and stop 
   assign Ext_Trig_Sync_Out = Ext_Triggers_Sync[0] & ~(Ext_Triggers_Sync_d1[0]); 
   assign Ext_Trig_Stop_Sync_Out = Ext_Triggers_Sync[1] & ~(Ext_Triggers_Sync_d1[1]); 

   always @(posedge clk) begin
      if (rst_n == RST_ACTIVE) begin
          Ext_Trig_log_en <= 0;
      end
      else begin
          if(Use_Ext_Trig_Log == 1'b0 || Ext_Trig_Stop_Sync_Out == 1'b1) begin
            Ext_Trig_log_en <=  1'b0;
          end
          else if(Ext_Trig_Sync_Out == 1'b1) begin
            Ext_Trig_log_en <=  1'b1;
          end
          else begin
            Ext_Trig_log_en <= Ext_Trig_log_en;
          end
      end
   end

 
    //-- Decoding individual signals from output of fifo
    wire RREADY                           = Data_In[0];
    wire RVALID                           = Data_In[1];
    wire RLAST                            = Data_In[2];
    wire [1:0] RRESP                      = Data_In[4:3];
    wire [C_AXI_ID_WIDTH-1:0] RID         = Data_In[C_AXI_ID_WIDTH+4:5];

    wire ARREADY                          = Data_In[C_AXI_ID_WIDTH+5];
    assign ARVALID                        = Data_In[C_AXI_ID_WIDTH+6];
    wire [1:0] ARBURST                    = Data_In[C_AXI_ID_WIDTH+8:C_AXI_ID_WIDTH+7];
    wire [2:0] ARSIZE                     = Data_In[C_AXI_ID_WIDTH+11:C_AXI_ID_WIDTH+9];
    wire [7:0] ARLEN                      = Data_In[C_AXI_ID_WIDTH+19:C_AXI_ID_WIDTH+12];
    wire [C_AXI_ADDR_WIDTH-1:0] ARADDR    = Data_In[C_AXI_ADDR_WIDTH+C_AXI_ID_WIDTH+19:C_AXI_ID_WIDTH+20];
    wire [C_AXI_ID_WIDTH-1:0] ARID        = Data_In[(C_AXI_ADDR_WIDTH+(2*C_AXI_ID_WIDTH)+19):(C_AXI_ADDR_WIDTH+C_AXI_ID_WIDTH+20)];

    wire BREADY        = Data_In[(C_AXI_ADDR_WIDTH+(2*C_AXI_ID_WIDTH)+20)];
    wire BVALID        = Data_In[(C_AXI_ADDR_WIDTH+(2*C_AXI_ID_WIDTH)+21)];
    wire [1:0] BRESP   = Data_In[(C_AXI_ADDR_WIDTH+(2*C_AXI_ID_WIDTH)+23):(C_AXI_ADDR_WIDTH+(2*C_AXI_ID_WIDTH)+22)];
    wire [C_AXI_ID_WIDTH-1:0] BID = Data_In[(C_AXI_ADDR_WIDTH+(3*C_AXI_ID_WIDTH)+23):(C_AXI_ADDR_WIDTH+(2*C_AXI_ID_WIDTH)+24)];

    wire WREADY                           = Data_In[(C_AXI_ADDR_WIDTH+(3*C_AXI_ID_WIDTH)+24)];
    wire WVALID                           = Data_In[(C_AXI_ADDR_WIDTH+(3*C_AXI_ID_WIDTH)+25)];
    wire WLAST                            = Data_In[(C_AXI_ADDR_WIDTH+(3*C_AXI_ID_WIDTH)+26)];
    wire [C_AXI_DATA_WIDTH/8 -1 :0] WSTRB = 
    Data_In[(C_AXI_ADDR_WIDTH+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+26):(C_AXI_ADDR_WIDTH+(3*C_AXI_ID_WIDTH)+27)];

    wire AWREADY                          = Data_In[(C_AXI_ADDR_WIDTH+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+27)];
    assign AWVALID                        = Data_In[(C_AXI_ADDR_WIDTH+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+28)];
    wire [1:0] AWBURST = 
    Data_In[(C_AXI_ADDR_WIDTH+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+30):(C_AXI_ADDR_WIDTH+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+29)];
    wire [2:0] AWSIZE = 
    Data_In[(C_AXI_ADDR_WIDTH+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+33):(C_AXI_ADDR_WIDTH+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+31)];
    wire [7:0] AWLEN  = 
    Data_In[(C_AXI_ADDR_WIDTH+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+41):(C_AXI_ADDR_WIDTH+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+34)];
    wire [C_AXI_ADDR_WIDTH-1:0] AWADDR    
    = Data_In[((2*C_AXI_ADDR_WIDTH)+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+41):(C_AXI_ADDR_WIDTH+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+42)];
    wire [C_AXI_ID_WIDTH-1:0] AWID   
    = Data_In[((2*C_AXI_ADDR_WIDTH)+(C_AXI_DATA_WIDTH/8)+(4*C_AXI_ID_WIDTH)+41):((2*C_AXI_ADDR_WIDTH)+(C_AXI_DATA_WIDTH/8)+(3*C_AXI_ID_WIDTH)+42)];

    //-- Flags generation
    wire Wr_Addr_Lat = AWREADY && AWVALID && Data_Valid;
    wire First_Write = WVALID && WREADY && (!Write_going_on) && Data_Valid;
    wire Last_Write  = WLAST && WVALID && WREADY && Data_Valid;
    wire Response    = BVALID && BREADY && Data_Valid;
    wire Rd_Addr_Lat = ARREADY && ARVALID && Data_Valid;
    wire First_Read  = RVALID && RREADY && (!Read_going_on) && Data_Valid;
    wire Last_Read   = RLAST && RVALID && RREADY && Data_Valid;

    assign Wr_Addr_Lat_Flag = C_EN_WR_ADD_FLAG?Wr_Addr_Lat:0;
    wire First_Write_Flag = C_EN_FIRST_WRITE_FLAG?First_Write:0;
    wire Last_Write_Flag  = C_EN_LAST_WRITE_FLAG?Last_Write:0;
    wire Response_Flag    = C_EN_RESPONSE_FLAG?Response:0;
    assign Rd_Addr_Lat_Flag = C_EN_RD_ADD_FLAG?Rd_Addr_Lat:0;
    wire First_Read_Flag  = C_EN_FIRST_READ_FLAG?First_Read:0;
    wire Last_Read_Flag   = C_EN_LAST_READ_FLAG?Last_Read:0;

    

    //-- Write_going_on for First_Write_Flag generation
    always @(posedge clk) begin 
       if (rst_n == RST_ACTIVE) begin
           Write_going_on <= 1'b0;
       end
       else begin
           if (Last_Write == 1'b1) begin
               Write_going_on <= 1'b0;
           end
           else if (First_Write == 1'b1)  begin
               Write_going_on <= 1'b1;
           end
           else begin
               Write_going_on <= Write_going_on;
           end
       end
    end 

    //-- Read_going_on for First_Read_Flag generation
    always @(posedge clk) begin 
       if (rst_n == RST_ACTIVE) begin
           Read_going_on <= 1'b0;
       end
       else begin
           if (Last_Read == 1'b1) begin
               Read_going_on <= 1'b0;
           end
           else if (First_Read == 1'b1)  begin
               Read_going_on <= 1'b1;
           end
           else begin
               Read_going_on <= Read_going_on;
           end
       end
    end 

    //-- Flags
always @(posedge clk) begin
  if (rst_n == RST_ACTIVE) begin
    Flags <= 0;
  end
  else begin
    if (C_EN_AXI_DEBUG == 0 && C_EN_ALL_TRACE == 1)
        Flags <= {Trace_Ctrl_bits[1]&Last_Read_Flag,Trace_Ctrl_bits[1]&First_Read_Flag,Trace_Ctrl_bits[1]&Rd_Addr_Lat_Flag,Trace_Ctrl_bits[2]&Response_Flag,Trace_Ctrl_bits[2]&Last_Write_Flag,Trace_Ctrl_bits[2]&First_Write_Flag,Trace_Ctrl_bits[2]&Wr_Addr_Lat_Flag};
    else if(C_EN_AXI_DEBUG == 0 && C_EN_ALL_TRACE == 0)
        Flags <= {Last_Read_Flag,First_Read_Flag,Rd_Addr_Lat_Flag,Response_Flag,Last_Write_Flag,First_Write_Flag,Wr_Addr_Lat_Flag};
    else
        Flags <= {Last_Read_Flag,1'b0,Rd_Addr_Lat_Flag,Response_Flag,1'b0,1'b0,Wr_Addr_Lat_Flag};
  end
end 

     
    //-- Data Log
    always @(posedge clk) begin
       if (rst_n == RST_ACTIVE) begin
           Log_Data_int <= 0;
       end
       else begin
           Log_Data_int <= {AWID, BID, ARID, RID, AWLEN, ARLEN};
       end
    end 

  reg [C_AXI_ADDR_WIDTH-1:0] AWADDR_d, ARADDR_d;
  reg [C_AXI_ADDR_WIDTH-1:0] AWADDR_d2, ARADDR_d2;
  wire [C_AXI_ADDR_WIDTH-1:0] AWRADDR, ARRADDR;
   
  generate if (C_EN_AXI_DEBUG == 1 ) begin : GEN_AXI_DDR_DEBUG
  
   always @ (posedge clk)
     if (rst_n == RST_ACTIVE)
     begin
	   ARADDR_d2 <= {C_AXI_ADDR_WIDTH{1'b0}};
	   ARADDR_d <= {C_AXI_ADDR_WIDTH{1'b0}};
	   AWADDR_d2 <= {C_AXI_ADDR_WIDTH{1'b0}};
	   AWADDR_d <= {C_AXI_ADDR_WIDTH{1'b0}};
     end
     else begin
   	Flags1 <= Flags;
      Log_Data_int1 <= Log_Data_int;
      if (Wr_Addr_Lat_Flag) begin
      AWADDR_d <= AWADDR;
      end
      if (Rd_Addr_Lat_Flag) begin
    	ARADDR_d  <= ARADDR;
      end
      if(Flags[3] == 1'b1 && Flags[0] == 1'b0) begin
	   AWADDR_d2 <= AWRADDR;
      end
	   else begin
      	//if (Wr_Addr_Lat_Flag)
  	       AWADDR_d2 <= AWADDR_d;
      end
	   if(Flags[6] == 1'b1 && Flags[4] == 1'b0) begin
           ARADDR_d2 <= ARRADDR;
      end
	   else begin
      	//if (Rd_Addr_Lat_Flag)
           ARADDR_d2 <= ARADDR_d;
      end
     end
   end
      
   axi_perf_mon_v5_0_12_sync_fifo 
     #(
        .WIDTH      (C_AXI_ADDR_WIDTH),
        .DEPTH_LOG2 (5)
     ) RESP_FIFO
     (
       .rst_n    (rst_n),
       .clk      (clk),
       .wren     (Wr_Addr_Lat_Flag),
       .rden     (Response_Flag   ),
       .din      (AWADDR ),
       .dout     (AWRADDR ),
       .full     (       ),
       .empty    (   )
     );

   axi_perf_mon_v5_0_12_sync_fifo 
     #(
        .WIDTH      (C_AXI_ADDR_WIDTH),
        .DEPTH_LOG2 (5)
     ) RRESP_FIFO
     (
       .rst_n    (rst_n),
       .clk      (clk),
       .wren     (Rd_Addr_Lat_Flag),
       .rden     (Last_Read_Flag   ),
       .din      (ARADDR ),
       .dout     (ARRADDR ),
       .full     (       ),
       .empty    (   )
     );

endgenerate


// Assigning log data out based on the control parameters
// This assignment is to reduce the log data width

generate 
// for AXI tranx debug purpose   
if (C_EN_AXI_DEBUG == 1 ) begin : GEN_LOGS_DEBUG
   assign Log_Data = {AWADDR_d2,Log_Data_int1[15:8],Flags1[0],Flags1[3],ARADDR_d2,Log_Data_int1[7:0],Flags1[4],Flags1[6]};
end
// for performance trace purpose 
else if (C_AXI_PROTOCOL == "AXI4" && C_SHOW_AXI_IDS == 1 && C_SHOW_AXI_LEN == 1) begin : GEN_LOGS_AXI4
   assign Log_Data = {Log_Data_int,Flags};
end
else if(C_AXI_PROTOCOL == "AXI4" && C_SHOW_AXI_IDS == 1 && C_SHOW_AXI_LEN == 0) begin :GEN_SHOW_IDS
   assign Log_Data = {Log_Data_int[LOG_DATA_WIDTH-1:16],Flags};
end
else if(C_AXI_PROTOCOL == "AXI4" && C_SHOW_AXI_IDS == 0 && C_SHOW_AXI_LEN == 1) begin :GEN_SHOW_LEN
   assign Log_Data = {Log_Data_int[15:0],Flags};
end
else if(C_AXI_PROTOCOL == "AXI4" && C_SHOW_AXI_IDS == 0 && C_SHOW_AXI_LEN == 0) begin :GEN_NO_LOG_DATA
   assign Log_Data = Flags;
end
else
   begin:GEN_NO_LOGS
   assign Log_Data = 0;
end

endgenerate

generate if(C_EN_EXT_EVENTS_FLAG == 1) begin:EXT_EVENT_FLAGS
    // External event flags generation
    wire Ext_Event_Start_Flag = Ext_Data_in[2] && Ext_Data_Valid; 
    wire Ext_Event_Stop_Flag =  Ext_Data_in[1] && Ext_Data_Valid;
    wire Ext_Event_Flag  =  Ext_Data_in[0] && Ext_Data_Valid;
    reg [2:0] Ext_Event_Flags_int;
   
     // External event flags
   always @(posedge clk) begin
    if (rst_n == RST_ACTIVE) begin
       Ext_Event_Flags_int <= 0;
    end
    else begin
        if (C_EN_ALL_TRACE == 1) begin
           Ext_Event_Flags_int <= {Trace_Ctrl_bits[0]&Ext_Event_Start_Flag,Trace_Ctrl_bits[0]&Ext_Event_Stop_Flag,Trace_Ctrl_bits[0]&Ext_Event_Flag};
        end
        else begin
           Ext_Event_Flags_int <= {Ext_Event_Start_Flag,Ext_Event_Stop_Flag,Ext_Event_Flag};
        end
    end
   end 

   assign Ext_Event_Flags = Ext_Event_Flags_int;
end
else begin:NO_EXT_EVENT_FLAGS
  assign Ext_Event_Flags = 0;
end
endgenerate

endmodule







//-----------------------------------------------------------------------------
// axi_perf_mon_v5_0_12_top  module
//-----------------------------------------------------------------------------
// (c) Copyright 2009 - 2013 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and 
//  international copyright and other intellectual property
//  laws.
//  
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//  
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//  
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
// Filename     : axi_perf_mon_v5_0_12_top.v
// Version      : v5.0
// Description  : This is the top level wrapper file for the AXI Performance
//                Monitor. 
// Verilog-Standard:verilog-2001
//-----------------------------------------------------------------------------
// Structure:   
// axi_perf_mon_v5_0_12_top.v
//   \--axi_perf_mon_v5_0_12_advanced.v
//     \-- axi_perf_mon_v5_0_12_axi_interface.v
//     \-- axi_perf_mon_v5_0_12_register_module.v
//             \--axi_perf_mon_v5_0_12_cdc_sync.v
//             \-- axi_perf_mon_v5_0_12_intr_sync.v
//                \--axi_perf_mon_v5_0_12_cdc_sync.v
//      \-- axi_perf_mon_v5_0_12_interrupt_module.v
//      \-- axi_perf_mon_v5_0_12_cdc_sync.v
//          \-- axi_perf_mon_v5_0_12_glbl_clk_cnt.v
//           \-- axi_perf_mon_v5_0_12_counter.v
//      \-- axi_perf_mon_v5_0_12_mon_fifo.v
//           \-- axi_perf_mon_v5_0_12_async_fifo.vhd
//      \-- axi_perf_mon_v5_0_12_metric_calc.v
//            \-- axi_perf_mon_v5_0_12_sync_fifo.vhd
//            \-- axi_perf_mon_v5_0_12_counter.v
//      \-- axi_perf_mon_v5_0_12_metric_counters.v
//            \-- axi_perf_mon_v5_0_12_metric_sel_n_cnt.v 
//            \--axi_perf_mon_v5_0_12_acc_n_incr.v
//               \--axi_perf_mon_v5_0_12_counter.v
//      \-- axi_perf_mon_v5_0_12_samp_intl_cnt.v
//          \-- axi_perf_mon_v5_0_12_counter.v
//      \-- axi_perf_mon_v5_0_12_samp_metrics_data.v
//      \-- axi_perf_mon_v5_0_12_flags_gen.v
//      \-- axi_perf_mon_v5_0_12_strm_fifo_wr_logic.v
//          \-- axi_perf_mon_v5_0_12_counter.v
//      \-- axi_perf_mon_v5_0_12_async_stream_fifo.v
//           \-- axi_perf_mon_v5_0_12_async_fifo.vhd
//   \--axi_perf_mon_v5_0_12_profile.v
//     \-- axi_perf_mon_v5_0_12_axi_interface.v
//             \--axi_perf_mon_v5_0_12_cdc_sync.v
//             \-- axi_perf_mon_v5_0_12_intr_sync.v
//                 \--axi_perf_mon_v5_0_12_cdc_sync.v
//      \-- axi_perf_mon_v5_0_12_interrupt_module.v
//      \-- axi_perf_mon_v5_0_12_cdc_sync.v
//      \-- axi_perf_mon_v5_0_12_mon_fifo.v
//           \-- axi_perf_mon_v5_0_12_async_fifo.vhd
//       \-- axi_perf_mon_v5_0_12_register_module_profile.v
//       \-- axi_perf_mon_v5_0_12_metric_calc_profile.v
//            \-- axi_perf_mon_v5_0_12_sync_fifo.vhd
//            \-- axi_perf_mon_v5_0_12_counter.v
//       \-- axi_perf_mon_v5_0_12_metric_counters_profile.v
//           \--axi_perf_mon_v5_0_12_acc_sample_profile.v
//      \-- axi_perf_mon_v5_0_12_strm_fifo_wr_logic.v
//      \-- axi_perf_mon_v5_0_12_async_stream_fifo.v
//       \-- axi_perf_mon_v5_0_12_flags_gen_trace.v
//---------------------------------------------------------------------------
// Author  :   NLR 
// History :    
// NLR       07/25/2012      First Version
// ^^^^^^
// NLR       12/18/2012      Release of v3_00_a with feature updates
// ^^^^^^
// NLR       03/20/2013      Release of v5_0
// ^^^^^^ 
// NLR       04/15/2013      Added resetting of sampled metric counters with
//                           Control register bit 
// ^^^^^^^
// NLR       06/18/2013      Restructred the code with proper generate statements 
// ^^^^^^^
// NLR       10/02/2013      Added advanced, profile and trace mode supports
// ^^^^^^^                   Metric scaling factor support
//---------------------------------------------------------------------------
// Naming Conventions:
//      active low signals:                     "*_n"
//      clock signals:                          "clk", "clk_div#", "clk_#x" 
//      reset signals:                          "rst", "rst_n" 
//      generics:                                "C_*" 
//      user defined types:                     "*_TYPE" 
//      state machine next state:               "*_ns" 
//      state machine current state:            "*_cs" 
//      combinatorial signals:                  "*_com" 
//      pipelined or register delay signals:    "*_d#" 
//      counter signals:                        "*cnt*"
//      clock enable signals:                   "*_ce" 
//      internal version of output port         "*_i"
//      device pins:                            "*_pin" 
//      ports:                                  - Lowercase 
//---------------------------------------------------------------------------

//Top Module 
`timescale 1ns/1ps
(* DowngradeIPIdentifiedWarnings="yes" *)

module axi_perf_mon_v5_0_12_top 
  # (
    parameter C_FAMILY                        = "virtex7",
    parameter C_INSTANCE                      = "axi_perf_mon_v5_0_12_top_inst",

    //AXI Lite Interface parameters for this core
    parameter C_LITE_ADDRESS_WIDTH              = 16, 

    //AXI Slave Interface parameters for this core
    parameter C_S_AXI_ADDR_WIDTH              = 16, 
    parameter C_S_AXI_DATA_WIDTH              = 32,
    parameter C_S_AXI_PROTOCOL                = "AXI4LITE",
    parameter C_S_AXI_ID_WIDTH                = 1,
    parameter C_SUPPORT_ID_REFLECTION         = 0,
   
    // Mode selection parameters
    parameter C_ENABLE_ADVANCED               = 1,
    parameter C_ENABLE_PROFILE                = 0,
    parameter C_ENABLE_TRACE                  = 0,

    // Trace Mode parameters 
    parameter C_EN_AXI_DEBUG                  = 0, 
    parameter C_EN_TRIGGER                    = 0, 
    parameter C_EN_WR_ADD_FLAG                = 1, 
    parameter C_EN_FIRST_WRITE_FLAG           = 1, 
    parameter C_EN_LAST_WRITE_FLAG            = 1, 
    parameter C_EN_RESPONSE_FLAG              = 1, 
    parameter C_EN_RD_ADD_FLAG                = 1, 
    parameter C_EN_FIRST_READ_FLAG            = 1, 
    parameter C_EN_LAST_READ_FLAG             = 1, 
    parameter C_EN_SW_REG_WR_FLAG             = 0, 
    parameter C_EN_EXT_EVENTS_FLAG            = 0, 

    //Counter Parameters
    parameter C_NUM_MONITOR_SLOTS             = 1,
    parameter C_ENABLE_EVENT_COUNT            = 1,  //-- enables/disables perf mon counting logic
    parameter C_NUM_OF_COUNTERS               = 1,
    parameter C_METRIC_COUNT_WIDTH            = 32, 
    parameter C_METRIC_COUNT_SCALE            = 1, 
    parameter C_GLOBAL_COUNT_WIDTH            = 32,
    parameter C_HAVE_SAMPLED_METRIC_CNT       = 1,  //-- enable sampled metric counters logic
    parameter C_METRICS_SAMPLE_COUNT_WIDTH    = 32,
    parameter C_AXI4LITE_CORE_CLK_ASYNC       = 1,  //-- disable synchronizers incase its 0 

    //AXI Slot 0 Interface parameters
    parameter C_SLOT_0_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_0_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_0_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_0_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_0_AXIS_TDATA_WIDTH       = 32,
    parameter C_SLOT_0_AXIS_TID_WIDTH         = 1,
    parameter C_SLOT_0_AXIS_TDEST_WIDTH       = 1,
    parameter C_SLOT_0_AXIS_TUSER_WIDTH       = 1,
    parameter C_SLOT_0_FIFO_ENABLE            = 1,

    //AXI Slot 1 Interface parameters
    parameter C_SLOT_1_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_1_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_1_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_1_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_1_AXIS_TDATA_WIDTH       = 32,
    parameter C_SLOT_1_AXIS_TID_WIDTH         = 1,
    parameter C_SLOT_1_AXIS_TDEST_WIDTH       = 1,
    parameter C_SLOT_1_AXIS_TUSER_WIDTH       = 1,
    parameter C_SLOT_1_FIFO_ENABLE            = 1,

    //AXI Slot 2 Interface parameters
    parameter C_SLOT_2_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_2_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_2_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_2_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_2_AXIS_TDATA_WIDTH       = 32,
    parameter C_SLOT_2_AXIS_TID_WIDTH         = 1,
    parameter C_SLOT_2_AXIS_TDEST_WIDTH       = 1,
    parameter C_SLOT_2_AXIS_TUSER_WIDTH       = 1,
    parameter C_SLOT_2_FIFO_ENABLE            = 1,
 
    //AXI Slot 3 Interface parameters
    parameter C_SLOT_3_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_3_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_3_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_3_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_3_AXIS_TDATA_WIDTH       = 32,
    parameter C_SLOT_3_AXIS_TID_WIDTH         = 1,
    parameter C_SLOT_3_AXIS_TDEST_WIDTH       = 1,
    parameter C_SLOT_3_AXIS_TUSER_WIDTH       = 1,
    parameter C_SLOT_3_FIFO_ENABLE            = 1,

    //AXI Slot 4 Interface parameters
    parameter C_SLOT_4_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_4_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_4_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_4_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_4_AXIS_TDATA_WIDTH       = 32,
    parameter C_SLOT_4_AXIS_TID_WIDTH         = 1,
    parameter C_SLOT_4_AXIS_TDEST_WIDTH       = 1,
    parameter C_SLOT_4_AXIS_TUSER_WIDTH       = 1,
    parameter C_SLOT_4_FIFO_ENABLE            = 1,

    //AXI Slot 5 Interface parameters
    parameter C_SLOT_5_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_5_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_5_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_5_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_5_AXIS_TDATA_WIDTH       = 32,
    parameter C_SLOT_5_AXIS_TID_WIDTH         = 1,
    parameter C_SLOT_5_AXIS_TDEST_WIDTH       = 1,
    parameter C_SLOT_5_AXIS_TUSER_WIDTH       = 1,
    parameter C_SLOT_5_FIFO_ENABLE            = 1,

    //AXI Slot 6 Interface parameters
    parameter C_SLOT_6_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_6_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_6_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_6_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_6_AXIS_TDATA_WIDTH       = 32,
    parameter C_SLOT_6_AXIS_TID_WIDTH         = 1,
    parameter C_SLOT_6_AXIS_TDEST_WIDTH       = 1,
    parameter C_SLOT_6_AXIS_TUSER_WIDTH       = 1,
    parameter C_SLOT_6_FIFO_ENABLE            = 1,

    //AXI Slot 7 Interface parameters
    parameter C_SLOT_7_AXI_ADDR_WIDTH         = 32,
    parameter C_SLOT_7_AXI_DATA_WIDTH         = 32,
    parameter C_SLOT_7_AXI_ID_WIDTH           = 1,
    parameter C_SLOT_7_AXI_PROTOCOL           = "AXI4",
    parameter C_SLOT_7_AXIS_TDATA_WIDTH       = 32,
    parameter C_SLOT_7_AXIS_TID_WIDTH         = 1,
    parameter C_SLOT_7_AXIS_TDEST_WIDTH       = 1,
    parameter C_SLOT_7_AXIS_TUSER_WIDTH       = 1,
    parameter C_SLOT_7_FIFO_ENABLE            = 1,

    //WLEN parameters
    parameter C_SLOT_0_AXI_AWLEN              = 7,
    parameter C_SLOT_1_AXI_AWLEN              = 7,
    parameter C_SLOT_2_AXI_AWLEN              = 7,
    parameter C_SLOT_3_AXI_AWLEN              = 7,
    parameter C_SLOT_4_AXI_AWLEN              = 7,
    parameter C_SLOT_5_AXI_AWLEN              = 7,
    parameter C_SLOT_6_AXI_AWLEN              = 7,
    parameter C_SLOT_7_AXI_AWLEN              = 7,
    parameter C_SLOT_0_AXI_LOCK               = 0,
    parameter C_SLOT_1_AXI_LOCK               = 0,
    parameter C_SLOT_2_AXI_LOCK               = 0,
    parameter C_SLOT_3_AXI_LOCK               = 0,
    parameter C_SLOT_4_AXI_LOCK               = 0,
    parameter C_SLOT_5_AXI_LOCK               = 0,
    parameter C_SLOT_6_AXI_LOCK               = 0,
    parameter C_SLOT_7_AXI_LOCK               = 0,

// Register all Monitor inputs option
    parameter C_REG_ALL_MONITOR_SIGNALS       = 0,

    // Fifo option for external events
    parameter C_EXT_EVENT0_FIFO_ENABLE        = 1,
    parameter C_EXT_EVENT1_FIFO_ENABLE        = 1,
    parameter C_EXT_EVENT2_FIFO_ENABLE        = 1,
    parameter C_EXT_EVENT3_FIFO_ENABLE        = 1,
    parameter C_EXT_EVENT4_FIFO_ENABLE        = 1,
    parameter C_EXT_EVENT5_FIFO_ENABLE        = 1,
    parameter C_EXT_EVENT6_FIFO_ENABLE        = 1,
    parameter C_EXT_EVENT7_FIFO_ENABLE        = 1,

    //Event Log Parameters
    parameter C_ENABLE_EVENT_LOG              = 0,  // Enables event logging logic
    parameter C_FIFO_AXIS_DEPTH               = 32, // AXI Streaming FIFO depth
    parameter C_FIFO_AXIS_TDATA_WIDTH         = 56, // AXI Streaming FIFO width
    parameter C_AXIS_DWIDTH_ROUND_TO_32       = 64, // AXI Streaming FIFO width rounded to next 32bit
    parameter C_FIFO_AXIS_TID_WIDTH           = 1,  // AXI Streaming FIFO ID width
    parameter C_FIFO_AXIS_SYNC                = 0,  // 1=Sync FIFO, 0=ASYNC FIFO
    parameter C_SHOW_AXI_IDS                  = 0,
    parameter C_SHOW_AXI_LEN                  = 0,
    parameter C_SHOW_AXIS_TID                 = 0,
    parameter C_SHOW_AXIS_TDEST               = 0,
    parameter C_SHOW_AXIS_TUSER               = 0,
    parameter ENABLE_EXT_EVENTS               = 0,
    parameter COUNTER_LOAD_VALUE              = 32'h00000000, 
    parameter C_LOG_DATA_OFFLD                = 0,//0- stream offload,1-Memorymap offload 
    parameter S_AXI_OFFLD_ID_WIDTH            = 1,//offload interface ID width.
    parameter C_S_AXI4_BASEADDR               = 32'hFFFFFFFF,//CR#782642.
    parameter C_S_AXI4_HIGHADDR               = 32'h0,
    parameter C_EN_ALL_TRACE                  = 0    
        )
    (
    //AXI-Lite Interface   
    input                                    s_axi_aclk,
    input                                    s_axi_aresetn,
    input [C_LITE_ADDRESS_WIDTH-1:0]         s_axi_awaddr,
    input                                    s_axi_awvalid,
    input [C_S_AXI_ID_WIDTH-1:0]             s_axi_awid,     //AXI4 Full Interface support
    output                                   s_axi_awready,
    input [31:0]                             s_axi_wdata,
    input [3:0]                              s_axi_wstrb,
    input                                    s_axi_wvalid,
    output                                   s_axi_wready,
    output [1:0]                             s_axi_bresp,
    output                                   s_axi_bvalid,
    output [C_S_AXI_ID_WIDTH-1:0]            s_axi_bid,      //AXI4 Full Interface support
    input                                    s_axi_bready,
    input  [C_LITE_ADDRESS_WIDTH-1:0]        s_axi_araddr,
    input                                    s_axi_arvalid,
    input [C_S_AXI_ID_WIDTH-1:0]             s_axi_arid,     //AXI4 Full Interface support
    output                                   s_axi_arready,
    output [31:0]                            s_axi_rdata,
    output [1:0]                             s_axi_rresp,
    output                                   s_axi_rvalid,
    output [C_S_AXI_ID_WIDTH-1:0]            s_axi_rid,      //AXI4 Full Interface support
    input                                    s_axi_rready,
  
    // SLOT 0 AXI MM Interface signals
    input                                    slot_0_axi_aclk,
    input                                    slot_0_axi_aresetn,
    input [C_SLOT_0_AXI_ID_WIDTH-1:0]        slot_0_axi_awid,
    input [C_SLOT_0_AXI_ADDR_WIDTH-1:0]      slot_0_axi_awaddr,
    input [2:0]                              slot_0_axi_awprot,
    input [C_SLOT_0_AXI_AWLEN:0]             slot_0_axi_awlen,
    input [2:0]                              slot_0_axi_awsize,
    input [1:0]                              slot_0_axi_awburst,
    input [3:0]                              slot_0_axi_awcache,
    input [C_SLOT_0_AXI_LOCK : 0]            slot_0_axi_awlock,
    input                                    slot_0_axi_awvalid,
    input                                    slot_0_axi_awready,
    input [C_SLOT_0_AXI_DATA_WIDTH-1:0]      slot_0_axi_wdata,
    input [C_SLOT_0_AXI_DATA_WIDTH/8-1:0]    slot_0_axi_wstrb,
    input                                    slot_0_axi_wlast,
    input                                    slot_0_axi_wvalid,
    input                                    slot_0_axi_wready,
    input [C_SLOT_0_AXI_ID_WIDTH-1:0]        slot_0_axi_bid,
    input [1:0]                              slot_0_axi_bresp,
    input                                    slot_0_axi_bvalid,
    input                                    slot_0_axi_bready,
    input [C_SLOT_0_AXI_ID_WIDTH-1:0]        slot_0_axi_arid,
    input [C_SLOT_0_AXI_ADDR_WIDTH-1:0]      slot_0_axi_araddr,
    input [C_SLOT_0_AXI_AWLEN:0]             slot_0_axi_arlen,
    input [2:0]                              slot_0_axi_arsize,
    input [1:0]                              slot_0_axi_arburst,
    input [3:0]                              slot_0_axi_arcache,
    input [2:0]                              slot_0_axi_arprot,
    input [C_SLOT_0_AXI_LOCK : 0]            slot_0_axi_arlock,
    input                                    slot_0_axi_arvalid,
    input                                    slot_0_axi_arready,
    input [C_SLOT_0_AXI_ID_WIDTH-1:0]        slot_0_axi_rid,
    input [C_SLOT_0_AXI_DATA_WIDTH-1:0]      slot_0_axi_rdata,
    input [1:0]                              slot_0_axi_rresp,
    input                                    slot_0_axi_rlast,
    input                                    slot_0_axi_rvalid,
    input                                    slot_0_axi_rready,
  
    //SLOT 0 AXI Streaming Interface
    input                                    slot_0_axis_aclk,
    input                                    slot_0_axis_aresetn,
    input                                    slot_0_axis_tvalid,
    input                                    slot_0_axis_tready,
    input [C_SLOT_0_AXIS_TDATA_WIDTH-1:0]    slot_0_axis_tdata,
    input [C_SLOT_0_AXIS_TDATA_WIDTH/8-1:0]  slot_0_axis_tstrb,
    input [C_SLOT_0_AXIS_TDATA_WIDTH/8-1:0]  slot_0_axis_tkeep,
    input                                    slot_0_axis_tlast,
    input [C_SLOT_0_AXIS_TID_WIDTH-1:0]      slot_0_axis_tid,
    input [C_SLOT_0_AXIS_TDEST_WIDTH-1:0]    slot_0_axis_tdest,
    input [C_SLOT_0_AXIS_TUSER_WIDTH-1:0]    slot_0_axis_tuser,

    //SLOT 0 External Triggers
    input                                    slot_0_ext_trig,
    input                                    slot_0_ext_trig_stop,
  
    // SLOT 1 AXI MM interface signals
    
    input                                    slot_1_axi_aclk,
    input                                    slot_1_axi_aresetn,
    input [C_SLOT_1_AXI_ID_WIDTH-1:0]        slot_1_axi_awid,
    input [C_SLOT_1_AXI_ADDR_WIDTH-1:0]      slot_1_axi_awaddr,
    input [2:0]                              slot_1_axi_awprot,
    input [C_SLOT_1_AXI_AWLEN:0]             slot_1_axi_awlen,
    input [2:0]                              slot_1_axi_awsize,
    input [1:0]                              slot_1_axi_awburst,
    input [3:0]                              slot_1_axi_awcache,
    input [C_SLOT_1_AXI_LOCK : 0]            slot_1_axi_awlock,
    input                                    slot_1_axi_awvalid,
    input                                    slot_1_axi_awready,
    input [C_SLOT_1_AXI_DATA_WIDTH-1:0]      slot_1_axi_wdata,
    input [C_SLOT_1_AXI_DATA_WIDTH/8-1:0]    slot_1_axi_wstrb,
    input                                    slot_1_axi_wlast,
    input                                    slot_1_axi_wvalid,
    input                                    slot_1_axi_wready,
    input [C_SLOT_1_AXI_ID_WIDTH-1:0]        slot_1_axi_bid,
    input [1:0]                              slot_1_axi_bresp,
    input                                    slot_1_axi_bvalid,
    input                                    slot_1_axi_bready,
    input [C_SLOT_1_AXI_ID_WIDTH-1:0]        slot_1_axi_arid,
    input [C_SLOT_1_AXI_ADDR_WIDTH-1:0]      slot_1_axi_araddr,
    input [C_SLOT_1_AXI_AWLEN:0]             slot_1_axi_arlen,
    input [2:0]                              slot_1_axi_arsize,
    input [1:0]                              slot_1_axi_arburst,
    input [3:0]                              slot_1_axi_arcache,
    input [2:0]                              slot_1_axi_arprot,
    input [C_SLOT_1_AXI_LOCK : 0]            slot_1_axi_arlock,
    input                                    slot_1_axi_arvalid,
    input                                    slot_1_axi_arready,
    input [C_SLOT_1_AXI_ID_WIDTH-1:0]        slot_1_axi_rid,
    input [C_SLOT_1_AXI_DATA_WIDTH-1:0]      slot_1_axi_rdata,
    input [1:0]                              slot_1_axi_rresp,
    input                                    slot_1_axi_rlast,
    input                                    slot_1_axi_rvalid,
    input                                    slot_1_axi_rready,
  
    //SLOT 1 AXI Streaming Interface
    input                                    slot_1_axis_aclk,
    input                                    slot_1_axis_aresetn,
    input                                    slot_1_axis_tvalid,
    input                                    slot_1_axis_tready,
    input [C_SLOT_1_AXIS_TDATA_WIDTH-1:0]    slot_1_axis_tdata,
    input [C_SLOT_1_AXIS_TDATA_WIDTH/8-1:0]  slot_1_axis_tstrb,
    input [C_SLOT_1_AXIS_TDATA_WIDTH/8-1:0]  slot_1_axis_tkeep,
    input                                    slot_1_axis_tlast,
    input [C_SLOT_1_AXIS_TID_WIDTH-1:0]      slot_1_axis_tid,
    input [C_SLOT_1_AXIS_TDEST_WIDTH-1:0]    slot_1_axis_tdest,
    input [C_SLOT_1_AXIS_TUSER_WIDTH-1:0]    slot_1_axis_tuser,
  
    //SLOT 1 External Trigger
    input                                    slot_1_ext_trig,
    input                                    slot_1_ext_trig_stop,

    //SLOT 2 AXI MM Interface 
  
    input                                    slot_2_axi_aclk,
    input                                    slot_2_axi_aresetn,
    input [C_SLOT_2_AXI_ID_WIDTH-1:0]        slot_2_axi_awid,
    input [C_SLOT_2_AXI_ADDR_WIDTH-1:0]      slot_2_axi_awaddr,
    input [2:0]                              slot_2_axi_awprot,
    input [C_SLOT_2_AXI_AWLEN:0]             slot_2_axi_awlen,
    input [2:0]                              slot_2_axi_awsize,
    input [1:0]                              slot_2_axi_awburst,
    input [3:0]                              slot_2_axi_awcache,
    input [C_SLOT_2_AXI_LOCK : 0]            slot_2_axi_awlock,
    input                                    slot_2_axi_awvalid,
    input                                    slot_2_axi_awready,
    input [C_SLOT_2_AXI_DATA_WIDTH-1:0]      slot_2_axi_wdata,
    input [C_SLOT_2_AXI_DATA_WIDTH/8-1: 0]   slot_2_axi_wstrb,
    input                                    slot_2_axi_wlast,
    input                                    slot_2_axi_wvalid,
    input                                    slot_2_axi_wready,
    input [C_SLOT_2_AXI_ID_WIDTH-1:0]        slot_2_axi_bid,
    input [1:0]                              slot_2_axi_bresp,
    input                                    slot_2_axi_bvalid,
    input                                    slot_2_axi_bready,
    input [C_SLOT_2_AXI_ID_WIDTH-1:0]        slot_2_axi_arid,
    input [C_SLOT_2_AXI_ADDR_WIDTH-1:0]      slot_2_axi_araddr,
    input [C_SLOT_2_AXI_AWLEN:0]             slot_2_axi_arlen,
    input [2:0]                              slot_2_axi_arsize,
    input [1:0]                              slot_2_axi_arburst,
    input [3:0]                              slot_2_axi_arcache,
    input [2:0]                              slot_2_axi_arprot,
    input [C_SLOT_2_AXI_LOCK : 0]            slot_2_axi_arlock,
    input                                    slot_2_axi_arvalid,
    input                                    slot_2_axi_arready,
    input [C_SLOT_2_AXI_ID_WIDTH-1:0]        slot_2_axi_rid,
    input [C_SLOT_2_AXI_DATA_WIDTH-1:0]      slot_2_axi_rdata,
    input [1:0]                              slot_2_axi_rresp,
    input                                    slot_2_axi_rlast,
    input                                    slot_2_axi_rvalid,
    input                                    slot_2_axi_rready,
  
   //SLOT 2 AXI Streaming Interface
    input                                    slot_2_axis_aclk,
    input                                    slot_2_axis_aresetn,
    input                                    slot_2_axis_tvalid,
    input                                    slot_2_axis_tready,
    input [C_SLOT_2_AXIS_TDATA_WIDTH-1:0]    slot_2_axis_tdata,
    input [C_SLOT_2_AXIS_TDATA_WIDTH/8-1:0]  slot_2_axis_tstrb,
    input [C_SLOT_2_AXIS_TDATA_WIDTH/8-1:0]  slot_2_axis_tkeep,
    input                                    slot_2_axis_tlast,
    input [C_SLOT_2_AXIS_TID_WIDTH-1:0]      slot_2_axis_tid,
    input [C_SLOT_2_AXIS_TDEST_WIDTH-1:0]    slot_2_axis_tdest,
    input [C_SLOT_2_AXIS_TUSER_WIDTH-1:0]    slot_2_axis_tuser,

   //SLOT 2 External Trigger
    input                                    slot_2_ext_trig,
    input                                    slot_2_ext_trig_stop,
  
   //SLOT 3 AXI MM Interface
    input                                    slot_3_axi_aclk,
    input                                    slot_3_axi_aresetn,
    input [C_SLOT_3_AXI_ID_WIDTH-1:0]        slot_3_axi_awid,
    input [C_SLOT_3_AXI_ADDR_WIDTH-1:0]      slot_3_axi_awaddr,
    input [2:0]                              slot_3_axi_awprot,
    input [C_SLOT_3_AXI_AWLEN:0]             slot_3_axi_awlen,
    input [2:0]                              slot_3_axi_awsize,
    input [1:0]                              slot_3_axi_awburst,
    input [3:0]                              slot_3_axi_awcache,
    input [C_SLOT_3_AXI_LOCK : 0]            slot_3_axi_awlock,
    input                                    slot_3_axi_awvalid,
    input                                    slot_3_axi_awready,
    input [C_SLOT_3_AXI_DATA_WIDTH-1:0]      slot_3_axi_wdata,
    input [C_SLOT_3_AXI_DATA_WIDTH/8-1:0]    slot_3_axi_wstrb,
    input                                    slot_3_axi_wlast,
    input                                    slot_3_axi_wvalid,
    input                                    slot_3_axi_wready,
    input [C_SLOT_3_AXI_ID_WIDTH-1:0]        slot_3_axi_bid,
    input [1:0]                              slot_3_axi_bresp,
    input                                    slot_3_axi_bvalid,
    input                                    slot_3_axi_bready,
    input [C_SLOT_3_AXI_ID_WIDTH-1:0]        slot_3_axi_arid,
    input [C_SLOT_3_AXI_ADDR_WIDTH-1:0]      slot_3_axi_araddr,
    input [C_SLOT_3_AXI_AWLEN:0]             slot_3_axi_arlen,
    input [2:0]                              slot_3_axi_arsize,
    input [1:0]                              slot_3_axi_arburst,
    input [3:0]                              slot_3_axi_arcache,
    input [2:0]                              slot_3_axi_arprot,
    input [C_SLOT_3_AXI_LOCK : 0]            slot_3_axi_arlock,
    input                                    slot_3_axi_arvalid,
    input                                    slot_3_axi_arready,
    input [C_SLOT_3_AXI_ID_WIDTH-1:0]        slot_3_axi_rid,
    input [C_SLOT_3_AXI_DATA_WIDTH-1:0]      slot_3_axi_rdata,
    input [1:0]                              slot_3_axi_rresp,
    input                                    slot_3_axi_rlast,
    input                                    slot_3_axi_rvalid,
    input                                    slot_3_axi_rready,
  
    //SLOT 3 AXI Streaming Interface
    input                                    slot_3_axis_aclk,
    input                                    slot_3_axis_aresetn,
    input                                    slot_3_axis_tvalid,
    input                                    slot_3_axis_tready,
    input [C_SLOT_3_AXIS_TDATA_WIDTH-1:0]    slot_3_axis_tdata,
    input [C_SLOT_3_AXIS_TDATA_WIDTH/8-1:0]  slot_3_axis_tstrb,
    input [C_SLOT_3_AXIS_TDATA_WIDTH/8-1:0]  slot_3_axis_tkeep,
    input                                    slot_3_axis_tlast,
    input [C_SLOT_3_AXIS_TID_WIDTH-1:0]      slot_3_axis_tid,
    input [C_SLOT_3_AXIS_TDEST_WIDTH-1:0]    slot_3_axis_tdest,
    input [C_SLOT_3_AXIS_TUSER_WIDTH-1:0]    slot_3_axis_tuser,

    //SLOT 3 External Trigger
    input                                    slot_3_ext_trig,
    input                                    slot_3_ext_trig_stop,
  
    //SLOT 4 AXI MM Interface
    input                                    slot_4_axi_aclk,
    input                                    slot_4_axi_aresetn,
    input [C_SLOT_4_AXI_ID_WIDTH-1:0]        slot_4_axi_awid,
    input [C_SLOT_4_AXI_ADDR_WIDTH-1:0]      slot_4_axi_awaddr,
    input [2:0]                              slot_4_axi_awprot,
    input [C_SLOT_4_AXI_AWLEN:0]             slot_4_axi_awlen,
    input [2:0]                              slot_4_axi_awsize,
    input [1:0]                              slot_4_axi_awburst,
    input [3:0]                              slot_4_axi_awcache,
    input [C_SLOT_4_AXI_LOCK : 0]            slot_4_axi_awlock,
    input                                    slot_4_axi_awvalid,
    input                                    slot_4_axi_awready,
    input [C_SLOT_4_AXI_DATA_WIDTH-1:0]      slot_4_axi_wdata,
    input [C_SLOT_4_AXI_DATA_WIDTH/8-1:0]    slot_4_axi_wstrb,
    input                                    slot_4_axi_wlast,
    input                                    slot_4_axi_wvalid,
    input                                    slot_4_axi_wready,
    input [C_SLOT_4_AXI_ID_WIDTH-1:0]        slot_4_axi_bid,
    input [1:0]                              slot_4_axi_bresp,
    input                                    slot_4_axi_bvalid,
    input                                    slot_4_axi_bready,
    input  [C_SLOT_4_AXI_ID_WIDTH-1:0]       slot_4_axi_arid,
    input  [C_SLOT_4_AXI_ADDR_WIDTH-1:0]     slot_4_axi_araddr,
    input  [C_SLOT_4_AXI_AWLEN:0]            slot_4_axi_arlen,
    input  [2:0]                             slot_4_axi_arsize,
    input  [1:0]                             slot_4_axi_arburst,
    input  [3:0]                             slot_4_axi_arcache,
    input  [2:0]                             slot_4_axi_arprot,
    input [C_SLOT_4_AXI_LOCK : 0]            slot_4_axi_arlock,
    input                                    slot_4_axi_arvalid,
    input                                    slot_4_axi_arready,
    input [C_SLOT_4_AXI_ID_WIDTH-1:0]        slot_4_axi_rid,
    input [C_SLOT_4_AXI_DATA_WIDTH-1:0]      slot_4_axi_rdata,
    input [1:0]                              slot_4_axi_rresp,
    input                                    slot_4_axi_rlast,
    input                                    slot_4_axi_rvalid,
    input                                    slot_4_axi_rready,
  
    //SLOT 4 AXI Streaming Interface
    input                                    slot_4_axis_aclk,
    input                                    slot_4_axis_aresetn,
    input                                    slot_4_axis_tvalid,
    input                                    slot_4_axis_tready,
    input [C_SLOT_4_AXIS_TDATA_WIDTH-1:0]    slot_4_axis_tdata,
    input [C_SLOT_4_AXIS_TDATA_WIDTH/8-1:0]  slot_4_axis_tstrb,
    input [C_SLOT_4_AXIS_TDATA_WIDTH/8-1:0]  slot_4_axis_tkeep,
    input                                    slot_4_axis_tlast,
    input [C_SLOT_4_AXIS_TID_WIDTH-1:0]      slot_4_axis_tid,
    input [C_SLOT_4_AXIS_TDEST_WIDTH-1:0]    slot_4_axis_tdest,
    input [C_SLOT_4_AXIS_TUSER_WIDTH-1:0]    slot_4_axis_tuser,

    //SLOT 4 External Trigger
    input                                    slot_4_ext_trig,
    input                                    slot_4_ext_trig_stop,

    //SLOT 5 AXI MM Interface
  
    input                                    slot_5_axi_aclk,
    input                                    slot_5_axi_aresetn,
    input [C_SLOT_5_AXI_ID_WIDTH-1:0]        slot_5_axi_awid,
    input [C_SLOT_5_AXI_ADDR_WIDTH-1:0]      slot_5_axi_awaddr,
    input [2:0]                              slot_5_axi_awprot,
    input [C_SLOT_5_AXI_AWLEN:0]             slot_5_axi_awlen,
    input [2:0]                              slot_5_axi_awsize,
    input [1:0]                              slot_5_axi_awburst,
    input [3:0]                              slot_5_axi_awcache,
    input [C_SLOT_5_AXI_LOCK : 0]            slot_5_axi_awlock,
    input                                    slot_5_axi_awvalid,
    input                                    slot_5_axi_awready,
    input [C_SLOT_5_AXI_DATA_WIDTH-1:0]      slot_5_axi_wdata,
    input [C_SLOT_5_AXI_DATA_WIDTH/8-1:0]    slot_5_axi_wstrb,
    input                                    slot_5_axi_wlast,
    input                                    slot_5_axi_wvalid,
    input                                    slot_5_axi_wready,
    input [C_SLOT_5_AXI_ID_WIDTH-1:0]        slot_5_axi_bid,
    input [1:0]                              slot_5_axi_bresp,
    input                                    slot_5_axi_bvalid,
    input                                    slot_5_axi_bready,
    input [C_SLOT_5_AXI_ID_WIDTH-1:0]        slot_5_axi_arid,
    input [C_SLOT_5_AXI_ADDR_WIDTH-1:0]      slot_5_axi_araddr,
    input [C_SLOT_5_AXI_AWLEN:0]             slot_5_axi_arlen,
    input [2:0]                              slot_5_axi_arsize,
    input [1:0]                              slot_5_axi_arburst,
    input [3:0]                              slot_5_axi_arcache,
    input [2:0]                              slot_5_axi_arprot,
    input [C_SLOT_5_AXI_LOCK : 0]            slot_5_axi_arlock,
    input                                    slot_5_axi_arvalid,
    input                                    slot_5_axi_arready,
    input [C_SLOT_5_AXI_ID_WIDTH-1:0]        slot_5_axi_rid,
    input [C_SLOT_5_AXI_DATA_WIDTH-1:0]      slot_5_axi_rdata,
    input [1:0]                              slot_5_axi_rresp,
    input                                    slot_5_axi_rlast,
    input                                    slot_5_axi_rvalid,
    input                                    slot_5_axi_rready,
  
    //SLOT 5 AXI Streaming Interface
    input                                    slot_5_axis_aclk,
    input                                    slot_5_axis_aresetn,
    input                                    slot_5_axis_tvalid,
    input                                    slot_5_axis_tready,
    input [C_SLOT_5_AXIS_TDATA_WIDTH-1:0]    slot_5_axis_tdata,
    input [C_SLOT_5_AXIS_TDATA_WIDTH/8-1:0]  slot_5_axis_tstrb,
    input [C_SLOT_5_AXIS_TDATA_WIDTH/8-1:0]  slot_5_axis_tkeep,
    input                                    slot_5_axis_tlast,
    input [C_SLOT_5_AXIS_TID_WIDTH-1:0]      slot_5_axis_tid,
    input [C_SLOT_5_AXIS_TDEST_WIDTH-1:0]    slot_5_axis_tdest,
    input [C_SLOT_5_AXIS_TUSER_WIDTH-1:0]    slot_5_axis_tuser,

    //SLOT 5 External Trigger
    input                                    slot_5_ext_trig,
    input                                    slot_5_ext_trig_stop,
  
    //SLOT 6 AXI MM Interface
    input                                    slot_6_axi_aclk,
    input                                    slot_6_axi_aresetn,
    input [C_SLOT_6_AXI_ID_WIDTH-1:0]        slot_6_axi_awid,
    input [C_SLOT_6_AXI_ADDR_WIDTH-1:0]      slot_6_axi_awaddr,
    input [2:0]                              slot_6_axi_awprot,
    input [C_SLOT_6_AXI_AWLEN:0]             slot_6_axi_awlen,
    input [2:0]                              slot_6_axi_awsize,
    input [1:0]                              slot_6_axi_awburst,
    input [3:0]                              slot_6_axi_awcache,
    input [C_SLOT_6_AXI_LOCK : 0]            slot_6_axi_awlock,
    input                                    slot_6_axi_awvalid,
    input                                    slot_6_axi_awready,
    input [C_SLOT_6_AXI_DATA_WIDTH-1:0]      slot_6_axi_wdata,
    input [C_SLOT_6_AXI_DATA_WIDTH/8-1:0]    slot_6_axi_wstrb,
    input                                    slot_6_axi_wlast,
    input                                    slot_6_axi_wvalid,
    input                                    slot_6_axi_wready,
    input [C_SLOT_6_AXI_ID_WIDTH-1:0]        slot_6_axi_bid,
    input [1:0]                              slot_6_axi_bresp,
    input                                    slot_6_axi_bvalid,
    input                                    slot_6_axi_bready,
    input [C_SLOT_6_AXI_ID_WIDTH-1:0]        slot_6_axi_arid,
    input [C_SLOT_6_AXI_ADDR_WIDTH-1:0]      slot_6_axi_araddr,
    input [C_SLOT_6_AXI_AWLEN:0]             slot_6_axi_arlen,
    input [2:0]                              slot_6_axi_arsize,
    input [1:0]                              slot_6_axi_arburst,
    input [3:0]                              slot_6_axi_arcache,
    input [2:0]                              slot_6_axi_arprot,
    input [C_SLOT_6_AXI_LOCK : 0]            slot_6_axi_arlock,
    input                                    slot_6_axi_arvalid,
    input                                    slot_6_axi_arready,
    input [C_SLOT_6_AXI_ID_WIDTH-1:0]        slot_6_axi_rid,
    input [C_SLOT_6_AXI_DATA_WIDTH-1:0]      slot_6_axi_rdata,
    input [1:0]                              slot_6_axi_rresp,
    input                                    slot_6_axi_rlast,
    input                                    slot_6_axi_rvalid,
    input                                    slot_6_axi_rready,
  
    //SLOT 6 AXI Streaming Interface
    input                                    slot_6_axis_aclk,
    input                                    slot_6_axis_aresetn,
    input                                    slot_6_axis_tvalid,
    input                                    slot_6_axis_tready,
    input [C_SLOT_6_AXIS_TDATA_WIDTH-1:0]    slot_6_axis_tdata,
    input [C_SLOT_6_AXIS_TDATA_WIDTH/8-1:0]  slot_6_axis_tstrb,
    input [C_SLOT_6_AXIS_TDATA_WIDTH/8-1:0]  slot_6_axis_tkeep,
    input                                    slot_6_axis_tlast,
    input [C_SLOT_6_AXIS_TID_WIDTH-1:0]      slot_6_axis_tid,
    input [C_SLOT_6_AXIS_TDEST_WIDTH-1:0]    slot_6_axis_tdest,
    input [C_SLOT_6_AXIS_TUSER_WIDTH-1:0]    slot_6_axis_tuser,

    //SLOT 6 External Trigger
    input                                    slot_6_ext_trig,
    input                                    slot_6_ext_trig_stop,
  
    //SLOT 7 AXI MM Interface
    input                                    slot_7_axi_aclk,
    input                                    slot_7_axi_aresetn,
    input [C_SLOT_7_AXI_ID_WIDTH-1:0]        slot_7_axi_awid,
    input [C_SLOT_7_AXI_ADDR_WIDTH-1:0]      slot_7_axi_awaddr,
    input [2:0]                              slot_7_axi_awprot,
    input [C_SLOT_7_AXI_AWLEN:0]             slot_7_axi_awlen,
    input [2:0]                              slot_7_axi_awsize,
    input [1:0]                              slot_7_axi_awburst,
    input [3:0]                              slot_7_axi_awcache,
    input [C_SLOT_7_AXI_LOCK : 0]            slot_7_axi_awlock,
    input                                    slot_7_axi_awvalid,
    input                                    slot_7_axi_awready,
    input [C_SLOT_7_AXI_DATA_WIDTH-1:0]      slot_7_axi_wdata,
    input [C_SLOT_7_AXI_DATA_WIDTH/8-1:0]    slot_7_axi_wstrb,
    input                                    slot_7_axi_wlast,
    input                                    slot_7_axi_wvalid,
    input                                    slot_7_axi_wready,
    input [C_SLOT_7_AXI_ID_WIDTH-1:0]        slot_7_axi_bid,
    input [1:0]                              slot_7_axi_bresp,
    input                                    slot_7_axi_bvalid,
    input                                    slot_7_axi_bready,
    input [C_SLOT_7_AXI_ID_WIDTH-1:0]        slot_7_axi_arid,
    input [C_SLOT_7_AXI_ADDR_WIDTH-1:0]      slot_7_axi_araddr,
    input [C_SLOT_7_AXI_AWLEN:0]             slot_7_axi_arlen,
    input [2:0]                              slot_7_axi_arsize,
    input [1:0]                              slot_7_axi_arburst,
    input [3:0]                              slot_7_axi_arcache,
    input [2:0]                              slot_7_axi_arprot,
    input [C_SLOT_7_AXI_LOCK : 0]            slot_7_axi_arlock,
    input                                    slot_7_axi_arvalid,
    input                                    slot_7_axi_arready,
    input  [C_SLOT_7_AXI_ID_WIDTH-1:0]       slot_7_axi_rid,
    input  [C_SLOT_7_AXI_DATA_WIDTH-1:0]     slot_7_axi_rdata,
    input  [1:0]                             slot_7_axi_rresp,
    input                                    slot_7_axi_rlast,
    input                                    slot_7_axi_rvalid,
    input                                    slot_7_axi_rready,
  
    //SLOT 7 AXI Streaming Interface
    input                                    slot_7_axis_aclk,
    input                                    slot_7_axis_aresetn,
    input                                    slot_7_axis_tvalid,
    input                                    slot_7_axis_tready,
    input [C_SLOT_7_AXIS_TDATA_WIDTH-1:0]    slot_7_axis_tdata,
    input [C_SLOT_7_AXIS_TDATA_WIDTH/8-1:0]  slot_7_axis_tstrb,
    input [C_SLOT_7_AXIS_TDATA_WIDTH/8-1:0]  slot_7_axis_tkeep,
    input                                    slot_7_axis_tlast,
    input [C_SLOT_7_AXIS_TID_WIDTH-1:0]      slot_7_axis_tid,
    input [C_SLOT_7_AXIS_TDEST_WIDTH-1:0]    slot_7_axis_tdest,
    input [C_SLOT_7_AXIS_TUSER_WIDTH-1:0]    slot_7_axis_tuser,
 
    //SLOT 7 External Trigger
    input                                    slot_7_ext_trig,
    input                                    slot_7_ext_trig_stop,
 
     // External Event 0
    input                                    ext_clk_0,
    input                                    ext_rstn_0,
    input                                    ext_event_0_cnt_start,
    input                                    ext_event_0_cnt_stop,
    input                                    ext_event_0,
  
     // External Event 1
    input                                    ext_clk_1,
    input                                    ext_rstn_1,
    input                                    ext_event_1_cnt_start,
    input                                    ext_event_1_cnt_stop,
    input                                    ext_event_1,

     // External Event 2
    input                                    ext_clk_2,
    input                                    ext_rstn_2,
    input                                    ext_event_2_cnt_start,
    input                                    ext_event_2_cnt_stop,
    input                                    ext_event_2,

     // External Event 3
    input                                    ext_clk_3,
    input                                    ext_rstn_3,
    input                                    ext_event_3_cnt_start,
    input                                    ext_event_3_cnt_stop,
    input                                    ext_event_3,

    // External Event 4
    input                                    ext_clk_4,
    input                                    ext_rstn_4,
    input                                    ext_event_4_cnt_start,
    input                                    ext_event_4_cnt_stop,
    input                                    ext_event_4,

    // External Event 5
    input                                    ext_clk_5,
    input                                    ext_rstn_5,
    input                                    ext_event_5_cnt_start,
    input                                    ext_event_5_cnt_stop,
    input                                    ext_event_5,

    // External Event 6
    input                                    ext_clk_6,
    input                                    ext_rstn_6,
    input                                    ext_event_6_cnt_start,
    input                                    ext_event_6_cnt_stop,
    input                                    ext_event_6,

    // External Event 7
    input                                    ext_clk_7,
    input                                    ext_rstn_7,
    input                                    ext_event_7_cnt_start,
    input                                    ext_event_7_cnt_stop,
    input                                    ext_event_7,
  
     // Capture and Reset events for metric counters
    input                                    capture_event,
    input                                    reset_event,
  
     // Core Clock and Reset signals
    input                                    core_aclk,
    input                                    core_aresetn,
 
     // Event Log streaming interface
    input                                    m_axis_aclk,
    input                                    m_axis_aresetn,
    output [C_FIFO_AXIS_TDATA_WIDTH-1:0]     m_axis_tdata,
    output [C_FIFO_AXIS_TDATA_WIDTH/8-1:0]   m_axis_tstrb,
    output                                   m_axis_tvalid,
    output [C_FIFO_AXIS_TID_WIDTH-1:0]       m_axis_tid,
    input                                    m_axis_tready,
    
     // Event Log 32b memorymap  interface
    input                                   s_axi_offld_aclk,
    input                                   s_axi_offld_aresetn,
    input [31:0]                            s_axi_offld_araddr ,
    input                                   s_axi_offld_arvalid,
    input [7:0]                             s_axi_offld_arlen  ,
    input [S_AXI_OFFLD_ID_WIDTH-1:0]        s_axi_offld_arid   ,    
    output                                  s_axi_offld_arready,
    input                                   s_axi_offld_rready ,
    output [31:0]                           s_axi_offld_rdata  ,
    output [1:0]                            s_axi_offld_rresp  ,
    output                                  s_axi_offld_rvalid ,
    output [S_AXI_OFFLD_ID_WIDTH-1:0]       s_axi_offld_rid    ,      
    output                                  s_axi_offld_rlast ,
    
     // Interrupt to the Processor
    output                                   interrupt,
    input                       			      trigger_in,
    output 				    trigger_in_ack
);
  

   /*---------------------------------------------------------------------
   -----------------------Parameter declarations-------------------------
   ------------------------------------------------------------------------*/

   localparam SLOT_0_AXI_PROTOCOL = (C_SLOT_0_AXI_PROTOCOL == "AXI3" || C_SLOT_0_AXI_PROTOCOL == "AXI4LITE" )?"AXI4":C_SLOT_0_AXI_PROTOCOL;
   localparam SLOT_1_AXI_PROTOCOL = (C_SLOT_1_AXI_PROTOCOL == "AXI3" || C_SLOT_1_AXI_PROTOCOL == "AXI4LITE" )?"AXI4":C_SLOT_1_AXI_PROTOCOL;
   localparam SLOT_2_AXI_PROTOCOL = (C_SLOT_2_AXI_PROTOCOL == "AXI3" || C_SLOT_2_AXI_PROTOCOL == "AXI4LITE" )?"AXI4":C_SLOT_2_AXI_PROTOCOL;
   localparam SLOT_3_AXI_PROTOCOL = (C_SLOT_3_AXI_PROTOCOL == "AXI3" || C_SLOT_3_AXI_PROTOCOL == "AXI4LITE" )?"AXI4":C_SLOT_3_AXI_PROTOCOL;
   localparam SLOT_4_AXI_PROTOCOL = (C_SLOT_4_AXI_PROTOCOL == "AXI3" || C_SLOT_4_AXI_PROTOCOL == "AXI4LITE" )?"AXI4":C_SLOT_4_AXI_PROTOCOL;
   localparam SLOT_5_AXI_PROTOCOL = (C_SLOT_5_AXI_PROTOCOL == "AXI3" || C_SLOT_5_AXI_PROTOCOL == "AXI4LITE" )?"AXI4":C_SLOT_5_AXI_PROTOCOL;
   localparam SLOT_6_AXI_PROTOCOL = (C_SLOT_6_AXI_PROTOCOL == "AXI3" || C_SLOT_6_AXI_PROTOCOL == "AXI4LITE" )?"AXI4":C_SLOT_6_AXI_PROTOCOL;
   localparam SLOT_7_AXI_PROTOCOL = (C_SLOT_7_AXI_PROTOCOL == "AXI3" || C_SLOT_7_AXI_PROTOCOL == "AXI4LITE" )?"AXI4":C_SLOT_7_AXI_PROTOCOL;

   localparam SLOT_0_AXI_SUB_PROTOCOL = (C_SLOT_0_AXI_PROTOCOL == "AXI4LITE")?"AXI4LITE":"NONE";
   localparam SLOT_1_AXI_SUB_PROTOCOL = (C_SLOT_1_AXI_PROTOCOL == "AXI4LITE")?"AXI4LITE":"NONE";
   localparam SLOT_2_AXI_SUB_PROTOCOL = (C_SLOT_2_AXI_PROTOCOL == "AXI4LITE")?"AXI4LITE":"NONE";
   localparam SLOT_3_AXI_SUB_PROTOCOL = (C_SLOT_3_AXI_PROTOCOL == "AXI4LITE")?"AXI4LITE":"NONE";
   localparam SLOT_4_AXI_SUB_PROTOCOL = (C_SLOT_4_AXI_PROTOCOL == "AXI4LITE")?"AXI4LITE":"NONE";
   localparam SLOT_5_AXI_SUB_PROTOCOL = (C_SLOT_5_AXI_PROTOCOL == "AXI4LITE")?"AXI4LITE":"NONE";
   localparam SLOT_6_AXI_SUB_PROTOCOL = (C_SLOT_6_AXI_PROTOCOL == "AXI4LITE")?"AXI4LITE":"NONE";
   localparam SLOT_7_AXI_SUB_PROTOCOL = (C_SLOT_7_AXI_PROTOCOL == "AXI4LITE")?"AXI4LITE":"NONE";

   wire [15:0] s_axi_araddr_int = (C_LITE_ADDRESS_WIDTH == 16) ? s_axi_araddr : {4'h0,s_axi_araddr};
   wire [15:0] s_axi_awaddr_int = (C_LITE_ADDRESS_WIDTH == 16) ? s_axi_awaddr : {4'h0,s_axi_awaddr};
   //Make wlast=wvalid when protocol is axi4lite.cr#778335
   wire slot_0_axi_wlast_i = (C_SLOT_0_AXI_PROTOCOL == "AXI4LITE") ? slot_0_axi_wvalid : slot_0_axi_wlast;
   wire slot_1_axi_wlast_i = (C_SLOT_1_AXI_PROTOCOL == "AXI4LITE") ? slot_1_axi_wvalid : slot_1_axi_wlast;
   wire slot_2_axi_wlast_i = (C_SLOT_2_AXI_PROTOCOL == "AXI4LITE") ? slot_2_axi_wvalid : slot_2_axi_wlast;
   wire slot_3_axi_wlast_i = (C_SLOT_3_AXI_PROTOCOL == "AXI4LITE") ? slot_3_axi_wvalid : slot_3_axi_wlast;
   wire slot_4_axi_wlast_i = (C_SLOT_4_AXI_PROTOCOL == "AXI4LITE") ? slot_4_axi_wvalid : slot_4_axi_wlast;
   wire slot_5_axi_wlast_i = (C_SLOT_5_AXI_PROTOCOL == "AXI4LITE") ? slot_5_axi_wvalid : slot_5_axi_wlast;
   wire slot_6_axi_wlast_i = (C_SLOT_6_AXI_PROTOCOL == "AXI4LITE") ? slot_6_axi_wvalid : slot_6_axi_wlast;
   wire slot_7_axi_wlast_i = (C_SLOT_7_AXI_PROTOCOL == "AXI4LITE") ? slot_7_axi_wvalid : slot_7_axi_wlast;
   
   //Make rlast=rvalid when protocol is axi4lite.cr#778335
   wire slot_0_axi_rlast_i = (C_SLOT_0_AXI_PROTOCOL == "AXI4LITE") ? slot_0_axi_rvalid : slot_0_axi_rlast;
   wire slot_1_axi_rlast_i = (C_SLOT_1_AXI_PROTOCOL == "AXI4LITE") ? slot_1_axi_rvalid : slot_1_axi_rlast;
   wire slot_2_axi_rlast_i = (C_SLOT_2_AXI_PROTOCOL == "AXI4LITE") ? slot_2_axi_rvalid : slot_2_axi_rlast;
   wire slot_3_axi_rlast_i = (C_SLOT_3_AXI_PROTOCOL == "AXI4LITE") ? slot_3_axi_rvalid : slot_3_axi_rlast;
   wire slot_4_axi_rlast_i = (C_SLOT_4_AXI_PROTOCOL == "AXI4LITE") ? slot_4_axi_rvalid : slot_4_axi_rlast;
   wire slot_5_axi_rlast_i = (C_SLOT_5_AXI_PROTOCOL == "AXI4LITE") ? slot_5_axi_rvalid : slot_5_axi_rlast;
   wire slot_6_axi_rlast_i = (C_SLOT_6_AXI_PROTOCOL == "AXI4LITE") ? slot_6_axi_rvalid : slot_6_axi_rlast;
   wire slot_7_axi_rlast_i = (C_SLOT_7_AXI_PROTOCOL == "AXI4LITE") ? slot_7_axi_rvalid : slot_7_axi_rlast;

   //awlen width as per protocol
   wire [7:0] slot_0_axi_awlen_i = (C_SLOT_0_AXI_PROTOCOL == "AXI3") ? {4'b0,slot_0_axi_awlen} : slot_0_axi_awlen;
   wire [7:0] slot_1_axi_awlen_i = (C_SLOT_1_AXI_PROTOCOL == "AXI3") ? {4'b0,slot_1_axi_awlen} : slot_1_axi_awlen;
   wire [7:0] slot_2_axi_awlen_i = (C_SLOT_2_AXI_PROTOCOL == "AXI3") ? {4'b0,slot_2_axi_awlen} : slot_2_axi_awlen;
   wire [7:0] slot_3_axi_awlen_i = (C_SLOT_3_AXI_PROTOCOL == "AXI3") ? {4'b0,slot_3_axi_awlen} : slot_3_axi_awlen;
   wire [7:0] slot_4_axi_awlen_i = (C_SLOT_4_AXI_PROTOCOL == "AXI3") ? {4'b0,slot_4_axi_awlen} : slot_4_axi_awlen;
   wire [7:0] slot_5_axi_awlen_i = (C_SLOT_5_AXI_PROTOCOL == "AXI3") ? {4'b0,slot_5_axi_awlen} : slot_5_axi_awlen;
   wire [7:0] slot_6_axi_awlen_i = (C_SLOT_6_AXI_PROTOCOL == "AXI3") ? {4'b0,slot_6_axi_awlen} : slot_6_axi_awlen;
   wire [7:0] slot_7_axi_awlen_i = (C_SLOT_7_AXI_PROTOCOL == "AXI3") ? {4'b0,slot_7_axi_awlen} : slot_7_axi_awlen;
   wire [7:0] slot_0_axi_arlen_i = (C_SLOT_0_AXI_PROTOCOL == "AXI3") ? {4'b0,slot_0_axi_arlen} : slot_0_axi_arlen;
   wire [7:0] slot_1_axi_arlen_i = (C_SLOT_1_AXI_PROTOCOL == "AXI3") ? {4'b0,slot_1_axi_arlen} : slot_1_axi_arlen;
   wire [7:0] slot_2_axi_arlen_i = (C_SLOT_2_AXI_PROTOCOL == "AXI3") ? {4'b0,slot_2_axi_arlen} : slot_2_axi_arlen;
   wire [7:0] slot_3_axi_arlen_i = (C_SLOT_3_AXI_PROTOCOL == "AXI3") ? {4'b0,slot_3_axi_arlen} : slot_3_axi_arlen;
   wire [7:0] slot_4_axi_arlen_i = (C_SLOT_4_AXI_PROTOCOL == "AXI3") ? {4'b0,slot_4_axi_arlen} : slot_4_axi_arlen;
   wire [7:0] slot_5_axi_arlen_i = (C_SLOT_5_AXI_PROTOCOL == "AXI3") ? {4'b0,slot_5_axi_arlen} : slot_5_axi_arlen;
   wire [7:0] slot_6_axi_arlen_i = (C_SLOT_6_AXI_PROTOCOL == "AXI3") ? {4'b0,slot_6_axi_arlen} : slot_6_axi_arlen;
   wire [7:0] slot_7_axi_arlen_i = (C_SLOT_7_AXI_PROTOCOL == "AXI3") ? {4'b0,slot_7_axi_arlen} : slot_7_axi_arlen;

   /*----------------------------------------------------------------------
   ------------------- Submodule instantiations-----------------------------
   -----------------------------------------------------------------------*/ 
wire rst_flop_ze_out,rst_flop_fi_out;
wire flop_ze_out,flop_fi_out;

//(*ASYNC_REG = "TRUE" *) reg sync_flop_0,sync_flop_1,sync_flop_2;
wire capture_event_sync,reset_event_sync;
//(*ASYNC_REG = "TRUE" *) reg rst_sync_flop_0,rst_sync_flop_1,rst_sync_flop_2;

axi_perf_mon_v5_0_12_dff_async_reset ext_sync_flop_0 (
  .clk   (core_aclk),
  .reset (capture_event),
  .data  (1'b0),
  .q     (flop_ze_out)
);

axi_perf_mon_v5_0_12_dff_async_reset ext_sync_flop_1 (
  .clk   (core_aclk),
  .reset (capture_event),
  .data  (flop_ze_out),
  .q     (flop_fi_out)
);

axi_perf_mon_v5_0_12_cdc_sync
    #(
       .c_cdc_type      (1             ),   
       .c_flop_input    (0             ),  
       .c_reset_state   (1             ),  
       .c_single_bit    (1             ),  
       .c_vector_width  (1             ),  
       .c_mtbf_stages   (4             )  
     ) reset_event_cdc_sync 
     (
       .prmry_aclk      (1'b1                    ),
       .prmry_rst_n     (1'b1                    ),
       .prmry_in        (flop_fi_out             ),
       .prmry_vect_in   (1'b0                    ),
       .scndry_aclk     (core_aclk               ),
       .scndry_rst_n    (core_aresetn            ),
       .prmry_ack       (                        ),
       .scndry_out      (capture_event_sync      ),
       .scndry_vect_out (                        ) 
      );
//always @(posedge core_aclk) begin
//  sync_flop_0     <= (core_aresetn) ? flop_fi_out : 1'b0;
//  sync_flop_1     <= (core_aresetn) ? sync_flop_0 : 1'b0;
//  sync_flop_2     <= (core_aresetn) ? sync_flop_1 : 1'b0;
//  capture_event_sync  <= (core_aresetn) ? sync_flop_2 : 1'b0;
//end

axi_perf_mon_v5_0_12_dff_async_reset ext_sync_flop_00 (
  .clk   (core_aclk),
  .reset (reset_event),
  .data  (1'b0),
  .q     (rst_flop_ze_out)
);

axi_perf_mon_v5_0_12_dff_async_reset ext_sync_flop_10 (
  .clk   (core_aclk),
  .reset (reset_event),
  .data  (rst_flop_ze_out),
  .q     (rst_flop_fi_out)
);

axi_perf_mon_v5_0_12_cdc_sync
    #(
       .c_cdc_type      (1             ),   
       .c_flop_input    (0             ),  
       .c_reset_state   (1             ),  
       .c_single_bit    (1             ),  
       .c_vector_width  (1             ),  
       .c_mtbf_stages   (4             )  
     ) reset_event_cdc_sync1 
     (
       .prmry_aclk      (1'b1                    ),
       .prmry_rst_n     (1'b1                    ),
       .prmry_in        (rst_flop_fi_out         ),
       .prmry_vect_in   (1'b0                    ),
       .scndry_aclk     (core_aclk               ),
       .scndry_rst_n    (core_aresetn            ),
       .prmry_ack       (                        ),
       .scndry_out      (reset_event_sync        ),
       .scndry_vect_out (                        ) 
      );
//always @(posedge core_aclk) begin
//  rst_sync_flop_0     <= (core_aresetn) ? rst_flop_fi_out : 1'b0;
//  rst_sync_flop_1     <= (core_aresetn) ? rst_sync_flop_0 : 1'b0;
//  rst_sync_flop_2     <= (core_aresetn) ? rst_sync_flop_1 : 1'b0;
//  reset_event_sync  <= (core_aresetn) ? rst_sync_flop_2 : 1'b0;
//end


   generate if( C_ENABLE_ADVANCED == 1) begin: GEN_Advanced_Mode 
   axi_perf_mon_v5_0_12_advanced 
    # (
    .C_FAMILY                      (C_FAMILY), 
    .C_S_AXI_ADDR_WIDTH            (C_S_AXI_ADDR_WIDTH), 
    .C_S_AXI_DATA_WIDTH            (C_S_AXI_DATA_WIDTH), 
    .C_S_AXI_PROTOCOL              (C_S_AXI_PROTOCOL), 
    .C_S_AXI_ID_WIDTH              (C_S_AXI_ID_WIDTH), 
    .C_SUPPORT_ID_REFLECTION       (C_SUPPORT_ID_REFLECTION), 
    .C_NUM_MONITOR_SLOTS           (C_NUM_MONITOR_SLOTS), 
    .C_ENABLE_EVENT_COUNT          (C_ENABLE_EVENT_COUNT), 
    .C_NUM_OF_COUNTERS             (C_NUM_OF_COUNTERS),  
    .C_METRIC_COUNT_WIDTH          (C_METRIC_COUNT_WIDTH),  
    .C_METRIC_COUNT_SCALE          (C_METRIC_COUNT_SCALE),  
    .C_GLOBAL_COUNT_WIDTH          (C_GLOBAL_COUNT_WIDTH),  
    .C_HAVE_SAMPLED_METRIC_CNT     (C_HAVE_SAMPLED_METRIC_CNT),  
    .C_METRICS_SAMPLE_COUNT_WIDTH  (C_METRICS_SAMPLE_COUNT_WIDTH),  
    .C_AXI4LITE_CORE_CLK_ASYNC     (C_AXI4LITE_CORE_CLK_ASYNC),  
    .C_SLOT_0_AXI_ADDR_WIDTH       (C_SLOT_0_AXI_ADDR_WIDTH),  
    .C_SLOT_0_AXI_DATA_WIDTH       (C_SLOT_0_AXI_DATA_WIDTH),  
    .C_SLOT_0_AXI_ID_WIDTH         (C_SLOT_0_AXI_ID_WIDTH),  
    .C_SLOT_0_AXI_PROTOCOL         (SLOT_0_AXI_PROTOCOL),  
    .C_SLOT_0_AXI_SUB_PROTOCOL     (SLOT_0_AXI_SUB_PROTOCOL),  
    .C_SLOT_0_AXIS_TDATA_WIDTH     (C_SLOT_0_AXIS_TDATA_WIDTH),  
    .C_SLOT_0_AXIS_TID_WIDTH       (C_SLOT_0_AXIS_TID_WIDTH),  
    .C_SLOT_0_AXIS_TDEST_WIDTH     (C_SLOT_0_AXIS_TDEST_WIDTH),  
    .C_SLOT_0_AXIS_TUSER_WIDTH     (C_SLOT_0_AXIS_TUSER_WIDTH),  
    .C_SLOT_0_FIFO_ENABLE          (C_SLOT_0_FIFO_ENABLE),  
    .C_SLOT_1_AXI_ADDR_WIDTH       (C_SLOT_1_AXI_ADDR_WIDTH),  
    .C_SLOT_1_AXI_DATA_WIDTH       (C_SLOT_1_AXI_DATA_WIDTH),  
    .C_SLOT_1_AXI_ID_WIDTH         (C_SLOT_1_AXI_ID_WIDTH),  
    .C_SLOT_1_AXI_PROTOCOL         (SLOT_1_AXI_PROTOCOL),  
    .C_SLOT_1_AXI_SUB_PROTOCOL     (SLOT_1_AXI_SUB_PROTOCOL),  
    .C_SLOT_1_AXIS_TDATA_WIDTH     (C_SLOT_1_AXIS_TDATA_WIDTH),  
    .C_SLOT_1_AXIS_TID_WIDTH       (C_SLOT_1_AXIS_TID_WIDTH),  
    .C_SLOT_1_AXIS_TDEST_WIDTH     (C_SLOT_1_AXIS_TDEST_WIDTH),  
    .C_SLOT_1_AXIS_TUSER_WIDTH     (C_SLOT_1_AXIS_TUSER_WIDTH),  
    .C_SLOT_1_FIFO_ENABLE          (C_SLOT_1_FIFO_ENABLE),  
    .C_SLOT_2_AXI_ADDR_WIDTH       (C_SLOT_2_AXI_ADDR_WIDTH),  
    .C_SLOT_2_AXI_DATA_WIDTH       (C_SLOT_2_AXI_DATA_WIDTH),  
    .C_SLOT_2_AXI_ID_WIDTH         (C_SLOT_2_AXI_ID_WIDTH),  
    .C_SLOT_2_AXI_PROTOCOL         (SLOT_2_AXI_PROTOCOL),  
    .C_SLOT_2_AXI_SUB_PROTOCOL     (SLOT_2_AXI_SUB_PROTOCOL),  
    .C_SLOT_2_AXIS_TDATA_WIDTH     (C_SLOT_2_AXIS_TDATA_WIDTH),  
    .C_SLOT_2_AXIS_TID_WIDTH       (C_SLOT_2_AXIS_TID_WIDTH),  
    .C_SLOT_2_AXIS_TDEST_WIDTH     (C_SLOT_2_AXIS_TDEST_WIDTH),  
    .C_SLOT_2_AXIS_TUSER_WIDTH     (C_SLOT_2_AXIS_TUSER_WIDTH),  
    .C_SLOT_2_FIFO_ENABLE          (C_SLOT_2_FIFO_ENABLE),  
    .C_SLOT_3_AXI_ADDR_WIDTH       (C_SLOT_3_AXI_ADDR_WIDTH),  
    .C_SLOT_3_AXI_DATA_WIDTH       (C_SLOT_3_AXI_DATA_WIDTH),  
    .C_SLOT_3_AXI_ID_WIDTH         (C_SLOT_3_AXI_ID_WIDTH),  
    .C_SLOT_3_AXI_PROTOCOL         (SLOT_3_AXI_PROTOCOL),  
    .C_SLOT_3_AXI_SUB_PROTOCOL     (SLOT_3_AXI_SUB_PROTOCOL),  
    .C_SLOT_3_AXIS_TDATA_WIDTH     (C_SLOT_3_AXIS_TDATA_WIDTH),  
    .C_SLOT_3_AXIS_TID_WIDTH       (C_SLOT_3_AXIS_TID_WIDTH),  
    .C_SLOT_3_AXIS_TDEST_WIDTH     (C_SLOT_3_AXIS_TDEST_WIDTH),  
    .C_SLOT_3_AXIS_TUSER_WIDTH     (C_SLOT_3_AXIS_TUSER_WIDTH),  
    .C_SLOT_3_FIFO_ENABLE          (C_SLOT_3_FIFO_ENABLE),  
    .C_SLOT_4_AXI_ADDR_WIDTH       (C_SLOT_4_AXI_ADDR_WIDTH),  
    .C_SLOT_4_AXI_DATA_WIDTH       (C_SLOT_4_AXI_DATA_WIDTH),  
    .C_SLOT_4_AXI_ID_WIDTH         (C_SLOT_4_AXI_ID_WIDTH),  
    .C_SLOT_4_AXI_PROTOCOL         (SLOT_4_AXI_PROTOCOL),  
    .C_SLOT_4_AXI_SUB_PROTOCOL     (SLOT_4_AXI_SUB_PROTOCOL),  
    .C_SLOT_4_AXIS_TDATA_WIDTH     (C_SLOT_4_AXIS_TDATA_WIDTH), 
    .C_SLOT_4_AXIS_TID_WIDTH       (C_SLOT_4_AXIS_TID_WIDTH), 
    .C_SLOT_4_AXIS_TDEST_WIDTH     (C_SLOT_4_AXIS_TDEST_WIDTH), 
    .C_SLOT_4_AXIS_TUSER_WIDTH     (C_SLOT_4_AXIS_TUSER_WIDTH), 
    .C_SLOT_4_FIFO_ENABLE          (C_SLOT_4_FIFO_ENABLE), 
    .C_SLOT_5_AXI_ADDR_WIDTH       (C_SLOT_5_AXI_ADDR_WIDTH), 
    .C_SLOT_5_AXI_DATA_WIDTH       (C_SLOT_5_AXI_DATA_WIDTH), 
    .C_SLOT_5_AXI_ID_WIDTH         (C_SLOT_5_AXI_ID_WIDTH), 
    .C_SLOT_5_AXI_PROTOCOL         (SLOT_5_AXI_PROTOCOL), 
    .C_SLOT_5_AXI_SUB_PROTOCOL     (SLOT_5_AXI_SUB_PROTOCOL),  
    .C_SLOT_5_AXIS_TDATA_WIDTH     (C_SLOT_5_AXIS_TDATA_WIDTH), 
    .C_SLOT_5_AXIS_TID_WIDTH       (C_SLOT_5_AXIS_TID_WIDTH),
    .C_SLOT_5_AXIS_TDEST_WIDTH     (C_SLOT_5_AXIS_TDEST_WIDTH),
    .C_SLOT_5_AXIS_TUSER_WIDTH     (C_SLOT_5_AXIS_TUSER_WIDTH),
    .C_SLOT_5_FIFO_ENABLE          (C_SLOT_5_FIFO_ENABLE),
    .C_SLOT_6_AXI_ADDR_WIDTH       (C_SLOT_6_AXI_ADDR_WIDTH),
    .C_SLOT_6_AXI_DATA_WIDTH       (C_SLOT_6_AXI_DATA_WIDTH),
    .C_SLOT_6_AXI_ID_WIDTH         (C_SLOT_6_AXI_ID_WIDTH),
    .C_SLOT_6_AXI_PROTOCOL         (SLOT_6_AXI_PROTOCOL),
    .C_SLOT_6_AXI_SUB_PROTOCOL     (SLOT_6_AXI_SUB_PROTOCOL),  
    .C_SLOT_6_AXIS_TDATA_WIDTH     (C_SLOT_6_AXIS_TDATA_WIDTH),
    .C_SLOT_6_AXIS_TID_WIDTH       (C_SLOT_6_AXIS_TID_WIDTH),
    .C_SLOT_6_AXIS_TDEST_WIDTH     (C_SLOT_6_AXIS_TDEST_WIDTH),
    .C_SLOT_6_AXIS_TUSER_WIDTH     (C_SLOT_6_AXIS_TUSER_WIDTH),
    .C_SLOT_6_FIFO_ENABLE          (C_SLOT_6_FIFO_ENABLE),
    .C_SLOT_7_AXI_ADDR_WIDTH       (C_SLOT_7_AXI_ADDR_WIDTH),
    .C_SLOT_7_AXI_DATA_WIDTH       (C_SLOT_7_AXI_DATA_WIDTH),
    .C_SLOT_7_AXI_ID_WIDTH         (C_SLOT_7_AXI_ID_WIDTH),
    .C_SLOT_7_AXI_PROTOCOL         (SLOT_7_AXI_PROTOCOL),
    .C_SLOT_7_AXI_SUB_PROTOCOL     (SLOT_7_AXI_SUB_PROTOCOL),  
    .C_SLOT_7_AXIS_TDATA_WIDTH     (C_SLOT_7_AXIS_TDATA_WIDTH),
    .C_SLOT_7_AXIS_TID_WIDTH       (C_SLOT_7_AXIS_TID_WIDTH),
    .C_SLOT_7_AXIS_TDEST_WIDTH     (C_SLOT_7_AXIS_TDEST_WIDTH),
    .C_SLOT_7_AXIS_TUSER_WIDTH     (C_SLOT_7_AXIS_TUSER_WIDTH),
    .C_SLOT_7_FIFO_ENABLE          (C_SLOT_7_FIFO_ENABLE),
    .C_REG_ALL_MONITOR_SIGNALS     (C_REG_ALL_MONITOR_SIGNALS),
    .C_EXT_EVENT0_FIFO_ENABLE      (C_EXT_EVENT0_FIFO_ENABLE),
    .C_EXT_EVENT1_FIFO_ENABLE      (C_EXT_EVENT1_FIFO_ENABLE),
    .C_EXT_EVENT2_FIFO_ENABLE      (C_EXT_EVENT2_FIFO_ENABLE),
    .C_EXT_EVENT3_FIFO_ENABLE      (C_EXT_EVENT3_FIFO_ENABLE),
    .C_EXT_EVENT4_FIFO_ENABLE      (C_EXT_EVENT4_FIFO_ENABLE),
    .C_EXT_EVENT5_FIFO_ENABLE      (C_EXT_EVENT5_FIFO_ENABLE),
    .C_EXT_EVENT6_FIFO_ENABLE      (C_EXT_EVENT6_FIFO_ENABLE),
    .C_EXT_EVENT7_FIFO_ENABLE      (C_EXT_EVENT7_FIFO_ENABLE),
    .C_ENABLE_EVENT_LOG            (C_ENABLE_EVENT_LOG), 
    .C_FIFO_AXIS_DEPTH             (C_FIFO_AXIS_DEPTH), 
    .C_FIFO_AXIS_TDATA_WIDTH       (C_FIFO_AXIS_TDATA_WIDTH), 
    .C_AXIS_DWIDTH_ROUND_TO_32     (C_AXIS_DWIDTH_ROUND_TO_32),
    .C_FIFO_AXIS_TID_WIDTH         (C_FIFO_AXIS_TID_WIDTH), 
    .C_FIFO_AXIS_SYNC              (C_FIFO_AXIS_SYNC), 
    .C_SHOW_AXI_IDS                (C_SHOW_AXI_IDS),
    .C_SHOW_AXI_LEN                (C_SHOW_AXI_LEN),
    .C_SHOW_AXIS_TID               (C_SHOW_AXIS_TID),
    .C_SHOW_AXIS_TDEST             (C_SHOW_AXIS_TDEST),
    .C_SHOW_AXIS_TUSER             (C_SHOW_AXIS_TUSER),
    .COUNTER_LOAD_VALUE            (COUNTER_LOAD_VALUE), 
    .C_LOG_DATA_OFFLD              (C_LOG_DATA_OFFLD)  ,
    .S_AXI_OFFLD_ID_WIDTH          (S_AXI_OFFLD_ID_WIDTH),
    .C_EN_TRIGGER                  (C_EN_TRIGGER), 
    .C_EN_AXI_DEBUG                (C_EN_AXI_DEBUG) 
        ) adavnced_mode_inst
    (
      .s_axi_aclk        (s_axi_aclk),
      .s_axi_aresetn     (s_axi_aresetn),
      .s_axi_awaddr      (s_axi_awaddr_int),
      .s_axi_awvalid     (s_axi_awvalid),
      .s_axi_awid        (s_axi_awid),           
      .s_axi_awready     (s_axi_awready),
      .s_axi_wdata       (s_axi_wdata),
      .s_axi_wstrb       (s_axi_wstrb),
      .s_axi_wvalid      (s_axi_wvalid),
      .s_axi_wready      (s_axi_wready),
      .s_axi_bresp       (s_axi_bresp),
      .s_axi_bvalid      (s_axi_bvalid),
      .s_axi_bid         (s_axi_bid),      
      .s_axi_bready      (s_axi_bready),
      .s_axi_araddr      (s_axi_araddr_int),
      .s_axi_arvalid     (s_axi_arvalid),
      .s_axi_arid        (s_axi_arid),     
      .s_axi_arready     (s_axi_arready),
      .s_axi_rdata       (s_axi_rdata),
      .s_axi_rresp       (s_axi_rresp),
      .s_axi_rvalid      (s_axi_rvalid),
      .s_axi_rid         (s_axi_rid),     
      .s_axi_rready      (s_axi_rready),
      .slot_0_axi_aclk   (slot_0_axi_aclk) ,
      .slot_0_axi_aresetn (slot_0_axi_aresetn),
      .slot_0_axi_awid    (slot_0_axi_awid),
      .slot_0_axi_awaddr  (slot_0_axi_awaddr),
      .slot_0_axi_awprot  (slot_0_axi_awprot),
      .slot_0_axi_awlen   (slot_0_axi_awlen_i),
      .slot_0_axi_awsize  (slot_0_axi_awsize),
      .slot_0_axi_awburst (slot_0_axi_awburst),
      .slot_0_axi_awcache (slot_0_axi_awcache),
      .slot_0_axi_awlock  (slot_0_axi_awlock[0:0]),
      .slot_0_axi_awvalid (slot_0_axi_awvalid),
      .slot_0_axi_awready (slot_0_axi_awready),
      .slot_0_axi_wdata   (slot_0_axi_wdata),
      .slot_0_axi_wstrb   (slot_0_axi_wstrb),
      .slot_0_axi_wlast   (slot_0_axi_wlast_i),
      .slot_0_axi_wvalid  (slot_0_axi_wvalid),
      .slot_0_axi_wready  (slot_0_axi_wready),
      .slot_0_axi_bid     (slot_0_axi_bid),
      .slot_0_axi_bresp   (slot_0_axi_bresp),
      .slot_0_axi_bvalid  (slot_0_axi_bvalid),
      .slot_0_axi_bready  (slot_0_axi_bready),
      .slot_0_axi_arid    (slot_0_axi_arid),
      .slot_0_axi_araddr  (slot_0_axi_araddr),
      .slot_0_axi_arlen   (slot_0_axi_arlen_i),
      .slot_0_axi_arsize  (slot_0_axi_arsize),
      .slot_0_axi_arburst (slot_0_axi_arburst),
      .slot_0_axi_arcache (slot_0_axi_arcache),
      .slot_0_axi_arprot  (slot_0_axi_arprot),
      .slot_0_axi_arlock  (slot_0_axi_arlock[0:0]),
      .slot_0_axi_arvalid (slot_0_axi_arvalid),
      .slot_0_axi_arready (slot_0_axi_arready),
      .slot_0_axi_rid     (slot_0_axi_rid),
      .slot_0_axi_rdata   (slot_0_axi_rdata),
      .slot_0_axi_rresp   (slot_0_axi_rresp),
      .slot_0_axi_rlast   (slot_0_axi_rlast_i),
      .slot_0_axi_rvalid  (slot_0_axi_rvalid),
      .slot_0_axi_rready  (slot_0_axi_rready),
      .slot_0_axis_aclk   (slot_0_axis_aclk),
      .slot_0_axis_aresetn(slot_0_axis_aresetn),
      .slot_0_axis_tvalid (slot_0_axis_tvalid),
      .slot_0_axis_tready (slot_0_axis_tready),
      .slot_0_axis_tdata  (slot_0_axis_tdata),
      .slot_0_axis_tstrb  (slot_0_axis_tstrb),
      .slot_0_axis_tkeep  (slot_0_axis_tkeep),
      .slot_0_axis_tlast  (slot_0_axis_tlast),
      .slot_0_axis_tid    (slot_0_axis_tid),
      .slot_0_axis_tdest  (slot_0_axis_tdest),
      .slot_0_axis_tuser  (slot_0_axis_tuser),
      .slot_0_ext_trig    (slot_0_ext_trig),
      .slot_0_ext_trig_stop (slot_0_ext_trig_stop),
      .slot_1_axi_aclk      (slot_1_axi_aclk),
      .slot_1_axi_aresetn   (slot_1_axi_aresetn),
      .slot_1_axi_awid      (slot_1_axi_awid),
      .slot_1_axi_awaddr    (slot_1_axi_awaddr),
      .slot_1_axi_awprot    (slot_1_axi_awprot),
      .slot_1_axi_awlen     (slot_1_axi_awlen_i),
      .slot_1_axi_awsize    (slot_1_axi_awsize),
      .slot_1_axi_awburst   (slot_1_axi_awburst),
      .slot_1_axi_awcache   (slot_1_axi_awcache),
      .slot_1_axi_awlock    (slot_1_axi_awlock[0:0]),
      .slot_1_axi_awvalid   (slot_1_axi_awvalid),
      .slot_1_axi_awready   (slot_1_axi_awready),
      .slot_1_axi_wdata     (slot_1_axi_wdata),
      .slot_1_axi_wstrb     (slot_1_axi_wstrb),
      .slot_1_axi_wlast     (slot_1_axi_wlast_i),
      .slot_1_axi_wvalid    (slot_1_axi_wvalid),
      .slot_1_axi_wready    (slot_1_axi_wready),
      .slot_1_axi_bid       (slot_1_axi_bid),
      .slot_1_axi_bresp     (slot_1_axi_bresp),
      .slot_1_axi_bvalid    (slot_1_axi_bvalid),
      .slot_1_axi_bready    (slot_1_axi_bready),
      .slot_1_axi_arid      (slot_1_axi_arid),
      .slot_1_axi_araddr    (slot_1_axi_araddr),
      .slot_1_axi_arlen     (slot_1_axi_arlen_i),
      .slot_1_axi_arsize    (slot_1_axi_arsize),
      .slot_1_axi_arburst   (slot_1_axi_arburst),
      .slot_1_axi_arcache   (slot_1_axi_arcache),
      .slot_1_axi_arprot    (slot_1_axi_arprot),
      .slot_1_axi_arlock    (slot_1_axi_arlock[0:0]),
      .slot_1_axi_arvalid   (slot_1_axi_arvalid),
      .slot_1_axi_arready   (slot_1_axi_arready),
      .slot_1_axi_rid       (slot_1_axi_rid),
      .slot_1_axi_rdata     (slot_1_axi_rdata),
      .slot_1_axi_rresp     (slot_1_axi_rresp),
      .slot_1_axi_rlast     (slot_1_axi_rlast_i),
      .slot_1_axi_rvalid    (slot_1_axi_rvalid),
      .slot_1_axi_rready    (slot_1_axi_rready),
      .slot_1_axis_aclk     (slot_1_axis_aclk),
      .slot_1_axis_aresetn  (slot_1_axis_aresetn),
      .slot_1_axis_tvalid   (slot_1_axis_tvalid),
      .slot_1_axis_tready   (slot_1_axis_tready),
      .slot_1_axis_tdata    (slot_1_axis_tdata),
      .slot_1_axis_tstrb    (slot_1_axis_tstrb),
      .slot_1_axis_tkeep    (slot_1_axis_tkeep),
      .slot_1_axis_tlast    (slot_1_axis_tlast),
      .slot_1_axis_tid      (slot_1_axis_tid),
      .slot_1_axis_tdest    (slot_1_axis_tdest),
      .slot_1_axis_tuser    (slot_1_axis_tuser),
      .slot_1_ext_trig      (slot_1_ext_trig),
      .slot_1_ext_trig_stop (slot_1_ext_trig_stop),
      .slot_2_axi_aclk      (slot_2_axi_aclk),
      .slot_2_axi_aresetn   (slot_2_axi_aresetn),
      .slot_2_axi_awid      (slot_2_axi_awid),
      .slot_2_axi_awaddr    (slot_2_axi_awaddr),
      .slot_2_axi_awprot    (slot_2_axi_awprot),
      .slot_2_axi_awlen     (slot_2_axi_awlen_i),
      .slot_2_axi_awsize    (slot_2_axi_awsize),
      .slot_2_axi_awburst   (slot_2_axi_awburst),
      .slot_2_axi_awcache   (slot_2_axi_awcache),
      .slot_2_axi_awlock    (slot_2_axi_awlock[0:0]),
      .slot_2_axi_awvalid   (slot_2_axi_awvalid),
      .slot_2_axi_awready   (slot_2_axi_awready),
      .slot_2_axi_wdata     (slot_2_axi_wdata),
      .slot_2_axi_wstrb     (slot_2_axi_wstrb),
      .slot_2_axi_wlast     (slot_2_axi_wlast_i),
      .slot_2_axi_wvalid    (slot_2_axi_wvalid),
      .slot_2_axi_wready    (slot_2_axi_wready),
      .slot_2_axi_bid       (slot_2_axi_bid),
      .slot_2_axi_bresp     (slot_2_axi_bresp),
      .slot_2_axi_bvalid    (slot_2_axi_bvalid),
      .slot_2_axi_bready    (slot_2_axi_bready),
      .slot_2_axi_arid      (slot_2_axi_arid),
      .slot_2_axi_araddr    (slot_2_axi_araddr),
      .slot_2_axi_arlen     (slot_2_axi_arlen_i),
      .slot_2_axi_arsize    (slot_2_axi_arsize),
      .slot_2_axi_arburst   (slot_2_axi_arburst),
      .slot_2_axi_arcache   (slot_2_axi_arcache),
      .slot_2_axi_arprot    (slot_2_axi_arprot),
      .slot_2_axi_arlock    (slot_2_axi_arlock[0:0]),
      .slot_2_axi_arvalid   (slot_2_axi_arvalid),
      .slot_2_axi_arready   (slot_2_axi_arready),
      .slot_2_axi_rid       (slot_2_axi_rid),
      .slot_2_axi_rdata     (slot_2_axi_rdata),
      .slot_2_axi_rresp     (slot_2_axi_rresp),
      .slot_2_axi_rlast     (slot_2_axi_rlast_i),
      .slot_2_axi_rvalid    (slot_2_axi_rvalid),
      .slot_2_axi_rready    (slot_2_axi_rready),
      .slot_2_axis_aclk     (slot_2_axis_aclk),
      .slot_2_axis_aresetn  (slot_2_axis_aresetn),
      .slot_2_axis_tvalid   (slot_2_axis_tvalid),
      .slot_2_axis_tready   (slot_2_axis_tready),
      .slot_2_axis_tdata    (slot_2_axis_tdata),
      .slot_2_axis_tstrb    (slot_2_axis_tstrb),
      .slot_2_axis_tkeep    (slot_2_axis_tkeep),
      .slot_2_axis_tlast    (slot_2_axis_tlast),
      .slot_2_axis_tid      (slot_2_axis_tid),
      .slot_2_axis_tdest    (slot_2_axis_tdest),
      .slot_2_axis_tuser    (slot_2_axis_tuser),
      .slot_2_ext_trig      (slot_2_ext_trig),
      .slot_2_ext_trig_stop (slot_2_ext_trig_stop),
      .slot_3_axi_aclk      (slot_3_axi_aclk),
      .slot_3_axi_aresetn   (slot_3_axi_aresetn),
      .slot_3_axi_awid      (slot_3_axi_awid),
      .slot_3_axi_awaddr    (slot_3_axi_awaddr),
      .slot_3_axi_awprot    (slot_3_axi_awprot),
      .slot_3_axi_awlen     (slot_3_axi_awlen_i),
      .slot_3_axi_awsize    (slot_3_axi_awsize),
      .slot_3_axi_awburst   (slot_3_axi_awburst),
      .slot_3_axi_awcache   (slot_3_axi_awcache),
      .slot_3_axi_awlock    (slot_3_axi_awlock[0:0]),
      .slot_3_axi_awvalid   (slot_3_axi_awvalid),
      .slot_3_axi_awready   (slot_3_axi_awready),
      .slot_3_axi_wdata     (slot_3_axi_wdata),  
      .slot_3_axi_wstrb     (slot_3_axi_wstrb),
      .slot_3_axi_wlast     (slot_3_axi_wlast_i),
      .slot_3_axi_wvalid    (slot_3_axi_wvalid),
      .slot_3_axi_wready    (slot_3_axi_wready),
      .slot_3_axi_bid       (slot_3_axi_bid), 
      .slot_3_axi_bresp     (slot_3_axi_bresp),
      .slot_3_axi_bvalid    (slot_3_axi_bvalid), 
      .slot_3_axi_bready    (slot_3_axi_bready), 
      .slot_3_axi_arid      (slot_3_axi_arid),
      .slot_3_axi_araddr    (slot_3_axi_araddr),
      .slot_3_axi_arlen     (slot_3_axi_arlen_i), 
      .slot_3_axi_arsize    (slot_3_axi_arsize),
      .slot_3_axi_arburst   (slot_3_axi_arburst),
      .slot_3_axi_arcache   (slot_3_axi_arcache), 
      .slot_3_axi_arprot    (slot_3_axi_arprot),
      .slot_3_axi_arlock    (slot_3_axi_arlock[0:0]),
      .slot_3_axi_arvalid   (slot_3_axi_arvalid),
      .slot_3_axi_arready   (slot_3_axi_arready),
      .slot_3_axi_rid       (slot_3_axi_rid),
      .slot_3_axi_rdata     (slot_3_axi_rdata),
      .slot_3_axi_rresp     (slot_3_axi_rresp),
      .slot_3_axi_rlast     (slot_3_axi_rlast_i),
      .slot_3_axi_rvalid    (slot_3_axi_rvalid),
      .slot_3_axi_rready    (slot_3_axi_rready),
      .slot_3_axis_aclk     (slot_3_axis_aclk),
      .slot_3_axis_aresetn  (slot_3_axis_aresetn),
      .slot_3_axis_tvalid   (slot_3_axis_tvalid),
      .slot_3_axis_tready   (slot_3_axis_tready),
      .slot_3_axis_tdata    (slot_3_axis_tdata),
      .slot_3_axis_tstrb    (slot_3_axis_tstrb),
      .slot_3_axis_tkeep    (slot_3_axis_tkeep),
      .slot_3_axis_tlast    (slot_3_axis_tlast),
      .slot_3_axis_tid      (slot_3_axis_tid),
      .slot_3_axis_tdest    (slot_3_axis_tdest),
      .slot_3_axis_tuser    (slot_3_axis_tuser),
      .slot_3_ext_trig      (slot_3_ext_trig),
      .slot_3_ext_trig_stop (slot_3_ext_trig_stop),
      .slot_4_axi_aclk      (slot_4_axi_aclk),
      .slot_4_axi_aresetn   (slot_4_axi_aresetn),
      .slot_4_axi_awid      (slot_4_axi_awid),
      .slot_4_axi_awaddr    (slot_4_axi_awaddr),
      .slot_4_axi_awprot    (slot_4_axi_awprot),
      .slot_4_axi_awlen     (slot_4_axi_awlen_i),
      .slot_4_axi_awsize    (slot_4_axi_awsize),
      .slot_4_axi_awburst   (slot_4_axi_awburst),
      .slot_4_axi_awcache   (slot_4_axi_awcache),
      .slot_4_axi_awlock    (slot_4_axi_awlock[0:0]),
      .slot_4_axi_awvalid   (slot_4_axi_awvalid),
      .slot_4_axi_awready   (slot_4_axi_awready),
      .slot_4_axi_wdata     (slot_4_axi_wdata),
      .slot_4_axi_wstrb     (slot_4_axi_wstrb),
      .slot_4_axi_wlast     (slot_4_axi_wlast_i),
      .slot_4_axi_wvalid    (slot_4_axi_wvalid),
      .slot_4_axi_wready    (slot_4_axi_wready),
      .slot_4_axi_bid       (slot_4_axi_bid),
      .slot_4_axi_bresp     (slot_4_axi_bresp),
      .slot_4_axi_bvalid    (slot_4_axi_bvalid),
      .slot_4_axi_bready    (slot_4_axi_bready),
      .slot_4_axi_arid      (slot_4_axi_arid),
      .slot_4_axi_araddr    (slot_4_axi_araddr),
      .slot_4_axi_arlen     (slot_4_axi_arlen_i),
      .slot_4_axi_arsize    (slot_4_axi_arsize),
      .slot_4_axi_arburst   (slot_4_axi_arburst),
      .slot_4_axi_arcache   (slot_4_axi_arcache),
      .slot_4_axi_arprot    (slot_4_axi_arprot),
      .slot_4_axi_arlock    (slot_4_axi_arlock[0:0]),
      .slot_4_axi_arvalid   (slot_4_axi_arvalid),
      .slot_4_axi_arready   (slot_4_axi_arready),
      .slot_4_axi_rid       (slot_4_axi_rid),
      .slot_4_axi_rdata     (slot_4_axi_rdata),
      .slot_4_axi_rresp     (slot_4_axi_rresp),
      .slot_4_axi_rlast     (slot_4_axi_rlast_i),
      .slot_4_axi_rvalid    (slot_4_axi_rvalid),
      .slot_4_axi_rready    (slot_4_axi_rready),
      .slot_4_axis_aclk     (slot_4_axis_aclk),
      .slot_4_axis_aresetn  (slot_4_axis_aresetn),
      .slot_4_axis_tvalid   (slot_4_axis_tvalid),
      .slot_4_axis_tready   (slot_4_axis_tready),
      .slot_4_axis_tdata    (slot_4_axis_tdata),
      .slot_4_axis_tstrb    (slot_4_axis_tstrb),
      .slot_4_axis_tkeep    (slot_4_axis_tkeep),
      .slot_4_axis_tlast    (slot_4_axis_tlast),
      .slot_4_axis_tid      (slot_4_axis_tid),
      .slot_4_axis_tdest    (slot_4_axis_tdest),
      .slot_4_axis_tuser    (slot_4_axis_tuser),
      .slot_4_ext_trig      (slot_4_ext_trig),
      .slot_4_ext_trig_stop (slot_4_ext_trig_stop),
      .slot_5_axi_aclk      (slot_5_axi_aclk),
      .slot_5_axi_aresetn   (slot_5_axi_aresetn),
      .slot_5_axi_awid      (slot_5_axi_awid),
      .slot_5_axi_awaddr    (slot_5_axi_awaddr),
      .slot_5_axi_awprot    (slot_5_axi_awprot),
      .slot_5_axi_awlen     (slot_5_axi_awlen_i),
      .slot_5_axi_awsize    (slot_5_axi_awsize),
      .slot_5_axi_awburst   (slot_5_axi_awburst),
      .slot_5_axi_awcache   (slot_5_axi_awcache),
      .slot_5_axi_awlock    (slot_5_axi_awlock[0:0]),
      .slot_5_axi_awvalid   (slot_5_axi_awvalid),
      .slot_5_axi_awready   (slot_5_axi_awready),
      .slot_5_axi_wdata     (slot_5_axi_wdata),
      .slot_5_axi_wstrb     (slot_5_axi_wstrb),
      .slot_5_axi_wlast     (slot_5_axi_wlast_i),
      .slot_5_axi_wvalid    (slot_5_axi_wvalid),
      .slot_5_axi_wready    (slot_5_axi_wready),
      .slot_5_axi_bid       (slot_5_axi_bid),
      .slot_5_axi_bresp     (slot_5_axi_bresp),
      .slot_5_axi_bvalid    (slot_5_axi_bvalid),
      .slot_5_axi_bready    (slot_5_axi_bready),
      .slot_5_axi_arid      (slot_5_axi_arid),
      .slot_5_axi_araddr    (slot_5_axi_araddr),
      .slot_5_axi_arlen     (slot_5_axi_arlen_i),
      .slot_5_axi_arsize    (slot_5_axi_arsize),
      .slot_5_axi_arburst   (slot_5_axi_arburst),
      .slot_5_axi_arcache   (slot_5_axi_arcache),
      .slot_5_axi_arprot    (slot_5_axi_arprot),
      .slot_5_axi_arlock    (slot_5_axi_arlock[0:0]),
      .slot_5_axi_arvalid   (slot_5_axi_arvalid),
      .slot_5_axi_arready   (slot_5_axi_arready),
      .slot_5_axi_rid       (slot_5_axi_rid),
      .slot_5_axi_rdata     (slot_5_axi_rdata),
      .slot_5_axi_rresp     (slot_5_axi_rresp),
      .slot_5_axi_rlast     (slot_5_axi_rlast_i),
      .slot_5_axi_rvalid    (slot_5_axi_rvalid),
      .slot_5_axi_rready    (slot_5_axi_rready),
      .slot_5_axis_aclk     (slot_5_axis_aclk),
      .slot_5_axis_aresetn  (slot_5_axis_aresetn),
      .slot_5_axis_tvalid   (slot_5_axis_tvalid),
      .slot_5_axis_tready   (slot_5_axis_tready),
      .slot_5_axis_tdata    (slot_5_axis_tdata),
      .slot_5_axis_tstrb    (slot_5_axis_tstrb),
      .slot_5_axis_tkeep    (slot_5_axis_tkeep),
      .slot_5_axis_tlast    (slot_5_axis_tlast),
      .slot_5_axis_tid      (slot_5_axis_tid),
      .slot_5_axis_tdest    (slot_5_axis_tdest),
      .slot_5_axis_tuser    (slot_5_axis_tuser),
      .slot_5_ext_trig      (slot_5_ext_trig),
      .slot_5_ext_trig_stop (slot_5_ext_trig_stop),
      .slot_6_axi_aclk      (slot_6_axi_aclk),
      .slot_6_axi_aresetn   (slot_6_axi_aresetn),
      .slot_6_axi_awid      (slot_6_axi_awid),
      .slot_6_axi_awaddr    (slot_6_axi_awaddr),
      .slot_6_axi_awprot    (slot_6_axi_awprot),
      .slot_6_axi_awlen     (slot_6_axi_awlen_i),
      .slot_6_axi_awsize    (slot_6_axi_awsize),
      .slot_6_axi_awburst   (slot_6_axi_awburst),
      .slot_6_axi_awcache   (slot_6_axi_awcache),
      .slot_6_axi_awlock    (slot_6_axi_awlock[0:0]),
      .slot_6_axi_awvalid   (slot_6_axi_awvalid),
      .slot_6_axi_awready   (slot_6_axi_awready),
      .slot_6_axi_wdata     (slot_6_axi_wdata),
      .slot_6_axi_wstrb     (slot_6_axi_wstrb),
      .slot_6_axi_wlast     (slot_6_axi_wlast_i),
      .slot_6_axi_wvalid    (slot_6_axi_wvalid),
      .slot_6_axi_wready    (slot_6_axi_wready),
      .slot_6_axi_bid       (slot_6_axi_bid),
      .slot_6_axi_bresp     (slot_6_axi_bresp),
      .slot_6_axi_bvalid    (slot_6_axi_bvalid),
      .slot_6_axi_bready    (slot_6_axi_bready),
      .slot_6_axi_arid      (slot_6_axi_arid),
      .slot_6_axi_araddr    (slot_6_axi_araddr),
      .slot_6_axi_arlen     (slot_6_axi_arlen_i),
      .slot_6_axi_arsize    (slot_6_axi_arsize),
      .slot_6_axi_arburst   (slot_6_axi_arburst),
      .slot_6_axi_arcache   (slot_6_axi_arcache),
      .slot_6_axi_arprot    (slot_6_axi_arprot),
      .slot_6_axi_arlock    (slot_6_axi_arlock[0:0]),
      .slot_6_axi_arvalid   (slot_6_axi_arvalid),
      .slot_6_axi_arready   (slot_6_axi_arready),
      .slot_6_axi_rid       (slot_6_axi_rid),
      .slot_6_axi_rdata     (slot_6_axi_rdata),
      .slot_6_axi_rresp     (slot_6_axi_rresp),
      .slot_6_axi_rlast     (slot_6_axi_rlast_i),
      .slot_6_axi_rvalid    (slot_6_axi_rvalid),
      .slot_6_axi_rready    (slot_6_axi_rready),
      .slot_6_axis_aclk     (slot_6_axis_aclk),
      .slot_6_axis_aresetn  (slot_6_axis_aresetn),
      .slot_6_axis_tvalid   (slot_6_axis_tvalid),
      .slot_6_axis_tready   (slot_6_axis_tready),
      .slot_6_axis_tdata    (slot_6_axis_tdata),
      .slot_6_axis_tstrb    (slot_6_axis_tstrb),
      .slot_6_axis_tkeep    (slot_6_axis_tkeep),
      .slot_6_axis_tlast    (slot_6_axis_tlast),
      .slot_6_axis_tid      (slot_6_axis_tid),
      .slot_6_axis_tdest    (slot_6_axis_tdest),
      .slot_6_axis_tuser    (slot_6_axis_tuser),
      .slot_6_ext_trig      (slot_6_ext_trig),
      .slot_6_ext_trig_stop (slot_6_ext_trig_stop),
      .slot_7_axi_aclk      (slot_7_axi_aclk),
      .slot_7_axi_aresetn   (slot_7_axi_aresetn),
      .slot_7_axi_awid      (slot_7_axi_awid),
      .slot_7_axi_awaddr    (slot_7_axi_awaddr),
      .slot_7_axi_awprot    (slot_7_axi_awprot),
      .slot_7_axi_awlen     (slot_7_axi_awlen_i),
      .slot_7_axi_awsize    (slot_7_axi_awsize),
      .slot_7_axi_awburst   (slot_7_axi_awburst),
      .slot_7_axi_awcache   (slot_7_axi_awcache),
      .slot_7_axi_awlock    (slot_7_axi_awlock[0:0]),
      .slot_7_axi_awvalid   (slot_7_axi_awvalid),
      .slot_7_axi_awready   (slot_7_axi_awready),
      .slot_7_axi_wdata     (slot_7_axi_wdata),
      .slot_7_axi_wstrb     (slot_7_axi_wstrb),
      .slot_7_axi_wlast     (slot_7_axi_wlast_i),
      .slot_7_axi_wvalid    (slot_7_axi_wvalid),
      .slot_7_axi_wready    (slot_7_axi_wready),
      .slot_7_axi_bid       (slot_7_axi_bid),
      .slot_7_axi_bresp     (slot_7_axi_bresp),
      .slot_7_axi_bvalid    (slot_7_axi_bvalid),
      .slot_7_axi_bready    (slot_7_axi_bready),
      .slot_7_axi_arid      (slot_7_axi_arid),
      .slot_7_axi_araddr    (slot_7_axi_araddr),
      .slot_7_axi_arlen     (slot_7_axi_arlen_i),
      .slot_7_axi_arsize    (slot_7_axi_arsize),
      .slot_7_axi_arburst   (slot_7_axi_arburst),
      .slot_7_axi_arcache   (slot_7_axi_arcache),
      .slot_7_axi_arprot    (slot_7_axi_arprot),
      .slot_7_axi_arlock    (slot_7_axi_arlock[0:0]),
      .slot_7_axi_arvalid   (slot_7_axi_arvalid),
      .slot_7_axi_arready   (slot_7_axi_arready),
      .slot_7_axi_rid       (slot_7_axi_rid),
      .slot_7_axi_rdata     (slot_7_axi_rdata),
      .slot_7_axi_rresp     (slot_7_axi_rresp),
      .slot_7_axi_rlast     (slot_7_axi_rlast_i),
      .slot_7_axi_rvalid    (slot_7_axi_rvalid),
      .slot_7_axi_rready    (slot_7_axi_rready),
      .slot_7_axis_aclk     (slot_7_axis_aclk),
      .slot_7_axis_aresetn  (slot_7_axis_aresetn),
      .slot_7_axis_tvalid   (slot_7_axis_tvalid),
      .slot_7_axis_tready   (slot_7_axis_tready),
      .slot_7_axis_tdata    (slot_7_axis_tdata),
      .slot_7_axis_tstrb    (slot_7_axis_tstrb),
      .slot_7_axis_tkeep    (slot_7_axis_tkeep),
      .slot_7_axis_tlast    (slot_7_axis_tlast),
      .slot_7_axis_tid      (slot_7_axis_tid),
      .slot_7_axis_tdest    (slot_7_axis_tdest),
      .slot_7_axis_tuser    (slot_7_axis_tuser),
      .slot_7_ext_trig      (slot_7_ext_trig),
      .slot_7_ext_trig_stop (slot_7_ext_trig_stop),
      .ext_clk_0            (ext_clk_0),
      .ext_rstn_0           (ext_rstn_0),
      .ext_event_0_cnt_start(ext_event_0_cnt_start),
      .ext_event_0_cnt_stop (ext_event_0_cnt_stop),
      .ext_event_0          (ext_event_0),
      .ext_clk_1            (ext_clk_1),
      .ext_rstn_1           (ext_rstn_1),
      .ext_event_1_cnt_start(ext_event_1_cnt_start),
      .ext_event_1_cnt_stop (ext_event_1_cnt_stop),
      .ext_event_1          (ext_event_1),
      .ext_clk_2            (ext_clk_2),
      .ext_rstn_2           (ext_rstn_2),
      .ext_event_2_cnt_start(ext_event_2_cnt_start),
      .ext_event_2_cnt_stop (ext_event_2_cnt_stop),
      .ext_event_2          (ext_event_2),
      .ext_clk_3            (ext_clk_3),
      .ext_rstn_3           (ext_rstn_3),
      .ext_event_3_cnt_start(ext_event_3_cnt_start),
      .ext_event_3_cnt_stop (ext_event_3_cnt_stop),
      .ext_event_3          (ext_event_3),
      .ext_clk_4            (ext_clk_4),
      .ext_rstn_4           (ext_rstn_4),
      .ext_event_4_cnt_start(ext_event_4_cnt_start),
      .ext_event_4_cnt_stop (ext_event_4_cnt_stop),
      .ext_event_4          (ext_event_4),
      .ext_clk_5            (ext_clk_5),
      .ext_rstn_5           (ext_rstn_5),
      .ext_event_5_cnt_start(ext_event_5_cnt_start),
      .ext_event_5_cnt_stop (ext_event_5_cnt_stop),
      .ext_event_5          (ext_event_5),
      .ext_clk_6            (ext_clk_6),
      .ext_rstn_6           (ext_rstn_6),
      .ext_event_6_cnt_start(ext_event_6_cnt_start),
      .ext_event_6_cnt_stop (ext_event_6_cnt_stop),
      .ext_event_6          (ext_event_6),
      .ext_clk_7            (ext_clk_7),
      .ext_rstn_7           (ext_rstn_7),
      .ext_event_7_cnt_start(ext_event_7_cnt_start),
      .ext_event_7_cnt_stop (ext_event_7_cnt_stop),
      .ext_event_7          (ext_event_7),
      .capture_event        (capture_event_sync),
      .reset_event          (reset_event_sync),
      .core_aclk            (core_aclk),
      .core_aresetn         (core_aresetn),
      .m_axis_aclk          (m_axis_aclk),
      .m_axis_aresetn       (m_axis_aresetn),
      .m_axis_tdata         (m_axis_tdata),
      .m_axis_tstrb         (m_axis_tstrb),
      .m_axis_tvalid        (m_axis_tvalid),
      .m_axis_tid           (m_axis_tid),
      .m_axis_tready        (m_axis_tready),
      .s_axi_offld_aclk     (s_axi_offld_aclk    ),
      .s_axi_offld_aresetn  (s_axi_offld_aresetn ),
      .s_axi_offld_araddr   (s_axi_offld_araddr  ),
      .s_axi_offld_arvalid  (s_axi_offld_arvalid ),
      .s_axi_offld_arlen    (s_axi_offld_arlen   ),
      .s_axi_offld_arid     (s_axi_offld_arid    ),
      .s_axi_offld_arready  (s_axi_offld_arready ),
      .s_axi_offld_rready   (s_axi_offld_rready  ),
      .s_axi_offld_rdata    (s_axi_offld_rdata   ),
      .s_axi_offld_rresp    (s_axi_offld_rresp   ),
      .s_axi_offld_rvalid   (s_axi_offld_rvalid  ),
      .s_axi_offld_rid      (s_axi_offld_rid     ),
      .s_axi_offld_rlast    (s_axi_offld_rlast   ),
      .interrupt            (interrupt),
      .trigger_in           (trigger_in),
      .trigger_in_ack       (trigger_in_ack)
    );

  end

  else if( C_ENABLE_PROFILE == 1 || C_ENABLE_TRACE == 1) begin: GEN_PROFILE_Trace_Mode

   axi_perf_mon_v5_0_12_profile 
    # (
    .C_FAMILY                      (C_FAMILY), 
    .C_S_AXI_ADDR_WIDTH            (C_S_AXI_ADDR_WIDTH), 
    .C_S_AXI_DATA_WIDTH            (C_S_AXI_DATA_WIDTH), 
    .C_S_AXI_PROTOCOL              (C_S_AXI_PROTOCOL), 
    .C_S_AXI_ID_WIDTH              (C_S_AXI_ID_WIDTH), 
    .C_SUPPORT_ID_REFLECTION       (C_SUPPORT_ID_REFLECTION), 
    .C_ENABLE_PROFILE              (C_ENABLE_PROFILE), 
    .C_EN_AXI_DEBUG                (C_EN_AXI_DEBUG), 
    .C_EN_TRIGGER                  (C_EN_TRIGGER), 
    .C_NUM_MONITOR_SLOTS           (C_NUM_MONITOR_SLOTS), 
    .C_NUM_OF_COUNTERS             (C_NUM_MONITOR_SLOTS*6),  
    .C_NUM_OF_COUNTERS_EXTND       (C_NUM_MONITOR_SLOTS*2),  
    .C_METRIC_COUNT_WIDTH          (C_METRIC_COUNT_WIDTH),  
    .C_HAVE_SAMPLED_METRIC_CNT     (C_HAVE_SAMPLED_METRIC_CNT),  
    .C_METRICS_SAMPLE_COUNT_WIDTH  (C_METRICS_SAMPLE_COUNT_WIDTH),  
    .C_AXI4LITE_CORE_CLK_ASYNC     (C_AXI4LITE_CORE_CLK_ASYNC),  
    .C_SLOT_0_AXI_ADDR_WIDTH       (C_SLOT_0_AXI_ADDR_WIDTH),  
    .C_SLOT_0_AXI_DATA_WIDTH       (C_SLOT_0_AXI_DATA_WIDTH),  
    .C_SLOT_0_AXI_ID_WIDTH         (C_SLOT_0_AXI_ID_WIDTH),  
    .C_SLOT_0_AXI_PROTOCOL         (SLOT_0_AXI_PROTOCOL),  
    .C_SLOT_0_AXI_SUB_PROTOCOL     (SLOT_0_AXI_SUB_PROTOCOL),  
    .C_SLOT_0_FIFO_ENABLE          (C_SLOT_0_FIFO_ENABLE),  
    .C_SLOT_1_AXI_ADDR_WIDTH       (C_SLOT_1_AXI_ADDR_WIDTH),  
    .C_SLOT_1_AXI_DATA_WIDTH       (C_SLOT_1_AXI_DATA_WIDTH),  
    .C_SLOT_1_AXI_ID_WIDTH         (C_SLOT_1_AXI_ID_WIDTH),  
    .C_SLOT_1_AXI_PROTOCOL         (SLOT_1_AXI_PROTOCOL),  
    .C_SLOT_1_AXI_SUB_PROTOCOL     (SLOT_1_AXI_SUB_PROTOCOL),  
    .C_SLOT_1_FIFO_ENABLE          (C_SLOT_1_FIFO_ENABLE),  
    .C_SLOT_2_AXI_ADDR_WIDTH       (C_SLOT_2_AXI_ADDR_WIDTH),  
    .C_SLOT_2_AXI_DATA_WIDTH       (C_SLOT_2_AXI_DATA_WIDTH),  
    .C_SLOT_2_AXI_ID_WIDTH         (C_SLOT_2_AXI_ID_WIDTH),  
    .C_SLOT_2_AXI_PROTOCOL         (SLOT_2_AXI_PROTOCOL),  
    .C_SLOT_2_AXI_SUB_PROTOCOL     (SLOT_2_AXI_SUB_PROTOCOL),  
    .C_SLOT_2_FIFO_ENABLE          (C_SLOT_2_FIFO_ENABLE),  
    .C_SLOT_3_AXI_ADDR_WIDTH       (C_SLOT_3_AXI_ADDR_WIDTH),  
    .C_SLOT_3_AXI_DATA_WIDTH       (C_SLOT_3_AXI_DATA_WIDTH),  
    .C_SLOT_3_AXI_ID_WIDTH         (C_SLOT_3_AXI_ID_WIDTH),  
    .C_SLOT_3_AXI_PROTOCOL         (SLOT_3_AXI_PROTOCOL),  
    .C_SLOT_3_AXI_SUB_PROTOCOL     (SLOT_3_AXI_SUB_PROTOCOL),  
    .C_SLOT_3_FIFO_ENABLE          (C_SLOT_3_FIFO_ENABLE),  
    .C_SLOT_4_AXI_ADDR_WIDTH       (C_SLOT_4_AXI_ADDR_WIDTH),  
    .C_SLOT_4_AXI_DATA_WIDTH       (C_SLOT_4_AXI_DATA_WIDTH),  
    .C_SLOT_4_AXI_ID_WIDTH         (C_SLOT_4_AXI_ID_WIDTH),  
    .C_SLOT_4_AXI_PROTOCOL         (SLOT_4_AXI_PROTOCOL),  
    .C_SLOT_4_AXI_SUB_PROTOCOL     (SLOT_4_AXI_SUB_PROTOCOL),  
    .C_SLOT_4_FIFO_ENABLE          (C_SLOT_4_FIFO_ENABLE), 
    .C_SLOT_5_AXI_ADDR_WIDTH       (C_SLOT_5_AXI_ADDR_WIDTH), 
    .C_SLOT_5_AXI_DATA_WIDTH       (C_SLOT_5_AXI_DATA_WIDTH), 
    .C_SLOT_5_AXI_ID_WIDTH         (C_SLOT_5_AXI_ID_WIDTH), 
    .C_SLOT_5_AXI_PROTOCOL         (SLOT_5_AXI_PROTOCOL), 
    .C_SLOT_5_AXI_SUB_PROTOCOL     (SLOT_5_AXI_SUB_PROTOCOL),  
    .C_SLOT_5_FIFO_ENABLE          (C_SLOT_5_FIFO_ENABLE),
    .C_SLOT_6_AXI_ADDR_WIDTH       (C_SLOT_6_AXI_ADDR_WIDTH),
    .C_SLOT_6_AXI_DATA_WIDTH       (C_SLOT_6_AXI_DATA_WIDTH),
    .C_SLOT_6_AXI_ID_WIDTH         (C_SLOT_6_AXI_ID_WIDTH),
    .C_SLOT_6_AXI_PROTOCOL         (SLOT_6_AXI_PROTOCOL),
    .C_SLOT_6_AXI_SUB_PROTOCOL     (SLOT_6_AXI_SUB_PROTOCOL),  
    .C_SLOT_6_FIFO_ENABLE          (C_SLOT_6_FIFO_ENABLE),
    .C_SLOT_7_AXI_ADDR_WIDTH       (C_SLOT_7_AXI_ADDR_WIDTH),
    .C_SLOT_7_AXI_DATA_WIDTH       (C_SLOT_7_AXI_DATA_WIDTH),
    .C_SLOT_7_AXI_ID_WIDTH         (C_SLOT_7_AXI_ID_WIDTH),
    .C_SLOT_7_AXI_PROTOCOL         (SLOT_7_AXI_PROTOCOL),
    .C_SLOT_7_AXI_SUB_PROTOCOL     (SLOT_7_AXI_SUB_PROTOCOL),  
    .C_SLOT_7_FIFO_ENABLE          (C_SLOT_7_FIFO_ENABLE),
    .C_REG_ALL_MONITOR_SIGNALS     (C_REG_ALL_MONITOR_SIGNALS),
    .C_EXT_EVENT0_FIFO_ENABLE      (C_EXT_EVENT0_FIFO_ENABLE),
    .C_EXT_EVENT1_FIFO_ENABLE      (C_EXT_EVENT1_FIFO_ENABLE),
    .C_EXT_EVENT2_FIFO_ENABLE      (C_EXT_EVENT2_FIFO_ENABLE),
    .C_EXT_EVENT3_FIFO_ENABLE      (C_EXT_EVENT3_FIFO_ENABLE),
    .C_EXT_EVENT4_FIFO_ENABLE      (C_EXT_EVENT4_FIFO_ENABLE),
    .C_EXT_EVENT5_FIFO_ENABLE      (C_EXT_EVENT5_FIFO_ENABLE),
    .C_EXT_EVENT6_FIFO_ENABLE      (C_EXT_EVENT6_FIFO_ENABLE),
    .C_EXT_EVENT7_FIFO_ENABLE      (C_EXT_EVENT7_FIFO_ENABLE),
    .C_ENABLE_TRACE                (C_ENABLE_TRACE),
    .C_FIFO_AXIS_DEPTH             (C_FIFO_AXIS_DEPTH), 
    .C_FIFO_AXIS_TDATA_WIDTH       (C_FIFO_AXIS_TDATA_WIDTH), 
    .C_AXIS_DWIDTH_ROUND_TO_32     (C_AXIS_DWIDTH_ROUND_TO_32),
    .C_FIFO_AXIS_TID_WIDTH         (C_FIFO_AXIS_TID_WIDTH), 
    .C_FIFO_AXIS_SYNC              (C_FIFO_AXIS_SYNC), 
    .C_SHOW_AXI_IDS                (C_SHOW_AXI_IDS),
    .C_SHOW_AXI_LEN                (C_SHOW_AXI_LEN),
    .C_EN_WR_ADD_FLAG              (C_EN_WR_ADD_FLAG), 
    .C_EN_FIRST_WRITE_FLAG         (C_EN_FIRST_WRITE_FLAG), 
    .C_EN_LAST_WRITE_FLAG          (C_EN_LAST_WRITE_FLAG), 
    .C_EN_RESPONSE_FLAG            (C_EN_RESPONSE_FLAG), 
    .C_EN_RD_ADD_FLAG              (C_EN_RD_ADD_FLAG), 
    .C_EN_FIRST_READ_FLAG          (C_EN_FIRST_READ_FLAG), 
    .C_EN_LAST_READ_FLAG           (C_EN_LAST_READ_FLAG), 
    .C_EN_SW_REG_WR_FLAG           (C_EN_SW_REG_WR_FLAG), 
    .C_EN_EXT_EVENTS_FLAG          (C_EN_EXT_EVENTS_FLAG),
    .C_LOG_DATA_OFFLD              (C_LOG_DATA_OFFLD)  ,
    .S_AXI_OFFLD_ID_WIDTH          (S_AXI_OFFLD_ID_WIDTH),  
    .C_EN_ALL_TRACE                (C_EN_ALL_TRACE)  

        ) profile_trace_mode_inst
    (
      .s_axi_aclk        (s_axi_aclk),
      .s_axi_aresetn     (s_axi_aresetn),
      .s_axi_awaddr      (s_axi_awaddr_int),
      .s_axi_awvalid     (s_axi_awvalid),
      .s_axi_awid        (s_axi_awid),           
      .s_axi_awready     (s_axi_awready),
      .s_axi_wdata       (s_axi_wdata),
      .s_axi_wstrb       (s_axi_wstrb),
      .s_axi_wvalid      (s_axi_wvalid),
      .s_axi_wready      (s_axi_wready),
      .s_axi_bresp       (s_axi_bresp),
      .s_axi_bvalid      (s_axi_bvalid),
      .s_axi_bid         (s_axi_bid),      
      .s_axi_bready      (s_axi_bready),
      .s_axi_araddr      (s_axi_araddr_int),
      .s_axi_arvalid     (s_axi_arvalid),
      .s_axi_arid        (s_axi_arid),     
      .s_axi_arready     (s_axi_arready),
      .s_axi_rdata       (s_axi_rdata),
      .s_axi_rresp       (s_axi_rresp),
      .s_axi_rvalid      (s_axi_rvalid),
      .s_axi_rid         (s_axi_rid),     
      .s_axi_rready      (s_axi_rready),
      .slot_0_axi_aclk   (slot_0_axi_aclk) ,
      .slot_0_axi_aresetn (slot_0_axi_aresetn),
      .slot_0_axi_awid    (slot_0_axi_awid),
      .slot_0_axi_awaddr  (slot_0_axi_awaddr),
      .slot_0_axi_awprot  (slot_0_axi_awprot),
      .slot_0_axi_awlen   (slot_0_axi_awlen_i),
      .slot_0_axi_awsize  (slot_0_axi_awsize),
      .slot_0_axi_awburst (slot_0_axi_awburst),
      .slot_0_axi_awcache (slot_0_axi_awcache),
      .slot_0_axi_awlock  (slot_0_axi_awlock[0:0]),
      .slot_0_axi_awvalid (slot_0_axi_awvalid),
      .slot_0_axi_awready (slot_0_axi_awready),
      .slot_0_axi_wdata   (slot_0_axi_wdata),
      .slot_0_axi_wstrb   (slot_0_axi_wstrb),
      .slot_0_axi_wlast   (slot_0_axi_wlast_i),
      .slot_0_axi_wvalid  (slot_0_axi_wvalid),
      .slot_0_axi_wready  (slot_0_axi_wready),
      .slot_0_axi_bid     (slot_0_axi_bid),
      .slot_0_axi_bresp   (slot_0_axi_bresp),
      .slot_0_axi_bvalid  (slot_0_axi_bvalid),
      .slot_0_axi_bready  (slot_0_axi_bready),
      .slot_0_axi_arid    (slot_0_axi_arid),
      .slot_0_axi_araddr  (slot_0_axi_araddr),
      .slot_0_axi_arlen   (slot_0_axi_arlen_i),
      .slot_0_axi_arsize  (slot_0_axi_arsize),
      .slot_0_axi_arburst (slot_0_axi_arburst),
      .slot_0_axi_arcache (slot_0_axi_arcache),
      .slot_0_axi_arprot  (slot_0_axi_arprot),
      .slot_0_axi_arlock  (slot_0_axi_arlock[0:0]),
      .slot_0_axi_arvalid (slot_0_axi_arvalid),
      .slot_0_axi_arready (slot_0_axi_arready),
      .slot_0_axi_rid     (slot_0_axi_rid),
      .slot_0_axi_rdata   (slot_0_axi_rdata),
      .slot_0_axi_rresp   (slot_0_axi_rresp),
      .slot_0_axi_rlast   (slot_0_axi_rlast_i),
      .slot_0_axi_rvalid  (slot_0_axi_rvalid),
      .slot_0_axi_rready  (slot_0_axi_rready),
      .slot_0_ext_trig    (slot_0_ext_trig),
      .slot_0_ext_trig_stop (slot_0_ext_trig_stop),
      .slot_1_axi_aclk      (slot_1_axi_aclk),
      .slot_1_axi_aresetn   (slot_1_axi_aresetn),
      .slot_1_axi_awid      (slot_1_axi_awid),
      .slot_1_axi_awaddr    (slot_1_axi_awaddr),
      .slot_1_axi_awprot    (slot_1_axi_awprot),
      .slot_1_axi_awlen     (slot_1_axi_awlen_i),
      .slot_1_axi_awsize    (slot_1_axi_awsize),
      .slot_1_axi_awburst   (slot_1_axi_awburst),
      .slot_1_axi_awcache   (slot_1_axi_awcache),
      .slot_1_axi_awlock    (slot_1_axi_awlock[0:0]),
      .slot_1_axi_awvalid   (slot_1_axi_awvalid),
      .slot_1_axi_awready   (slot_1_axi_awready),
      .slot_1_axi_wdata     (slot_1_axi_wdata),
      .slot_1_axi_wstrb     (slot_1_axi_wstrb),
      .slot_1_axi_wlast     (slot_1_axi_wlast_i),
      .slot_1_axi_wvalid    (slot_1_axi_wvalid),
      .slot_1_axi_wready    (slot_1_axi_wready),
      .slot_1_axi_bid       (slot_1_axi_bid),
      .slot_1_axi_bresp     (slot_1_axi_bresp),
      .slot_1_axi_bvalid    (slot_1_axi_bvalid),
      .slot_1_axi_bready    (slot_1_axi_bready),
      .slot_1_axi_arid      (slot_1_axi_arid),
      .slot_1_axi_araddr    (slot_1_axi_araddr),
      .slot_1_axi_arlen     (slot_1_axi_arlen_i),
      .slot_1_axi_arsize    (slot_1_axi_arsize),
      .slot_1_axi_arburst   (slot_1_axi_arburst),
      .slot_1_axi_arcache   (slot_1_axi_arcache),
      .slot_1_axi_arprot    (slot_1_axi_arprot),
      .slot_1_axi_arlock    (slot_1_axi_arlock[0:0]),
      .slot_1_axi_arvalid   (slot_1_axi_arvalid),
      .slot_1_axi_arready   (slot_1_axi_arready),
      .slot_1_axi_rid       (slot_1_axi_rid),
      .slot_1_axi_rdata     (slot_1_axi_rdata),
      .slot_1_axi_rresp     (slot_1_axi_rresp),
      .slot_1_axi_rlast     (slot_1_axi_rlast_i),
      .slot_1_axi_rvalid    (slot_1_axi_rvalid),
      .slot_1_axi_rready    (slot_1_axi_rready),
      .slot_1_ext_trig      (slot_1_ext_trig),
      .slot_1_ext_trig_stop (slot_1_ext_trig_stop),
      .slot_2_axi_aclk      (slot_2_axi_aclk),
      .slot_2_axi_aresetn   (slot_2_axi_aresetn),
      .slot_2_axi_awid      (slot_2_axi_awid),
      .slot_2_axi_awaddr    (slot_2_axi_awaddr),
      .slot_2_axi_awprot    (slot_2_axi_awprot),
      .slot_2_axi_awlen     (slot_2_axi_awlen_i),
      .slot_2_axi_awsize    (slot_2_axi_awsize),
      .slot_2_axi_awburst   (slot_2_axi_awburst),
      .slot_2_axi_awcache   (slot_2_axi_awcache),
      .slot_2_axi_awlock    (slot_2_axi_awlock[0:0]),
      .slot_2_axi_awvalid   (slot_2_axi_awvalid),
      .slot_2_axi_awready   (slot_2_axi_awready),
      .slot_2_axi_wdata     (slot_2_axi_wdata),
      .slot_2_axi_wstrb     (slot_2_axi_wstrb),
      .slot_2_axi_wlast     (slot_2_axi_wlast_i),
      .slot_2_axi_wvalid    (slot_2_axi_wvalid),
      .slot_2_axi_wready    (slot_2_axi_wready),
      .slot_2_axi_bid       (slot_2_axi_bid),
      .slot_2_axi_bresp     (slot_2_axi_bresp),
      .slot_2_axi_bvalid    (slot_2_axi_bvalid),
      .slot_2_axi_bready    (slot_2_axi_bready),
      .slot_2_axi_arid      (slot_2_axi_arid),
      .slot_2_axi_araddr    (slot_2_axi_araddr),
      .slot_2_axi_arlen     (slot_2_axi_arlen_i),
      .slot_2_axi_arsize    (slot_2_axi_arsize),
      .slot_2_axi_arburst   (slot_2_axi_arburst),
      .slot_2_axi_arcache   (slot_2_axi_arcache),
      .slot_2_axi_arprot    (slot_2_axi_arprot),
      .slot_2_axi_arlock    (slot_2_axi_arlock[0:0]),
      .slot_2_axi_arvalid   (slot_2_axi_arvalid),
      .slot_2_axi_arready   (slot_2_axi_arready),
      .slot_2_axi_rid       (slot_2_axi_rid),
      .slot_2_axi_rdata     (slot_2_axi_rdata),
      .slot_2_axi_rresp     (slot_2_axi_rresp),
      .slot_2_axi_rlast     (slot_2_axi_rlast_i),
      .slot_2_axi_rvalid    (slot_2_axi_rvalid),
      .slot_2_axi_rready    (slot_2_axi_rready),
      .slot_2_ext_trig      (slot_2_ext_trig),
      .slot_2_ext_trig_stop (slot_2_ext_trig_stop),
      .slot_3_axi_aclk      (slot_3_axi_aclk),
      .slot_3_axi_aresetn   (slot_3_axi_aresetn),
      .slot_3_axi_awid      (slot_3_axi_awid),
      .slot_3_axi_awaddr    (slot_3_axi_awaddr),
      .slot_3_axi_awprot    (slot_3_axi_awprot),
      .slot_3_axi_awlen     (slot_3_axi_awlen_i),
      .slot_3_axi_awsize    (slot_3_axi_awsize),
      .slot_3_axi_awburst   (slot_3_axi_awburst),
      .slot_3_axi_awcache   (slot_3_axi_awcache),
      .slot_3_axi_awlock    (slot_3_axi_awlock[0:0]),
      .slot_3_axi_awvalid   (slot_3_axi_awvalid),
      .slot_3_axi_awready   (slot_3_axi_awready),
      .slot_3_axi_wdata     (slot_3_axi_wdata),  
      .slot_3_axi_wstrb     (slot_3_axi_wstrb),
      .slot_3_axi_wlast     (slot_3_axi_wlast_i),
      .slot_3_axi_wvalid    (slot_3_axi_wvalid),
      .slot_3_axi_wready    (slot_3_axi_wready),
      .slot_3_axi_bid       (slot_3_axi_bid), 
      .slot_3_axi_bresp     (slot_3_axi_bresp),
      .slot_3_axi_bvalid    (slot_3_axi_bvalid), 
      .slot_3_axi_bready    (slot_3_axi_bready), 
      .slot_3_axi_arid      (slot_3_axi_arid),
      .slot_3_axi_araddr    (slot_3_axi_araddr),
      .slot_3_axi_arlen     (slot_3_axi_arlen_i), 
      .slot_3_axi_arsize    (slot_3_axi_arsize),
      .slot_3_axi_arburst   (slot_3_axi_arburst),
      .slot_3_axi_arcache   (slot_3_axi_arcache), 
      .slot_3_axi_arprot    (slot_3_axi_arprot),
      .slot_3_axi_arlock    (slot_3_axi_arlock[0:0]),
      .slot_3_axi_arvalid   (slot_3_axi_arvalid),
      .slot_3_axi_arready   (slot_3_axi_arready),
      .slot_3_axi_rid       (slot_3_axi_rid),
      .slot_3_axi_rdata     (slot_3_axi_rdata),
      .slot_3_axi_rresp     (slot_3_axi_rresp),
      .slot_3_axi_rlast     (slot_3_axi_rlast_i),
      .slot_3_axi_rvalid    (slot_3_axi_rvalid),
      .slot_3_axi_rready    (slot_3_axi_rready),
      .slot_3_ext_trig      (slot_3_ext_trig),
      .slot_3_ext_trig_stop (slot_3_ext_trig_stop),
      .slot_4_axi_aclk      (slot_4_axi_aclk),
      .slot_4_axi_aresetn   (slot_4_axi_aresetn),
      .slot_4_axi_awid      (slot_4_axi_awid),
      .slot_4_axi_awaddr    (slot_4_axi_awaddr),
      .slot_4_axi_awprot    (slot_4_axi_awprot),
      .slot_4_axi_awlen     (slot_4_axi_awlen_i),
      .slot_4_axi_awsize    (slot_4_axi_awsize),
      .slot_4_axi_awburst   (slot_4_axi_awburst),
      .slot_4_axi_awcache   (slot_4_axi_awcache),
      .slot_4_axi_awlock    (slot_4_axi_awlock[0:0]),
      .slot_4_axi_awvalid   (slot_4_axi_awvalid),
      .slot_4_axi_awready   (slot_4_axi_awready),
      .slot_4_axi_wdata     (slot_4_axi_wdata),
      .slot_4_axi_wstrb     (slot_4_axi_wstrb),
      .slot_4_axi_wlast     (slot_4_axi_wlast_i),
      .slot_4_axi_wvalid    (slot_4_axi_wvalid),
      .slot_4_axi_wready    (slot_4_axi_wready),
      .slot_4_axi_bid       (slot_4_axi_bid),
      .slot_4_axi_bresp     (slot_4_axi_bresp),
      .slot_4_axi_bvalid    (slot_4_axi_bvalid),
      .slot_4_axi_bready    (slot_4_axi_bready),
      .slot_4_axi_arid      (slot_4_axi_arid),
      .slot_4_axi_araddr    (slot_4_axi_araddr),
      .slot_4_axi_arlen     (slot_4_axi_arlen_i),
      .slot_4_axi_arsize    (slot_4_axi_arsize),
      .slot_4_axi_arburst   (slot_4_axi_arburst),
      .slot_4_axi_arcache   (slot_4_axi_arcache),
      .slot_4_axi_arprot    (slot_4_axi_arprot),
      .slot_4_axi_arlock    (slot_4_axi_arlock[0:0]),
      .slot_4_axi_arvalid   (slot_4_axi_arvalid),
      .slot_4_axi_arready   (slot_4_axi_arready),
      .slot_4_axi_rid       (slot_4_axi_rid),
      .slot_4_axi_rdata     (slot_4_axi_rdata),
      .slot_4_axi_rresp     (slot_4_axi_rresp),
      .slot_4_axi_rlast     (slot_4_axi_rlast_i),
      .slot_4_axi_rvalid    (slot_4_axi_rvalid),
      .slot_4_axi_rready    (slot_4_axi_rready),
      .slot_4_ext_trig      (slot_4_ext_trig),
      .slot_4_ext_trig_stop (slot_4_ext_trig_stop),
      .slot_5_axi_aclk      (slot_5_axi_aclk),
      .slot_5_axi_aresetn   (slot_5_axi_aresetn),
      .slot_5_axi_awid      (slot_5_axi_awid),
      .slot_5_axi_awaddr    (slot_5_axi_awaddr),
      .slot_5_axi_awprot    (slot_5_axi_awprot),
      .slot_5_axi_awlen     (slot_5_axi_awlen_i),
      .slot_5_axi_awsize    (slot_5_axi_awsize),
      .slot_5_axi_awburst   (slot_5_axi_awburst),
      .slot_5_axi_awcache   (slot_5_axi_awcache),
      .slot_5_axi_awlock    (slot_5_axi_awlock[0:0]),
      .slot_5_axi_awvalid   (slot_5_axi_awvalid),
      .slot_5_axi_awready   (slot_5_axi_awready),
      .slot_5_axi_wdata     (slot_5_axi_wdata),
      .slot_5_axi_wstrb     (slot_5_axi_wstrb),
      .slot_5_axi_wlast     (slot_5_axi_wlast_i),
      .slot_5_axi_wvalid    (slot_5_axi_wvalid),
      .slot_5_axi_wready    (slot_5_axi_wready),
      .slot_5_axi_bid       (slot_5_axi_bid),
      .slot_5_axi_bresp     (slot_5_axi_bresp),
      .slot_5_axi_bvalid    (slot_5_axi_bvalid),
      .slot_5_axi_bready    (slot_5_axi_bready),
      .slot_5_axi_arid      (slot_5_axi_arid),
      .slot_5_axi_araddr    (slot_5_axi_araddr),
      .slot_5_axi_arlen     (slot_5_axi_arlen_i),
      .slot_5_axi_arsize    (slot_5_axi_arsize),
      .slot_5_axi_arburst   (slot_5_axi_arburst),
      .slot_5_axi_arcache   (slot_5_axi_arcache),
      .slot_5_axi_arprot    (slot_5_axi_arprot),
      .slot_5_axi_arlock    (slot_5_axi_arlock[0:0]),
      .slot_5_axi_arvalid   (slot_5_axi_arvalid),
      .slot_5_axi_arready   (slot_5_axi_arready),
      .slot_5_axi_rid       (slot_5_axi_rid),
      .slot_5_axi_rdata     (slot_5_axi_rdata),
      .slot_5_axi_rresp     (slot_5_axi_rresp),
      .slot_5_axi_rlast     (slot_5_axi_rlast_i),
      .slot_5_axi_rvalid    (slot_5_axi_rvalid),
      .slot_5_axi_rready    (slot_5_axi_rready),
      .slot_5_ext_trig      (slot_5_ext_trig),
      .slot_5_ext_trig_stop (slot_5_ext_trig_stop),
      .slot_6_axi_aclk      (slot_6_axi_aclk),
      .slot_6_axi_aresetn   (slot_6_axi_aresetn),
      .slot_6_axi_awid      (slot_6_axi_awid),
      .slot_6_axi_awaddr    (slot_6_axi_awaddr),
      .slot_6_axi_awprot    (slot_6_axi_awprot),
      .slot_6_axi_awlen     (slot_6_axi_awlen_i),
      .slot_6_axi_awsize    (slot_6_axi_awsize),
      .slot_6_axi_awburst   (slot_6_axi_awburst),
      .slot_6_axi_awcache   (slot_6_axi_awcache),
      .slot_6_axi_awlock    (slot_6_axi_awlock[0:0]),
      .slot_6_axi_awvalid   (slot_6_axi_awvalid),
      .slot_6_axi_awready   (slot_6_axi_awready),
      .slot_6_axi_wdata     (slot_6_axi_wdata),
      .slot_6_axi_wstrb     (slot_6_axi_wstrb),
      .slot_6_axi_wlast     (slot_6_axi_wlast_i),
      .slot_6_axi_wvalid    (slot_6_axi_wvalid),
      .slot_6_axi_wready    (slot_6_axi_wready),
      .slot_6_axi_bid       (slot_6_axi_bid),
      .slot_6_axi_bresp     (slot_6_axi_bresp),
      .slot_6_axi_bvalid    (slot_6_axi_bvalid),
      .slot_6_axi_bready    (slot_6_axi_bready),
      .slot_6_axi_arid      (slot_6_axi_arid),
      .slot_6_axi_araddr    (slot_6_axi_araddr),
      .slot_6_axi_arlen     (slot_6_axi_arlen_i),
      .slot_6_axi_arsize    (slot_6_axi_arsize),
      .slot_6_axi_arburst   (slot_6_axi_arburst),
      .slot_6_axi_arcache   (slot_6_axi_arcache),
      .slot_6_axi_arprot    (slot_6_axi_arprot),
      .slot_6_axi_arlock    (slot_6_axi_arlock[0:0]),
      .slot_6_axi_arvalid   (slot_6_axi_arvalid),
      .slot_6_axi_arready   (slot_6_axi_arready),
      .slot_6_axi_rid       (slot_6_axi_rid),
      .slot_6_axi_rdata     (slot_6_axi_rdata),
      .slot_6_axi_rresp     (slot_6_axi_rresp),
      .slot_6_axi_rlast     (slot_6_axi_rlast_i),
      .slot_6_axi_rvalid    (slot_6_axi_rvalid),
      .slot_6_axi_rready    (slot_6_axi_rready),
      .slot_6_ext_trig      (slot_6_ext_trig),
      .slot_6_ext_trig_stop (slot_6_ext_trig_stop),
      .slot_7_axi_aclk      (slot_7_axi_aclk),
      .slot_7_axi_aresetn   (slot_7_axi_aresetn),
      .slot_7_axi_awid      (slot_7_axi_awid),
      .slot_7_axi_awaddr    (slot_7_axi_awaddr),
      .slot_7_axi_awprot    (slot_7_axi_awprot),
      .slot_7_axi_awlen     (slot_7_axi_awlen_i),
      .slot_7_axi_awsize    (slot_7_axi_awsize),
      .slot_7_axi_awburst   (slot_7_axi_awburst),
      .slot_7_axi_awcache   (slot_7_axi_awcache),
      .slot_7_axi_awlock    (slot_7_axi_awlock[0:0]),
      .slot_7_axi_awvalid   (slot_7_axi_awvalid),
      .slot_7_axi_awready   (slot_7_axi_awready),
      .slot_7_axi_wdata     (slot_7_axi_wdata),
      .slot_7_axi_wstrb     (slot_7_axi_wstrb),
      .slot_7_axi_wlast     (slot_7_axi_wlast_i),
      .slot_7_axi_wvalid    (slot_7_axi_wvalid),
      .slot_7_axi_wready    (slot_7_axi_wready),
      .slot_7_axi_bid       (slot_7_axi_bid),
      .slot_7_axi_bresp     (slot_7_axi_bresp),
      .slot_7_axi_bvalid    (slot_7_axi_bvalid),
      .slot_7_axi_bready    (slot_7_axi_bready),
      .slot_7_axi_arid      (slot_7_axi_arid),
      .slot_7_axi_araddr    (slot_7_axi_araddr),
      .slot_7_axi_arlen     (slot_7_axi_arlen_i),
      .slot_7_axi_arsize    (slot_7_axi_arsize),
      .slot_7_axi_arburst   (slot_7_axi_arburst),
      .slot_7_axi_arcache   (slot_7_axi_arcache),
      .slot_7_axi_arprot    (slot_7_axi_arprot),
      .slot_7_axi_arlock    (slot_7_axi_arlock[0:0]),
      .slot_7_axi_arvalid   (slot_7_axi_arvalid),
      .slot_7_axi_arready   (slot_7_axi_arready),
      .slot_7_axi_rid       (slot_7_axi_rid),
      .slot_7_axi_rdata     (slot_7_axi_rdata),
      .slot_7_axi_rresp     (slot_7_axi_rresp),
      .slot_7_axi_rlast     (slot_7_axi_rlast_i),
      .slot_7_axi_rvalid    (slot_7_axi_rvalid),
      .slot_7_axi_rready    (slot_7_axi_rready),
      .slot_7_ext_trig      (slot_7_ext_trig),
      .slot_7_ext_trig_stop (slot_7_ext_trig_stop),
      .ext_clk_0            (ext_clk_0),
      .ext_rstn_0           (ext_rstn_0),
      .ext_event_0_cnt_start(ext_event_0_cnt_start),
      .ext_event_0_cnt_stop (ext_event_0_cnt_stop),
      .ext_event_0          (ext_event_0),
      .ext_clk_1            (ext_clk_1),
      .ext_rstn_1           (ext_rstn_1),
      .ext_event_1_cnt_start(ext_event_1_cnt_start),
      .ext_event_1_cnt_stop (ext_event_1_cnt_stop),
      .ext_event_1          (ext_event_1),
      .ext_clk_2            (ext_clk_2),
      .ext_rstn_2           (ext_rstn_2),
      .ext_event_2_cnt_start(ext_event_2_cnt_start),
      .ext_event_2_cnt_stop (ext_event_2_cnt_stop),
      .ext_event_2          (ext_event_2),
      .ext_clk_3            (ext_clk_3),
      .ext_rstn_3           (ext_rstn_3),
      .ext_event_3_cnt_start(ext_event_3_cnt_start),
      .ext_event_3_cnt_stop (ext_event_3_cnt_stop),
      .ext_event_3          (ext_event_3),
      .ext_clk_4            (ext_clk_4),
      .ext_rstn_4           (ext_rstn_4),
      .ext_event_4_cnt_start(ext_event_4_cnt_start),
      .ext_event_4_cnt_stop (ext_event_4_cnt_stop),
      .ext_event_4          (ext_event_4),
      .ext_clk_5            (ext_clk_5),
      .ext_rstn_5           (ext_rstn_5),
      .ext_event_5_cnt_start(ext_event_5_cnt_start),
      .ext_event_5_cnt_stop (ext_event_5_cnt_stop),
      .ext_event_5          (ext_event_5),
      .ext_clk_6            (ext_clk_6),
      .ext_rstn_6           (ext_rstn_6),
      .ext_event_6_cnt_start(ext_event_6_cnt_start),
      .ext_event_6_cnt_stop (ext_event_6_cnt_stop),
      .ext_event_6          (ext_event_6),
      .ext_clk_7            (ext_clk_7),
      .ext_rstn_7           (ext_rstn_7),
      .ext_event_7_cnt_start(ext_event_7_cnt_start),
      .ext_event_7_cnt_stop (ext_event_7_cnt_stop),
      .ext_event_7          (ext_event_7),
      .capture_event        (capture_event_sync),
      .reset_event          (reset_event_sync),
      .core_aclk            (core_aclk),
      .core_aresetn         (core_aresetn),
      .m_axis_aclk          (m_axis_aclk),
      .m_axis_aresetn       (m_axis_aresetn),
      .m_axis_tdata         (m_axis_tdata),
      .m_axis_tstrb         (m_axis_tstrb),
      .m_axis_tvalid        (m_axis_tvalid),
      .m_axis_tid           (m_axis_tid),
      .m_axis_tready        (m_axis_tready),
      .s_axi_offld_aclk     (s_axi_offld_aclk    ),
      .s_axi_offld_aresetn  (s_axi_offld_aresetn ),
      .s_axi_offld_araddr   (s_axi_offld_araddr  ),
      .s_axi_offld_arvalid  (s_axi_offld_arvalid ),
      .s_axi_offld_arlen    (s_axi_offld_arlen   ),
      .s_axi_offld_arid     (s_axi_offld_arid    ),
      .s_axi_offld_arready  (s_axi_offld_arready ),
      .s_axi_offld_rready   (s_axi_offld_rready  ),
      .s_axi_offld_rdata    (s_axi_offld_rdata   ),
      .s_axi_offld_rresp    (s_axi_offld_rresp   ),
      .s_axi_offld_rvalid   (s_axi_offld_rvalid  ),
      .s_axi_offld_rid      (s_axi_offld_rid     ),
      .s_axi_offld_rlast    (s_axi_offld_rlast   ),
      .interrupt            (interrupt),
      .trigger_in           (trigger_in),
      .trigger_in_ack       (trigger_in_ack)
  );

  end
  endgenerate

  
endmodule


